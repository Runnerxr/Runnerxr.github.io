<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-剑指offer 40最小的k个数(easy)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/15/%E5%89%91%E6%8C%87offer%2040%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0(easy)/" class="article-date">
  <time class="dt-published" datetime="2022-03-15T06:21:25.000Z" itemprop="datePublished">2022-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/15/%E5%89%91%E6%8C%87offer%2040%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0(easy)/">剑指offer 40最小的k个数(easy)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>leetcoad链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/</a><br>视频链接：<a target="_blank" rel="noopener" href="https://www.algomooc.com/1744.html">https://www.algomooc.com/1744.html</a><br>属于top k类型的题目<br>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。<br><strong>使用最原始的暴力的方法如下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLeastNumbers</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        arr.sort()</span><br><span class="line">        <span class="keyword">return</span> arr[:k]</span><br></pre></td></tr></table></figure>
<p><strong>采用借助快速排序的思路来解题：</strong><br>如果在划分后，基准数正好是第k+1小的数字，基准数左边所有的数字就是题目的最下的k个数<br>判断每次划分后，基准数在数组中的索引是否等于k,如果是直接返回数组的前k个数字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLeastNumbers</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> k &gt;= <span class="built_in">len</span>(arr): </span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        <span class="comment">#定义快速排序的函数（相当于只排一部分）</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">left,right</span>):</span><br><span class="line">            <span class="comment"># 定义两个游标分别指向0和末尾的位置,选择基准点为该调整范围的第一个值</span></span><br><span class="line">            start = left</span><br><span class="line">            end = right</span><br><span class="line">            pivot = arr[left]</span><br><span class="line"></span><br><span class="line">            <span class="comment">#循环判断，直到遍历全部</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="comment"># 从右向左 arr[right]&gt;pivot 则right-=1（从右开始查找大于基准点的值）</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[right] &gt;= pivot:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 将right索引对应的元素赋值给left（这个位置的值先移动到左边）</span></span><br><span class="line">                arr[left] = arr[right]</span><br><span class="line">                 <span class="comment"># 从左往右  arr[left]&lt;pivot  则left+=1（从左开始查找小于基准点的值）</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[left] &lt;pivot:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                 <span class="comment"># 将left索引对应的元素赋值给right（这个位置的值先移动到右边）</span></span><br><span class="line">                arr[right] = arr[left]</span><br><span class="line">            <span class="comment">#将基准数放置到对应的位置（写回改成的值）</span></span><br><span class="line">            arr[left]=pivot</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 以下的部分不同于快速排序（快速排序是将所有的数字都排好了，这里我只排我需要的那部分就行了。）</span></span><br><span class="line">            <span class="keyword">if</span> k &lt; left: </span><br><span class="line">                <span class="keyword">return</span> quick_sort(start, left - <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">if</span> k &gt; left: </span><br><span class="line">                <span class="keyword">return</span> quick_sort(left + <span class="number">1</span>, end)</span><br><span class="line">            <span class="keyword">return</span> arr[:k]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> quick_sort(<span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/15/%E5%89%91%E6%8C%87offer%2040%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0(easy)/" data-id="claquc62x001uz0tk57oa63z6" data-title="剑指offer 40最小的k个数(easy)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" rel="tag">算法专栏（用python注写）</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-提交leetcoad后的一些常见的报错" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/15/%E6%8F%90%E4%BA%A4leetcoad%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8A%A5%E9%94%99/" class="article-date">
  <time class="dt-published" datetime="2022-03-15T02:00:19.000Z" itemprop="datePublished">2022-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/15/%E6%8F%90%E4%BA%A4leetcoad%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8A%A5%E9%94%99/">python在提交leetcoad后的一些常见的报错如下（日常整理，报错就整理）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>第一类报错：</strong><br>local variable xxx referenced before assignment<br> #赋值前引用的局部变量xxx<br>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44198436/article/details/100051651">https://blog.csdn.net/qq_44198436/article/details/100051651</a><br>局部变量指的在函数内部定义并使用的变量，它只在函数内部有效。<br>全局变量指的是能作用于函数内外的变量，即全局变量既可以在各个函数的外部使用，也可以在各函数内部使用。<br><strong>test_1:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    num=<span class="number">5</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">main()</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<p><strong>报错如下：</strong><br>NameError: name ‘num’ is not defined<br><strong>原因解释：</strong><br>这里是提示num没有被定义，因为num属于在main函数内部的变量，在函数体外面是不会被调用，解释器也不会认识这个num变量，只有当main函数调用时，才可以获得其内部一些变量，这就是局部变量。<br><strong>修改如下：</strong>使用global声明num为全局变量就可以</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num=<span class="number">5</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">main()</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<p><strong>test_2:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num=<span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    num=<span class="number">5</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">main()</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<p><strong>报错如下：</strong><br>UnboundLocalError: local variable ‘num’ referenced before assignment<br><strong>原因解释：</strong><br>这就是赋前引用局部变量，num在main函数外界定义一次，但在main函数内部又定义一次，python将优先处理在函数体内的变量，且调用在定义之前，所以在第三行print(num)报错，后面num变量赋值num&#x3D;5让num&#x3D;10失去全局效果。</p>
<p><strong>test_3:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span> num</span><br><span class="line">num=<span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    num=<span class="number">5</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(num))</span><br><span class="line">main()</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>
<p>报错原因解释：<br>进一步说明在函数体内部自称一体，num为全局变量，只能保证在函数体内部认识这个num变量，但在函数体内部对num变量进行的改变，依然要保证先赋值后调用。<br><strong>更改一：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span> num</span><br><span class="line">num=<span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment">#print(num)</span></span><br><span class="line">    num=<span class="number">5</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(num))</span><br><span class="line">main()</span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line">输出：</span><br><span class="line">main:<span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">**更改二：**</span><br><span class="line"><span class="keyword">global</span> num</span><br><span class="line">num=<span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment">#print(num)</span></span><br><span class="line">    <span class="comment">#num=5</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(num))</span><br><span class="line">main()</span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line">输出：</span><br><span class="line">main:<span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**更改三：**</span><br><span class="line">num=<span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    num=<span class="number">5</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(num))</span><br><span class="line">main()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;外部:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(num))</span><br></pre></td></tr></table></figure>
<p><strong>总结如下：</strong><br>Python 命名空间查找顺序:<br>假设我们要使用变量 runoob，则 Python 的查找顺序为：局部的命名空间去 -&gt; 全局命名空间 -&gt; 内置命名空间。<br>如果找不到变量 runoob，它将放弃查找并引发一个 NameError 异常:<br>NameError: name ‘runoob’ is not defined。</p>
<p><strong>第二类报错：</strong><br>TypeError: ‘NoneType‘ object is not subscriptable</p>
<p><strong>第三类报错：</strong><br>IndexError:list index out of range</p>
<p><strong>第四类报错：</strong><br>TypeError: <strong>init</strong>() takes 3 positional arguments but 4 were given</p>
<p>第五类错误：<br>TypeError: ‘int’ object is not iterable</p>
<p>其他错误：：解决方案对象没有属性（在左leetcoad16题：最接近三数之和的题目中遇到的）<br>AttributeError: ‘Solution’ object has no attribute ‘threeSumClosest’<br>    ret &#x3D; Solution().threeSumClosest(param_1, param_2)<br>Line 181 in _driver (Solution.py)<br>    _driver()<br>Line 192 in <module> (Solution.py)</p>
<p>在做leetcoad704二分查找的时候遇到的问题<br>其他错误：<br>SyntaxError: cannot assign to subscript here. Maybe you meant ‘&#x3D;&#x3D;’ instead of ‘&#x3D;’?<br>       ^^^^^^^^^<br>    if nums[mid] &#x3D; target:<br>Line 15  (Solution.py)<br>记录：这里是不能在这里分配下标，必须要用&#x3D;&#x3D;才行</p>
<p>TypeError: list indices must be integers or slices, not float<br>    if nums[mid] &#x3D;&#x3D; target:<br>Line 15 in search (Solution.py)<br>    ret &#x3D; Solution().search(param_1, param_2)<br>Line 56 in _driver (Solution.py)<br>    _driver()<br>Line 67 in <module> (Solution.py)<br>记录：列表必须是整数或者是切片，不能是浮点数<br>将mid &#x3D; left +(right - left) &#x2F;2改为mid &#x3D; left +(right - left) &#x2F;&#x2F;2</p>
<p>RecursionError: maximum recursion depth exceeded in comparison<br>python中在递归达到997层的时候就会报错</p>
<p>‘int’ object is not subscriptable<br>整数类型不能进行切片操作（能够进行切片即索引的只有：数组、字符串、元组以及range）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/15/%E6%8F%90%E4%BA%A4leetcoad%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8A%A5%E9%94%99/" data-id="claquc637002gz0tkgvg79fnk" data-title="python在提交leetcoad后的一些常见的报错如下（日常整理，报错就整理）" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-小众-基础类用法整理（附案例）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/14/%E5%B0%8F%E4%BC%97-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%94%A8%E6%B3%95%E6%95%B4%E7%90%86%EF%BC%88%E9%99%84%E6%A1%88%E4%BE%8B%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2022-03-14T11:29:38.000Z" itemprop="datePublished">2022-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/14/%E5%B0%8F%E4%BC%97-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%94%A8%E6%B3%95%E6%95%B4%E7%90%86%EF%BC%88%E9%99%84%E6%A1%88%E4%BE%8B%EF%BC%89/">勿删除！！！-杂项-小众-基础类用法整理（附案例）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="关于python中字符串索引的问题"><a href="#关于python中字符串索引的问题" class="headerlink" title="关于python中字符串索引的问题"></a>关于python中字符串索引的问题</h1><p>利用索引进行切片操作时，可包含三个参数:<br>如对列表来说即：list[start_index: stop_index: step]<br>起始位置 : start_index (空时默认为 0)。<br>起始位置 : start_index (空时默认为 0)。<br>步长: step (空时默认为 1，不能为 0)。<br>当起始位置或者终止位置为0的时候：</p>
<ol>
<li>当 step&gt;0，start_index 的空值下标为 0，stop_index 的空值下标为 length，step 的方向是左到右；</li>
<li>当 step&lt;0，start_index 的空值下标为 length，stop_index 的空值下标为 0，此时反向为右到左了！也即： start_index、 stop_index 空值代表的头和尾，是随着 step 的正负而改变的。
        
          <p class="article-more-link">
            <a href="/2022/03/14/%E5%B0%8F%E4%BC%97-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%94%A8%E6%B3%95%E6%95%B4%E7%90%86%EF%BC%88%E9%99%84%E6%A1%88%E4%BE%8B%EF%BC%89/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/14/%E5%B0%8F%E4%BC%97-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%94%A8%E6%B3%95%E6%95%B4%E7%90%86%EF%BC%88%E9%99%84%E6%A1%88%E4%BE%8B%EF%BC%89/" data-id="claquc6340029z0tkgsszemom" data-title="勿删除！！！-杂项-小众-基础类用法整理（附案例）" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-leetcoad基础知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/14/leetcoad%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2022-03-14T08:19:20.000Z" itemprop="datePublished">2022-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/14/leetcoad%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">刷leetcoad常见的不能够再常见的几个基础性的东西</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>关于python作用域的问题（未完待续）</strong><br>参考链接如下：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fireporsche/p/7813961.html">https://www.cnblogs.com/fireporsche/p/7813961.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Keep_Trying_Go/article/details/121860673">https://blog.csdn.net/Keep_Trying_Go/article/details/121860673</a><br>1.在函数内定义的局部变量只在该函数内可见，当函数运行结束后，在其内部定义的所有局部变量将被自动删除而不可访问。在函数内部使用global定义的全局变量当函数结束以后任然存在并且可以访问。<br>2.如果在函数内部修改一个定义在函数外的变量值，必须使用global明确声明，否则会自动创建新的局部变量。在函数内部通过global关键字类声明或定义全局变量，分为两种情况：<br>方式一的理解：<br>（1）一个变量已在函数外定义，如果在函数内需要修改这个变量的值，并将修改的结果反映到函数之外，可以在函数内用关键字global明确声明要使用已定义的同名全局变量。<br>（2）在函数内部直接使用global关键字将一个变量声明为全局变量，如果在函数外没有定义该全局变量，在调用这个函数之后，会自动创建新的全局变量。<br>方式二的理解：<br>（1）在函数内如果只引用某个变量的值而没有为其赋新值，该变量为（隐式的）全局变量；<br>（2）如果在函数内某条代码有为变量赋值的操作，该变量就被认为是（隐式的）局部变量，除非在函数内赋值操作 之前显示地用关键字global进行声明。<br>例如：局部变量和全局变量</p>
<p>创建一个和原数组相同的数组的问题：<br>例如原数组为[0,1,2,3,4]<br>现在创建一个和它一样的数组：<br>n &#x3D; 5<br>arr &#x3D; list(range(5))<br>这样返回的arr&#x3D; [0,1,2,3,4]</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/14/leetcoad%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" data-id="claquc62j000xz0tkbwlxafjg" data-title="刷leetcoad常见的不能够再常见的几个基础性的东西" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" rel="tag">python知识小记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-markdown教程（深度写作必备）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/13/markdown%E6%95%99%E7%A8%8B%EF%BC%88%E6%B7%B1%E5%BA%A6%E5%86%99%E4%BD%9C%E5%BF%85%E5%A4%87%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2022-03-13T03:17:30.000Z" itemprop="datePublished">2022-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/13/markdown%E6%95%99%E7%A8%8B%EF%BC%88%E6%B7%B1%E5%BA%A6%E5%86%99%E4%BD%9C%E5%BF%85%E5%A4%87%EF%BC%89/">markdown教程（深度写作必备）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1、标题-一级标题-二级标题-三级标题-四级标题-五级标题-六级标题2、段落人工换行3、字体斜体粗体粗斜体4、分割线"><a href="#1、标题-一级标题-二级标题-三级标题-四级标题-五级标题-六级标题2、段落人工换行3、字体斜体粗体粗斜体4、分割线" class="headerlink" title="1、标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题2、段落人工换行3、字体斜体粗体粗斜体4、分割线***"></a>1、标题<br># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题<br>2、段落<br><br/>人工换行<br>3、字体<br><em>斜体</em><br><strong>粗体</strong><br><em><strong>粗斜体</strong></em><br>4、分割线<br>***</h2><p>5、删除线<br><del>划掉文字</del><br>6、下划线<br><u>下划线<u><br>7、无序列表<br>*第一项   +第一项   -第一项<br>*第二项   +第二项   -第二项<br>*第三项   +第三项   -第三项<br>8、有序列表<br>1.第一项<br>2.第二项<br>9、区块</p>
<blockquote>
<p>最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套<br>10、链接地址<br><a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a><br>[1]:<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a><br>11、<img src="/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="属性文本"><br>12、表格</p>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>13、添加图片</td>
<td></td>
</tr>
<tr>
<td><img src="/"></td>
<td></td>
</tr>
</tbody></table>
</blockquote>
</blockquote>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/13/markdown%E6%95%99%E7%A8%8B%EF%BC%88%E6%B7%B1%E5%BA%A6%E5%86%99%E4%BD%9C%E5%BF%85%E5%A4%87%EF%BC%89/" data-id="claquc62l0011z0tkg5ja0v14" data-title="markdown教程（深度写作必备）" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-跳跃游戏--leetcoad55题(middle)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/13/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F--leetcoad55%E9%A2%98(middle)/" class="article-date">
  <time class="dt-published" datetime="2022-03-13T03:08:52.000Z" itemprop="datePublished">2022-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/13/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F--leetcoad55%E9%A2%98(middle)/">跳跃游戏--leetcoad55题(middle)-后续补充动态规划的算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>leetcoad链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/">https://leetcode-cn.com/problems/jump-game/</a><br>视频链接：<a target="_blank" rel="noopener" href="https://www.algomooc.com/972.html">https://www.algomooc.com/972.html</a><br>总的来说，这里举的两道跳跃游戏的题目，就是关键的那一点思想，懂了就是懂了，难的就在于贪心的理解。再次看题或者做题的时候，就要跳出题目的框架去仔细的理解，揣摩里面的贪心思想。其实投过这些题目可以反思很多问题，对于之前做过的题目反思：思路还是否记得，代码是否可以复盘，对于没有做过的题目，思路是否移植到该题上面，刷题的目的不就在于这上面嘛，加油！！！！，刷题也要有目的的去刷。</p>
<p>题目描述：给定一个非负整数数组 nums ，你最初位于<strong>数组的 第一个下标</strong> 。<br>数组中的<strong>每个元素</strong>代表你在<strong>该位置可以跳跃的最大长度</strong>。<br>判断你是否<strong>能够到达最后一个下标</strong>。<br>示例一：<br>输入：nums &#x3D; [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。<br>示例二：<br>输入：nums &#x3D; [3,2,1,0,4]<br>输出：false<br>解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。<br><strong>用贪心的做法来做：</strong><br>解题的关键：先让其跳到尽可能远的位置(也就是贪心所在)<br>别想那么多，就<strong>挨着跳</strong><br>相应的核心步骤如下：</p>
<ol>
<li>如果某一个作为起跳点的格子可以跳跃的距离是3，那么表示后面的三个格子都可以作为起跳点（反向理解也行：如果一个起跳点可以达到某个位置，那么这个位置左侧的所有位置都能到达）</li>
<li>如果<strong>对每一个起跳点的格子都尝试跳一次</strong>，把<strong>能跳到的最远的距离不断更新</strong></li>
<li>如果<strong>可以一直跳到最后</strong>，就成功了。（当index已经越过max_distance的时候，就可以返回True,没有越过，说明<strong>在某个地方直接停住了</strong>，不走了，直接返回False）</li>
</ol>
<p>以实例1举例来说<br><img src="https://runnerxr.github.io/post-images/1653205948074.png"><br><img src="https://runnerxr.github.io/post-images/1653206773807.png"><br>从索引为0的位置看起，他能到的最远的位置是索引为2的位置，在这个位置它能到达的最远位置是索引为4（此时的元素下标为2，值为2），但是我们想到<strong>既然能够达到索引为2的位置就必然能够达到索引为1的位置</strong>，从这个位置出发的时候发现，能够到达的最远位置为索引5（该位置的下标为1，值为4），那么比较两者，我会<strong>贪心的选择先达到索引为1的位置再说</strong>，现在从索引为1的位置开始重新出发：最远可以到达索引为5，它必然也能够索引为2 3 4的位置，我们挨个的让从索引为1的分别跳到索引为2 3 4 ，他们所能跳到的最远的距离分别是：索引为4 6 5 ，此时我们贪心的选择索引3这个位置，因为它能达到的最大位置已经超过了记录的值（5），<strong>这样我们就做了第二次选择</strong>：从索引为1跳到索引为的位置，<strong>最后从索引为3的位置跳到索引6</strong>，此时索引6正好已经达到了数组的末尾，说明可以达到。返回True<br>以下的两种解法都是自己在初学的时候做的一点记录，不能说有错，只是没有理解其中的精髓，现在再看又是一脸茫然，有用嘛，有用，有达到学习的效果嘛，不是那么大，在短时间的突击学习中，知识点没有那么牢靠的掌握,终究不是自己的知识。<br>从实例2我们也可以看出来，这种情况无论无何也无法达到数组的末尾<br><img src="https://runnerxr.github.io/post-images/1653207421811.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 定义最开始的位置和能到达的最远的下标</span></span><br><span class="line">        i,farthest=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 如果采用while,循环结束的条件是什么？</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;=farthest:</span><br><span class="line">            <span class="comment"># 更新farthest</span></span><br><span class="line">            farthest=<span class="built_in">max</span>(farthest,i+nums[i])</span><br><span class="line">            <span class="comment"># 如果发现farthest能够达到数组的末尾</span></span><br><span class="line">            <span class="keyword">if</span> farthest &gt;=n:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i +=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 跳出循环之后，再次查看是否能否到达数组的末尾</span></span><br><span class="line">        <span class="comment"># 为什么还有判断?前面返回是因为通过前面的位置，几步就能跳到或者跳过末尾</span></span><br><span class="line">        <span class="comment"># 那什么时候是返回空的了？此时已经到了或超过数组的末尾了，是在最后一步才成功</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;=n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">    res=Solution().canJump(nums)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<p>如果采用的for循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        farthest = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i &gt;farthest:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            farthest = <span class="built_in">max</span>(farthest,nums[i] + i)</span><br><span class="line">        <span class="keyword">return</span> farthest &gt;=n-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>采用吴师兄的算法思路来解题：</strong><br>jump[i] 就是当前的索引值 i 加上该位置可以跳跃的最大长度 nums[i]<br>相较来说，吴师兄的这个解法中规中矩的算是最好理解的一种思路吧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">#创建一个jump数组，用来存储下标值+跳得最远的距离</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        jump = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            jump[i] = i + nums[i]</span><br><span class="line">        <span class="comment">#初始化指针</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="comment">#初始化：记录可以达到的最远的距离</span></span><br><span class="line">        maxjump = jump[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#写一个循环：当当前的值小于整个数组的长度，并且当前值小于可以跳得最远的距离,如果不满足就跳出相应的循环</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; n <span class="keyword">and</span> index &lt;=maxjump:</span><br><span class="line">            <span class="comment">#判断当前的元素能够跳得最远的距离是否大于记录的最远的距离</span></span><br><span class="line">            <span class="keyword">if</span> maxjump &lt; jump[index]:</span><br><span class="line">                <span class="comment">#将maxjump的值用jump[index]来更新</span></span><br><span class="line">                maxjump = jump[index]</span><br><span class="line">            index +=<span class="number">1</span></span><br><span class="line">        <span class="comment">#如果index能够达到数组的末尾（隐含的是index &gt;=n）</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; n -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment">#否则说明无法达到最后一个下标</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h1 id="leetcoad跳跃游戏II"><a href="#leetcoad跳跃游戏II" class="headerlink" title="leetcoad跳跃游戏II"></a>leetcoad跳跃游戏II</h1><p>参考链接：<a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/3/27/100/">https://labuladong.gitee.io/algo/3/27/100/</a><br>这一题是在上一题上进行翻版的，这里尝试既用贪心算法又用到动态规划的思路来解题，对这两种算法有一个结合的认识。<br>题目描述：给你一个非负整数数组 nums ，你最初位于数组的第一个位置。<br>数组中的<strong>每个元素代表你在该位置可以跳跃的最大长度</strong>。<br>你的目标是<strong>使用最少的跳跃次数到达数组的最后一个位置</strong>（这里就隐含了它肯定是能够达到数组的末尾的，注意和跳跃游戏这道题进行比较）。<br>假设你<strong>总是可以到达</strong>数组的最后一个位置。<br>示例 1:<br>输入: nums &#x3D; [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。<br>示例 2:<br>输入: nums &#x3D; [2,3,0,1,4]<br>输出: 2<br>采用贪心的思路：<br><img src="https://runnerxr.github.io/post-images/1653321982119.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#  你可以选择跳1步  2步</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 站在索引i，最多能跳到索引end</span></span><br><span class="line">        end=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 从索引[i,end]起跳，最远能跳到的距离</span></span><br><span class="line">        far=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 记录跳跃次数</span></span><br><span class="line">        jump=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">            far=<span class="built_in">max</span>(nums[i]+i,far)</span><br><span class="line">            <span class="keyword">if</span> end==i:</span><br><span class="line">                jump+=<span class="number">1</span></span><br><span class="line">                end=far</span><br><span class="line">        <span class="keyword">return</span> jump</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">    res=Solution().jump(nums)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<p>贪心思路一：反向查找出出发位置<br>目标是达到数组的最后一个位置，<strong>考虑最后一步跳跃前所在的位置，该位置通过跳跃能够达到最后一个位置</strong>（重要的是这里的思考的逻辑和方向的问题）。如果有<strong>多个位置</strong>跳跃都能<strong>达到最后的一个位置</strong>，我们应该如何处理的问题？<br><strong>答案是</strong>：</p>
<ol>
<li>选择距离最后一个元素最远的那个位置（下标最小的那个位置），可以从左到右遍历数组之后，选择第一个满足要求的位置。</li>
<li>继续贪心的选择倒数第二个跳跃前的位置</li>
<li>依次类推，直到找到数组最开始的那个位置。</li>
</ol>
<p>贪心思路二：正向查找可到达的最大位置<br>贪心的进行正向的查找，<strong>每次找到可到达的最远位置</strong>，就可以在线性的时间内得到最少的跳跃次数</p>
<p><strong>采用动态规划的思路来解题：</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/13/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F--leetcoad55%E9%A2%98(middle)/" data-id="claquc63i002yz0tkdeegfh9z" data-title="跳跃游戏--leetcoad55题(middle)-后续补充动态规划的算法" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" rel="tag">算法专栏（用python注写）</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Python交互模式导入自己写的模块的方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/13/Python%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F%E5%AF%BC%E5%85%A5%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2022-03-13T00:51:47.000Z" itemprop="datePublished">2022-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/13/Python%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F%E5%AF%BC%E5%85%A5%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95/">Python交互模式导入自己写的模块的方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>两种方法：<br>方法一：①把hello文件保存到D盘python的文件夹(python的安装文件夹内)内，然后在打开python开发环境时这样键入：D:\PyThon\python.exe</p>
<p>方法二：直接在交互式界面增加</p>
<blockquote>
<blockquote>
<blockquote>
<p>import sys<br>sys.path.append(‘E:\Python项目(new)’)<br>import hello</p>
</blockquote>
</blockquote>
</blockquote>
<p>如何在命令行导入自己写的模块的问题：<br>1.自定义模块与所需要调用自定义模块的文件在同一文件夹下<br>2.自定义模块与所需要调用自定义模块的文件不在同一文件夹下<br>3.找到本地库的路径<br>4.手动给python添加搜索路径导入本地模…</p>
<p>第一种在同一个文件夹内的情况<br><img src="https://runnerxr.github.io/post-images/1647134155422.png"><br><img src="https://runnerxr.github.io/post-images/1647134280132.png"><br><img src="https://runnerxr.github.io/post-images/1647134267209.png"></p>
<p>第二种：通过sys模块导入自定义模块的path（两者不在同一个目录下面）<br>import sys<br>sys.path.append(r”E:\Python项目(new)”)<br>import print_func<br>print(“Done!”)</p>
<p>第三种，通过pth文件找到自定义模块<br>这个方法原理就是利用了系统变量，python会扫描path变量的路径来导入模块，可以在系统path里面添加。但是我还是推荐使用pth文件添加。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/13/Python%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F%E5%AF%BC%E5%85%A5%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95/" data-id="claquc6270009z0tk47o6451c" data-title="Python交互模式导入自己写的模块的方法" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" rel="tag">python知识小记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-常见的几种排序的基础知识汇总" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/10/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/" class="article-date">
  <time class="dt-published" datetime="2022-03-10T14:00:50.000Z" itemprop="datePublished">2022-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/10/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/">常见的几种排序的基础知识汇总（内化为自己的：important）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>写在前面：常见的几种排序的思路以及代码要直接背下来，烂熟于心的程度，形成自己的东西并复刻在脑海里面。其中快速排序、归并排序以及堆排序是高级排序。冒泡、选择、插入都是常用的一些排序，需要知晓原理和相应的代码细节。算是第二次全面的回顾了，所以下一次如果要写，应该是十分的熟悉才对。 </p>
<ol>
<li>冒泡排列(Bubble sort) </li>
<li>简单选择排序(Selection sort)</li>
<li>插入排序(Insertion sort)</li>
<li>快速排序(Quick sort) **</li>
<li>计数排序</li>
<li>归并排序(Merge Sort)  **</li>
<li>堆排序(Heap Sort) **<br>常见排序的一个算法效率的分析，总体来说堆排序时流皮的，时间复杂度：O(nlogn),空间复杂度：O(1)<br><img src="https://runnerxr.github.io/post-images/1651828935490.png"><br><strong>1、冒泡排列(Bubble sort)：</strong><br><img src="https://runnerxr.github.io/post-images/1651821272738.gif"><br>这种应该是最常见，也是最好理解的，是一种相对很暴力的过程：从左到右不断交换相邻逆序的元素，需要深入理解</li>
</ol>
<ul>
<li>类别：基于交换的排序算法</li>
<li>多次遍历待排序的数组</li>
<li>每轮遍历，依次比较两个相邻的元素，如果顺序错误，将这两个元素交换，使得较小的元素放在较大的元素前面，这样，一轮遍历之后，最大的元素被交换到了序列尾部<ul>
<li>外层循环需要遍历的次数，n个元素的排列，需要n-1次遍历</li>
<li>内层循环需要n-i-1次遍历，代表i次循环中比较的次数</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j]&gt;arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j],arr[j+<span class="number">1</span>]=arr[j+<span class="number">1</span>],arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">arr=[<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">44</span>, <span class="number">99</span>]</span><br><span class="line">res=bubble_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># [3, 3, 5, 6, 7, 11, 22, 44, 99] </span></span><br><span class="line"></span><br><span class="line">**增加一种计数的功能：**</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bubble_sort2</span>(<span class="params">arr</span>):</span><br><span class="line">        <span class="comment">#相邻两个元素进行比较，如果发现位置错误则进行交换</span></span><br><span class="line">        n=<span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-i-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> arr[j]&gt;arr[j+<span class="number">1</span>]:</span><br><span class="line">                    arr[j],arr[j+<span class="number">1</span>]=arr[j+<span class="number">1</span>],arr[j]</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">            <span class="comment">#判断count的值是否等于0，如果等于0说明没有交换</span></span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p><strong>2、简单选择排序(Selection sort)：</strong><br><img src="https://runnerxr.github.io/post-images/1651821139895.gif"><br>附上这张动图进行理解<br>选择排序的思想：每一趟（第i趟）在后面n-i+1个待排序元素中选取关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟做完，待排序元素只剩1个，就不用再选了。</p>
<ul>
<li>多次遍历待排序的数组</li>
<li>每轮遍历，从待排序序列种选出最小的元素，存放到已排序序列的末尾，即和待排序序列中的开始元素进行交换<ul>
<li>外层循环寻找最小元素的次数，n个元素的排序，需要进行n-1次选择</li>
<li>内层循环需要n-i-1次，代表第i次循环中比较的次数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">99</span>, <span class="number">11</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">99</span>, <span class="number">11</span>]  <span class="comment">#第一次</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">99</span>, <span class="number">11</span>]  <span class="comment">#第二次</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">99</span>, <span class="number">11</span>]  <span class="comment">#第三次</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">99</span>, <span class="number">11</span>]  <span class="comment">#第四次</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">99</span>, <span class="number">44</span>]  <span class="comment">#第五次</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">99</span>, <span class="number">44</span>]  <span class="comment">#第六次</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">44</span>, <span class="number">99</span>]  <span class="comment">#第七次</span></span><br><span class="line"></span><br><span class="line">[<span class="number">7</span>, <span class="number">5</span>,(<span class="number">99</span>,<span class="number">1</span>), <span class="number">3</span>, <span class="number">6</span>, <span class="number">44</span>, <span class="number">22</span>, (<span class="number">99</span>,<span class="number">2</span>), <span class="number">11</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>,<span class="number">3</span>, <span class="number">6</span>, <span class="number">44</span>, <span class="number">22</span>, (<span class="number">99</span>,<span class="number">2</span>),(<span class="number">99</span>,<span class="number">1</span>)]</span><br><span class="line"><span class="comment">#从列表中选择最大的元素放到最后一个位置</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n=<span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>): <span class="comment"># 0  n-1  O(n)  一共进行n-1趟的</span></span><br><span class="line">        <span class="comment">#剩余列表中最小值的索引</span></span><br><span class="line">        min_index=i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n): <span class="comment">#O(n)   #在剩下的i+1~n-1中去寻找最小的元素</span></span><br><span class="line">            <span class="keyword">if</span> arr[min_index]&gt;arr[j]:    </span><br><span class="line">                min_index=j    <span class="comment">#更新最小元素的位置</span></span><br><span class="line">        <span class="keyword">if</span> min_index!=i:</span><br><span class="line">            arr[i],arr[min_index]=arr[min_index],arr[i]   <span class="comment">#如果需要更新就需要进行相应的交换操作</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"><span class="comment">#arr=[5, 1, 3, 4, 2]         </span></span><br><span class="line">arr=[<span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">99</span>, <span class="number">11</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;排序后数组：&#x27;</span>)</span><br><span class="line">select_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br></pre></td></tr></table></figure>
<strong>3、插入排序(Insertion sort)：</strong><br><img src="https://runnerxr.github.io/post-images/1651824148857.gif"></li>
</ul>
</li>
<li>多次遍历待排序的数组</li>
<li>首先将数组的第一个元素看作是包含1个元素的已排序数组（将待排序的第一个元素当作已排序序列，第二个~最后一共而元素当作 未排序序列）</li>
<li>接着，按顺序把待排序数组中的元素插入到已排序数组的正确位置（将未排序的第一个数据与已排序的最后一个数进行比较）<br>总结原理：通过<strong>构建有序序列</strong>，<strong>对于未排序的数据</strong>，在已排序的序列中<strong>从后向前扫描，找到相应的位置并插入</strong>（语言很精炼），元素集合越接近有序，直接插入排序算法的时间效率越高。<br>常见的几种插入排序：<br>直接插入排序：适用于顺序存储和链式存储的线性表<br>折半插入排序<br>希尔插入排序<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">54</span>, <span class="number">226</span>, <span class="number">93</span>, <span class="number">17</span>, <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>]  <span class="comment">#升序排序</span></span><br><span class="line"></span><br><span class="line">[<span class="number">54</span>,      <span class="number">226</span>, <span class="number">93</span>, <span class="number">17</span>, <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>]</span><br><span class="line">[<span class="number">54</span>, <span class="number">93</span>,<span class="number">226</span>,       <span class="number">17</span>, <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>]</span><br><span class="line">[<span class="number">54</span>, <span class="number">93</span>,<span class="number">17</span>,<span class="number">226</span>,        <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>]</span><br><span class="line">[<span class="number">54</span>,<span class="number">17</span>, <span class="number">93</span>,<span class="number">226</span>,        <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>]</span><br><span class="line">[<span class="number">17</span>,<span class="number">54</span>, <span class="number">93</span>,<span class="number">226</span>,        <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>]</span><br><span class="line">[<span class="number">17</span>,<span class="number">54</span>, <span class="number">93</span>,<span class="number">77</span>,<span class="number">226</span>,         <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>]</span><br><span class="line">[<span class="number">17</span>,<span class="number">54</span>,<span class="number">77</span>, <span class="number">93</span>,<span class="number">226</span>,         <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>]</span><br><span class="line"><span class="comment"># .....</span></span><br><span class="line">[<span class="number">17</span>,<span class="number">31</span>, <span class="number">44</span>,<span class="number">54</span>,<span class="number">55</span>,<span class="number">77</span>,<span class="number">93</span>,<span class="number">226</span>,   <span class="number">15</span>]</span><br><span class="line"><span class="comment">#最坏时间复杂度  n*n=O(n^2)</span></span><br><span class="line"><span class="comment">#最优时间复杂度  n*1=O(n)</span></span><br><span class="line">[<span class="number">17</span>, <span class="number">20</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">77</span>, <span class="number">93</span>, <span class="number">226</span>,  <span class="number">1000</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#稳定性 :稳定的</span></span><br><span class="line">[<span class="number">17</span>, <span class="number">20</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">77</span>, <span class="number">93</span>,   <span class="number">77</span>, <span class="number">226</span>]</span><br><span class="line">[<span class="number">17</span>, <span class="number">20</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">77</span>, <span class="number">77</span>,   <span class="number">93</span>, <span class="number">226</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n=<span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="comment"># i表示列表中索引为i的数据进行插入排序（相当于抓牌的过程）</span></span><br><span class="line">    <span class="comment"># 每次进行一轮插入之后，已排序序列的长度+1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):  <span class="comment">#n-1   n  对序号为1~n-1的数组进行排序</span></span><br><span class="line">        <span class="comment"># 使用j标记待插入数据向前移动时的索引，知道不需要再移动（相当于将新抓的牌放入到已有的牌中）</span></span><br><span class="line">        j=i</span><br><span class="line">        <span class="keyword">while</span> j&gt;<span class="number">0</span>: <span class="comment">#和有序列表中每个元素进行比较 （从有序序列的最后一个开始，一直到第一个元素）</span></span><br><span class="line">            <span class="keyword">if</span> arr[j]&lt;arr[j-<span class="number">1</span>]: <span class="comment">#如果当前元素比前一个元素小，则进行交换</span></span><br><span class="line">                arr[j],arr[j-<span class="number">1</span>],=arr[j-<span class="number">1</span>],arr[j]</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#否则已经是有序列表，不需要交换了，则退出循环，进行下一轮的判断</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 每次进行一轮插入之后，未排序序列的长度-1</span></span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#arr=[54, 226, 93, 17, 77, 31, 44, 55, 20]</span></span><br><span class="line">    arr=[<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;原数组：&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(arr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;排序后：&#x27;</span>)</span><br><span class="line">    insert_sort(arr)</span><br><span class="line">    <span class="built_in">print</span>(arr) </span><br></pre></td></tr></table></figure>
<strong>4、快速排序(Quick sort)</strong><br><img src="https://runnerxr.github.io/post-images/1651827602453.gif"><br>类别：基于交换的排序算法<br>基本思想：基于分治法的思想，让两个索引不断的向中间靠拢</li>
</ul>
<ul>
<li>首先设定一个分界值pivot,通过该分界值将数组分成左右两个部分</li>
<li><strong>将大于或等于分界值的数据集中到数组右边，小于或等于分界值的数组集中到数组的左边</strong></li>
<li>左右和右边的数据可以分别进行排序，左侧的数据也取分界值分成左右两个部分左边放小，右边放大，右边的同理</li>
<li>重复上述的操作<br>具体的那部分：<br>将第一个数值作为分界值<br>附上一个自己写的例子如下：（形成相应的肌肉记忆）<br>注意事项：循环的时候需要先从右边往左边开始<br><strong>参考资料：<a target="_blank" rel="noopener" href="https://yshblog.com/blog/170">https://yshblog.com/blog/170</a></strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr,left,right</span>):</span><br><span class="line"><span class="comment">#递归退出条件</span></span><br><span class="line"><span class="comment"># left=right ,证明要处理的数据只有一个</span></span><br><span class="line"><span class="comment"># left&gt;right ,证明右边没有数据</span></span><br><span class="line"><span class="keyword">if</span> left&gt;=right:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="comment"># 定义两个游标分别指向0和末尾的位置,选择基准点为该调整范围的第一个值</span></span><br><span class="line">start = left</span><br><span class="line">end = right</span><br><span class="line">pivot = arr[left]</span><br><span class="line"></span><br><span class="line"><span class="comment">#循环判断，直到遍历全部，left和right两个变量值一直在变化，直到两个相遇说明遍历完全部的数据点</span></span><br><span class="line"><span class="comment">#递归相当于循环，即无需继续处理返回结果</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">    <span class="comment"># 从右向左 arr[right]&gt;pivot 则right-=1（从右开始查找大于基准点的值）</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[right] &gt;= pivot:</span><br><span class="line">        right -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将right索引对应的元素赋值给left（这个位置的值先移动到左边）</span></span><br><span class="line">    arr[left] = arr[right]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从左往右  arr[left]&lt;pivot  则left+=1（从左开始查找小于基准点的值）</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[left] &lt; pivot:</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将left索引对应的元素赋值给right（这个位置的值先移动到右边）</span></span><br><span class="line">    arr[right] = arr[left]</span><br><span class="line"><span class="comment">#将基准数放置到对应的位置（写回改成的值）</span></span><br><span class="line">arr[left]=pivot</span><br><span class="line"></span><br><span class="line"><span class="comment">#比基准数小的即左边的数据 要重复调用quick_sort()</span></span><br><span class="line">quick_sort(arr,start,left-<span class="number">1</span>)</span><br><span class="line"><span class="comment">#比基准数大的即右边的数据 要重复调用quick_sort()</span></span><br><span class="line">quick_sort(arr,left+<span class="number">1</span>,end)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr=[<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;原数组：&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(arr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;排序后数组：&#x27;</span>)</span><br><span class="line">    quick_sort(arr,<span class="number">0</span>,<span class="built_in">len</span>(arr)-<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(arr)</span><br></pre></td></tr></table></figure>
<p>有一个注意的地方，将分治的方法用函数来写，这样可以使得代码比较的简洁，这里也将代码贴在这里，作为熟悉用。用的变量的名字没有太大的关系，主要是熟悉里面的相关逻辑才是最重要的。其实这也很好的对二分法做了一个回顾了。 化成一种标准的形式比较好处理也是，为后面熟练写打下基础。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先写一个分治的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr,left,right</span>):</span><br><span class="line">    pivot=arr[left]</span><br><span class="line">    i = left</span><br><span class="line">    j = right</span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[j] &gt;= pivot:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        arr[i] = arr[j]</span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[i] &lt;pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        arr[j] = arr[i]</span><br><span class="line">    arr[i]=pivot</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再写排序函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr, left, right</span>):</span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        mid = partition(arr,left,right)</span><br><span class="line">        quick_sort(arr, left, mid-<span class="number">1</span>)</span><br><span class="line">        quick_sort(arr, mid+<span class="number">1</span>, right)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr=[<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;原数组：&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(arr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;排序后数组：&#x27;</span>)</span><br><span class="line">    quick_sort(arr,<span class="number">0</span>,<span class="built_in">len</span>(arr)-<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(arr)</span><br></pre></td></tr></table></figure>

<p><strong>5、计数排序：</strong><br>找出原数组中元素的最大值，记为max<br>创建一个新的数组，记为count，其长度为max +1 ,元素的默认值都是0<br>遍历原数组中的元素，以原数组中的元素作为count数组的索引，以原数组中元素出现的次数作为count数组的元素值<br>创建结果数组result,起始索引index<br>遍历count数组，找出其中元素值大于0的元素，将其对应的索引作为元素填充到result数组中去，每处理依次，count中的元素值减1，直到该元素值不大于0，依次处理count中剩下的元素<br>返回结果数组result</p>
<p><strong>6、归并排序(Merge Sort)：</strong><br><img src="https://runnerxr.github.io/post-images/1651827839467.gif"><br>分解（divide）：将n个元素分成含n&#x2F;2个元素的子序列<br>解决(conquer)：用合并排序法对两个子序列递归的排序<br>合并(combine)：合并两个已排序的子序列已得到排序结果</p>
<ul>
<li>按拆分顺序一层一层反向合并，在拆分过程中原来在一个子序列的，合并后还在子序列，合并时需要保证按序合并；最底层的合并：两个值，比较大小，小值在前</li>
<li>再往上，需要为合并的两个子序列配置两个指针（姑且称之为left和right），初始分别指向序列的起始位置，较两个指针指向值，取较小值加入合并序列，较小值指针后移，再比较、加入较小值、较小值指针后移……直到合并完成<br>视频链接：<a target="_blank" rel="noopener" href="https://www.algomooc.com/1280.html">https://www.algomooc.com/1280.html</a><br>写代码的过程中有很多的细节是需要注意的，需要不停的反复写才能够发现真正的问题所在。甚至还有一些语法的问题在里面。有几个十分需要注意的点如下：</li>
</ul>
<ol>
<li>递归的终止条件</li>
<li>定义的两个左右排序区间的问题：分治法</li>
<li>将归并排序和快速排序要区分开来，两者也是有相似的地方</li>
<li>双指针的思想（双指针用到的情况有很多，这里运用的具体步骤要非常清晰才行）</li>
<li>一个区间遍历完毕之后，将另一个区间加入的过程<br><strong>实际代码如下：</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">54</span>, <span class="number">26</span>, <span class="number">93</span>, <span class="number">17</span>, <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>]  <span class="comment">#升序排序</span></span><br><span class="line"><span class="comment">#分解  n//2</span></span><br><span class="line">[<span class="number">54</span>, <span class="number">26</span>, <span class="number">93</span>, <span class="number">17</span>]   [<span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">54</span>, <span class="number">26</span>]  [<span class="number">93</span>, <span class="number">17</span>]   [<span class="number">77</span>, <span class="number">31</span>]  [<span class="number">44</span>, <span class="number">55</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">54</span>]  [<span class="number">26</span>]  [<span class="number">93</span>] [<span class="number">17</span>]   [<span class="number">77</span>]  [<span class="number">31</span>]  [<span class="number">44</span>] [<span class="number">55</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并</span></span><br><span class="line">[<span class="number">26</span>,<span class="number">54</span>] [<span class="number">17</span>,<span class="number">93</span>] [<span class="number">31</span>,<span class="number">77</span>] [<span class="number">44</span>,<span class="number">55</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">17</span>,<span class="number">26</span>,(<span class="number">54</span>,<span class="number">1</span>),<span class="number">93</span>]   [<span class="number">31</span>,<span class="number">44</span>,(<span class="number">54</span>,<span class="number">2</span>),<span class="number">55</span>,<span class="number">77</span>]</span><br><span class="line">  </span><br><span class="line">[<span class="number">17</span>,<span class="number">26</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">54</span>,<span class="number">55</span>,<span class="number">77</span>,<span class="number">93</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merg_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment">#1. 分解</span></span><br><span class="line">    n=<span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="comment">#递归的出口： 分解到最小</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    <span class="comment">#取拆分的中间位置（递归拆分，取整）</span></span><br><span class="line">    mid=n//<span class="number">2</span></span><br><span class="line">    <span class="comment">#拆分后左右两侧子串，并且是不断的进行调用，一直到只有一个元素为止</span></span><br><span class="line">    left_li=merg_sort(arr[<span class="number">0</span>:mid])   <span class="comment">#左边</span></span><br><span class="line">    right_li=merg_sort(arr[mid:])   <span class="comment">#右边</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#2.合并</span></span><br><span class="line">    <span class="comment">#排序结果列表，比较传过来的两个序列，返回一个排好的序列</span></span><br><span class="line">    result=[]</span><br><span class="line">    <span class="comment">#定义左右指针</span></span><br><span class="line">    left_pointer,right_pointer=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="comment">#利用两个指针归并当前两个左右子序列</span></span><br><span class="line">    <span class="keyword">while</span> left_pointer&lt;<span class="built_in">len</span>(left_li) <span class="keyword">and</span> right_pointer&lt;<span class="built_in">len</span>(right_li):</span><br><span class="line">        <span class="comment">#比较最小集合中的元素，将最小元素添加到result列表中</span></span><br><span class="line">        <span class="keyword">if</span> left_li[left_pointer] &lt;=right_li[right_pointer]:</span><br><span class="line">            result.append(left_li[left_pointer])</span><br><span class="line">            left_pointer += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right_li[right_pointer])</span><br><span class="line">            right_pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 其中一个指针到头之后（pointer指在最后，[pointer:]就是一个空列表），也即比较大小结束</span></span><br><span class="line">    <span class="comment"># 退出循环后，将不为空的列表剩余元素添加到result中</span></span><br><span class="line">    <span class="comment"># result+=left_li[left_pointer:]</span></span><br><span class="line">    result.extend(left_li[left_pointer:])</span><br><span class="line">    result.extend(right_li[right_pointer:])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#将最后排序的结果列表返回</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr=[<span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>]</span><br><span class="line">    <span class="comment">#arr=[54, 26, 93, 17, 77, 31, 44, 55]</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;原来的数组：&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(arr)</span><br><span class="line">    result=merg_sort(arr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;排序后：&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">##如果硬要按照三部分拆分开来写的话</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merg_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n=<span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    mid=n//<span class="number">2</span></span><br><span class="line">    left_li=merg_sort(arr[<span class="number">0</span>:mid])  </span><br><span class="line">    right_li=merg_sort(arr[mid:])  </span><br><span class="line">    <span class="keyword">return</span> merge(left_li, right_li)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">left_li , right_li</span>):</span><br><span class="line">    result=[]</span><br><span class="line">    left_pointer,right_pointer=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> left_pointer&lt;<span class="built_in">len</span>(left_li) <span class="keyword">and</span> right_pointer&lt;<span class="built_in">len</span>(right_li):</span><br><span class="line">        <span class="keyword">if</span> left_li[left_pointer] &lt;=right_li[right_pointer]:</span><br><span class="line">            result.append(left_li[left_pointer])</span><br><span class="line">            left_pointer += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right_li[right_pointer])</span><br><span class="line">            right_pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    result.extend(left_li[left_pointer:])</span><br><span class="line">    result.extend(right_li[right_pointer:])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr=[<span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;原来的数组：&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(arr)</span><br><span class="line">    result=merg_sort(arr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;排序后：&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<strong>堆排序(Heap Sort)：</strong><br><img src="https://runnerxr.github.io/post-images/1651822697481.gif"><br>类别：基于选择排序+堆的思想（一种利用堆的概念来排序的选择排序）<br>参考链接：</li>
<li><a target="_blank" rel="noopener" href="https://www.algomooc.com/2747.html">https://www.algomooc.com/2747.html</a><br>子所以是一个排序，是因为每次的操作都是发生在一个数组中的（表面上有一个堆，但是这个堆始终是在数组中进行体现的）</li>
</ol>
<p>基础知识：</p>
<ol>
<li><strong>堆是一种完全二叉树</strong>（是按照顺序存储方式，从上至下，从左至右进行元素的添加，需要结合完全二叉树从数学上更好的去理解）</li>
<li>大顶堆：每个父结点的值都大于等于左右孩子结点（用于升序排列）</li>
<li>小顶堆：每一个父子结点都小于或等于其左右孩子结点的值 （用于降序排列）</li>
<li>时间复杂度：平均O(nlogn), 最坏O(nlogn), 最好O(nlogn)</li>
<li>空间复杂度：O(1)</li>
<li>适用场景：想得到一个序列中第k个最小元素之前的部分排序序列，最好采用堆排序（Topk系列问题）</li>
<li>算法稳定性：不稳定</li>
<li>该算法的核心：堆结点的调整</li>
</ol>
<p><strong>基本步骤如下：</strong><br>下面的步骤也是辅助图片加深理解，属于是二次回顾的问题了</p>
<ol>
<li>将无序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆（利用大顶堆可以迅速找出最大的节点）<img src="https://runnerxr.github.io/post-images/1651845519139.png"><ul>
<li><strong>从最后一个非叶子结点开始</strong></li>
<li>第一个非叶子节点arr.length&#x2F;2-1&#x3D;5&#x2F;2-1&#x3D;1</li>
<li>从左至右，从上至下进行调整</li>
</ul>
</li>
<li>将堆顶元素与末尾元素交换，将最大元素“沉”到数组末端，此时数组末端储存了当前区间最大的元素<img src="https://runnerxr.github.io/post-images/1651845568418.png"></li>
<li>每次将堆顶元素与末尾元素交换，使末尾元素最大，去掉最后一个元素，然后将剩下的堆部分继续构造大顶堆，再将堆顶元素与末尾元素交换，得到第二大元素<img src="https://runnerxr.github.io/post-images/1651845738825.png"></li>
<li>如此反复进行交换、重建、交换（直到堆只剩下一个元素：大顶堆的长度为1）<img src="https://runnerxr.github.io/post-images/1651845762761.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仿照吴师兄的代码贴了一个比较好懂的版本，之后以这个版本为基础和原型</span></span><br><span class="line"><span class="comment"># 构建维护大顶堆的函数</span></span><br><span class="line"><span class="comment"># 传入的参数分别是数组\父节点、数组的最大小标</span></span><br><span class="line"><span class="comment"># 整个函数的实现过程就是在讨论父节点应该放置在哪个位置的问题，只是针对一个小堆的情况</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">KeepHeap</span>(<span class="params">arr,parent,high</span>):</span><br><span class="line">    <span class="comment"># 左子树节点</span></span><br><span class="line">    child = <span class="number">2</span> *parent +<span class="number">1</span></span><br><span class="line">    <span class="comment"># 用临时数组保存当前的父节点的值</span></span><br><span class="line">    temp=arr[parent]</span><br><span class="line">    <span class="comment"># 遍历child后面的节点，把temp放入合理位置的过程</span></span><br><span class="line">    <span class="keyword">while</span> child &lt;high:</span><br><span class="line">        <span class="comment"># 如果发现左子树的值小于右子树的值，将child切换到右子树的位置</span></span><br><span class="line">        <span class="comment"># 否则就证明左子树的值是大于右子树的值，不需要进行切换</span></span><br><span class="line">        <span class="comment"># if child +1&lt;high,确保得有左右子节点才会进行相应的比较</span></span><br><span class="line">        <span class="keyword">if</span> child +<span class="number">1</span>&lt; high <span class="keyword">and</span> arr[child] &lt;arr[child+<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># 将左节点切换到右节点</span></span><br><span class="line">            child+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 当父节点的值是大于左右子节点的，说明parent就在正确的位置上面，直接退出</span></span><br><span class="line">        <span class="keyword">if</span> temp&gt;arr[child]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 父节点的值是小于左子节点的，需要进行交换(将最大值赋值给父节点)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arr[parent]=arr[child]</span><br><span class="line">            <span class="comment"># 记录此时的parent的位置（实际上如果是数组的话就是相应的下标）</span></span><br><span class="line">            parent=child</span><br><span class="line">            <span class="comment"># 此时子节点已经发生变化，从它的左子节点开始(如果是数组就是需要更新现在的左子节点的下标)</span></span><br><span class="line">            child=<span class="number">2</span>*parent+<span class="number">1</span></span><br><span class="line">    <span class="comment"># 循环结束之后，将temp放在正确的位置</span></span><br><span class="line">    arr[parent]=temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下为堆排序的过程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Heap_Sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 1.建堆（用到了完全二叉树的定义）</span></span><br><span class="line">    <span class="comment"># 根据升序，这里选择的是大顶堆</span></span><br><span class="line">    <span class="comment"># 先找到最后一个非叶子节点的根节点</span></span><br><span class="line">    <span class="comment"># 向上循环根节点，从小到大</span></span><br><span class="line">    n=<span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 调用维护大顶堆的函数</span></span><br><span class="line">        KeepHeap(arr,i,n)</span><br><span class="line">    <span class="comment"># 为了理解的方便，这里打印一行,这里打印的结果应该是所有的子节点为根的堆都是大顶堆</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;arr of heap&#x27;</span>,arr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 挨个的出数，按照升序进行排列</span></span><br><span class="line">    <span class="comment"># 一开始最大元素是[0],被换到最后一个，数组末端存储了当前区间的最大元素</span></span><br><span class="line">    <span class="comment"># 从n-0,不断的和[0]元素进行交换，重新排序（n把第2，3...n的数翻转到最下面）</span></span><br><span class="line">    <span class="comment"># i表示数组的序列，从0~n-1，因为是倒序的，所以写范围的时候就需要特别注意</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 交换元素</span></span><br><span class="line">        arr[<span class="number">0</span>],arr[i]=arr[i],arr[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 交换之后调用维护最大堆的函数</span></span><br><span class="line">        <span class="comment"># 始终是从下标为0父节点开始的，并且在当前的调用过程中，一直到第i下标</span></span><br><span class="line">        KeepHeap(arr,<span class="number">0</span>,i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写主函数</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    numbers = [<span class="number">54</span>, <span class="number">26</span>, <span class="number">93</span>, <span class="number">17</span>, <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>, <span class="number">13</span>]</span><br><span class="line">    Heap_Sort(numbers)</span><br><span class="line">    <span class="built_in">print</span>(numbers)</span><br><span class="line"><span class="comment"># 排序之后的结果</span></span><br><span class="line">[<span class="number">13</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">26</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">77</span>, <span class="number">93</span>]</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/10/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/" data-id="claquc6330027z0tk5j2p9d5j" data-title="常见的几种排序的基础知识汇总（内化为自己的：important）" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-leetcoad239-滑动窗口的最大值" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/10/leetcoad239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/" class="article-date">
  <time class="dt-published" datetime="2022-03-10T06:08:13.000Z" itemprop="datePublished">2022-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/10/leetcoad239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/">leetcoad239-滑动窗口的最大值</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回 滑动窗口中的最大值 。<br><a target="_blank" rel="noopener" href="https://www.algomooc.com/635.html">https://www.algomooc.com/635.html</a><br><strong>解题的本质：</strong><br>将处于窗口的第一个数字删除，同时在窗口的末尾添加一个新的数字，可以用双端队列来模拟，每次把尾部的数字弹出，再把新的数字压入到头部，然后找栈队列中最大的元素。<br>如果队列中进来一个较大的数字，那么队列中比这个数字更小的数字就不可能再成为窗口中最大的元素了（这个大的数字是后进来的，一定会比之前早进入窗口的小的数字要后离开窗口，先进入且比较小的数字必然不可能成为最大的元素，可以弹出队列）</p>
<p><strong>注意事项：</strong><br>python中队列保留的是索引，而其他的像java和C++中队列保存的是元素</p>
<p><strong>解题步骤如下:</strong></p>
<ol>
<li>获取数组长度</li>
<li>构建双端队列</li>
<li>创建一个存储最大值的数组</li>
<li>定义好相应的边界情况</li>
<li><strong>一开始滑动窗口不包含K个元素，不是合格的滑动窗口</strong><ol>
<li>在滑动的过程中，维护好deque,确保是单调递减队列</li>
<li>反复判断，如果队列不为空且当前考察元素大于等于队尾元素，则将元队尾素移除（为什么要移除队尾元素：因为前面已经进行递减的操作了）。</li>
<li>直到考察元素可以放入到队列中（此处采用while循环进行相应的判断：满足条件就不断的执行队首元素的弹出，不满足：即考察的元素小与队列的队尾元素就加入进去）</li>
</ol>
</li>
<li><strong>当滑动的窗口正好有k个元素的时候，那么最大值就是对应的队首元素</strong><ol>
<li><strong>向右移动会把窗口最左边的给舍弃</strong></li>
<li>加入判断语句，如果队首元素与窗口最左边的元素相等，需要将队首元素抛出</li>
<li>反复判断，如果队列不为空且当前考察元素大于等于队尾元素，则将队尾元素移除（采用while循环进行相应的判断，与上面的判断相同，相等的情况也要进行弹出）</li>
<li>直到考察元素可以放入到队列中</li>
</ol>
</li>
<li>最后返回res<br><strong>代码如下：</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n ==<span class="number">0</span> <span class="keyword">or</span> k ==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,k):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[q[-<span class="number">1</span>]] &lt;= nums[i]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line">        res.append(nums[q[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,n):</span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> q[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">                    q.popleft()</span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[q[-<span class="number">1</span>]] &lt;=nums[i]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line">            res.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>第一种写法：</strong><br>while q and nums[q[-1]] &lt;&#x3D; nums[i]:<br>        q.pop()<br>q.append(i)<br><strong>第二种写法：</strong><br>while q and q[-1] &lt; nums[i]:<br>        q.pop()<br>q.append(nums[i])</p>
<p><strong>第二种代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (k):</span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> q[-<span class="number">1</span>] &lt; nums[i]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(nums[i])</span><br><span class="line">        res.append(q[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (k, n):</span><br><span class="line">            <span class="keyword">if</span> q[<span class="number">0</span>] == nums[i-k]:</span><br><span class="line">                q.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> q[-<span class="number">1</span>] &lt; nums[i]: </span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(nums[i])</span><br><span class="line">            res.append(q[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>这里也提供一种滑动窗口的写法，解法也不难，也值得学习，建议将两种方式都掌握清楚</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 之前自己做过的一道题，尝试着再做一遍（不要怕）</span></span><br><span class="line">        <span class="comment"># 十分典型的滑动窗口的题目</span></span><br><span class="line">        <span class="comment"># 先想想套路和思路</span></span><br><span class="line">        <span class="comment"># 需要维持一个固定的窗口大小，可以用两个指针尝试</span></span><br><span class="line">        left,right=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="comment"># 外层循环：右指针还没走到末尾的部分</span></span><br><span class="line">        <span class="keyword">while</span> right &lt;n:</span><br><span class="line">            <span class="comment"># 右指针移动</span></span><br><span class="line">            c=nums[right]</span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 内层循环的条件是：相应的指针的差值是否等于k，如果不等于k，就继续的往右移动右指针</span></span><br><span class="line">            <span class="keyword">while</span> right-left==k:</span><br><span class="line">                <span class="comment"># 如果等有k的话，更新当前窗口的一个最大值，并加入到结果数组中</span></span><br><span class="line">                res.append(<span class="built_in">max</span>(nums[left:right]))</span><br><span class="line">                <span class="comment"># 左指针继续的往右移动</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/10/leetcoad239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/" data-id="claquc62e000mz0tk259ndr14" data-title="leetcoad239-滑动窗口的最大值" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" rel="tag">算法专栏（用python注写）</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-链表和栈以及队列的深度理解（提纲挈领性质）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/09/%E9%93%BE%E8%A1%A8%E5%92%8C%E6%A0%88%E4%BB%A5%E5%8F%8A%E9%98%9F%E5%88%97%E7%9A%84%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3%EF%BC%88%E6%8F%90%E7%BA%B2%E6%8C%88%E9%A2%86%E6%80%A7%E8%B4%A8%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2022-03-09T14:10:11.000Z" itemprop="datePublished">2022-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/09/%E9%93%BE%E8%A1%A8%E5%92%8C%E6%A0%88%E4%BB%A5%E5%8F%8A%E9%98%9F%E5%88%97%E7%9A%84%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3%EF%BC%88%E6%8F%90%E7%BA%B2%E6%8C%88%E9%A2%86%E6%80%A7%E8%B4%A8%EF%BC%89/">链表和栈以及队列的深度理解（提纲挈领性质）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>数据结构再怎么变，主要是通过数组和链表</strong><br>链表不用顺序实现，<strong>用指针</strong>实现，在内存中不连续，也即链表将一系列不连续的内存联系起来，将那种碎片化内存进行合理的利用，解决空间的问题。因此链表就允许插入、删除表上的任意位置上的节点，但是不允许随即随存。<br> 数组与链表的区别：<br> 区别：</p>
<ol>
<li>链表是链式的存储结构；数组是顺序的存储结构。</li>
<li>链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储。</li>
<li>链表的插入删除元素相对数组较为简单，不需要移动元素，且较为容易实现长度扩充，但是寻找某个元素较为困难；</li>
<li>数组寻找某个元素较为简单，但插入与删除比较复杂，由于最大长度需要再编程一开始时指定，故当达到最大长度时，扩充长度不如链表方便。<br>相同点：<br>两种结构均可实现数据的顺序存储，构造出来的模型呈线性结构。<br>把数据结构抽象化：<br>最高层的抽象，数据结构只有两种：数组和链表（顺序存储结构和链式存储结构）。<br>队列和栈这两种数据结构既可以使用链表也可以使用数组来实现</li>
</ol>
<ul>
<li>用数组来实现：处理扩容和缩容的问题</li>
<li>用链表来实现：需要更多的空间存储节点指针</li>
</ul>
<p>散列表：通过散列函数把键映映射到一个大的数组中。<br>对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要空间；线性探查法就需要数组特性，以便连续寻址，省空间，但操作稍微复杂些。</p>
<p>树：<br>用数组实现就是堆，堆是一个完全二叉树，用数组存储不需要节点指针，操作简单<br>用链表实现就是常见的树，不一定是完全二叉树。在链表的结构上，又衍生出各种设计：二叉搜索树、平衡二叉树、红黑树、区间树、B树等等<br><strong>对数据结构的操作,无非遍历 + 访问（增删查改）</strong><br>如何遍历 + 访问？我们仍然从最高层来看，各种数据结构的遍历 + 访问无非两种形式，线性的和非线性的。<br><strong>线性就是 for&#x2F;while <strong>为代表，</strong>非线性就是递归</strong>为代表。再具体一步，无非以下两种框架：<br>数组遍历框架，典型的线性遍历结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void traverse(int[] arr) &#123;</span><br><span class="line">    for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        // 访问 arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二叉树遍历框架，典型的非线性递归遍历结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void traverse(TreeNode root) &#123;</span><br><span class="line">    traverse(root.left)</span><br><span class="line">    traverse(root.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关的变式：<br><strong>链表遍历框架，兼具线性和非线性遍历结构</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void traverse(ListNode head) &#123;</span><br><span class="line">    for (ListNode p = head; p != null; p = p.next) &#123;</span><br><span class="line">        // 访问 p.val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void traverse(ListNode head) &#123;</span><br><span class="line">    // 访问 head.val</span><br><span class="line">    traverse(head.next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二叉树框架又可以具体扩展为 N 叉树的遍历框架：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void traverse(TreeNode root) &#123;</span><br><span class="line">    for (TreeNode child : root.children)</span><br><span class="line">        traverse(child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>N 叉树的遍历又可以扩展为<strong>图的遍历</strong>，因为，图就是<strong>好几 N 叉棵树的结合体</strong>。你说图是可能出现环的？这个很好办，用个布尔数组 visited 做标记就行了，就不写代码了。</p>
<p>所谓框架，就是说不管增删查改，这些<strong>代码都是永远无法脱离的结构</strong>，你可以把这个结构作为大纲，<strong>根据具体问题</strong>在框架上添加代码就行了。<br><strong>为什么算法总是和数据结构同时出现</strong><br><strong>数据结构是工具</strong>，<strong>算法</strong>是通过合适的工具<strong>解决问题的方法</strong>。<br>拿原始人举例，我们学会了数据结构，就像原始人拥有了石刀，石斧等工具。而根据制造工具的工艺不同，石刀又分尖锐的石刀和锯齿状石刀，前者适合打猎，后者适合切割；就像图这种数据结构通过不同的实现方法（链表、数组），可以表示为邻接表和邻接矩阵，前者适合处理非稠密图，后者适合处理稠密图。原始人想要造一栋房子，就要进行规划，石斧砍树，石刀磨尖角等等；就像我们设计算法，发挥数据结构的特性，去解决实际问题。</p>
<p>算法利用数据结构，可以显式利用，比如说前文单调栈，就是巧妙地直接利用了栈结构先进后出的特性。稍微高级一点的算法设计思路，就是隐式利用数据结构，比如前文讲过的回溯算法、动态规划，以及传说中的的分治算法，都在利用树这种结构来解决问题。</p>
<p>但是，无论怎样利用数据结构，多么高大上的算法，其解法都逃不出第二点中相应的框架，是不是？<br><strong>最后总结（重要）</strong></p>
<p>对于一个初学算法的人来说，一定要学会从框架上看问题，而不要纠结于细节问题。<br>啥叫细节问题？比如说 i 到底应该加到 n 还是加到 n - 1 ？这个数组的大小到底应该开 n 还是 n + 1 ？<br>啥叫从框架上看问题？比如说前文动态规划中凑零钱的问题，如果你看了一眼代码就自动忽略细节问题，直接提取出 N 叉树遍历框架，你的框架思维就到位了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span><br><span class="line">    if (amount == 0) return 0;</span><br><span class="line">    int ans = INT_MAX;</span><br><span class="line">    for (int coin : coins) &#123;</span><br><span class="line">        // 金额不可达</span><br><span class="line">        if (amount - coin &lt; 0) continue;</span><br><span class="line">        int subProb = coinChange(coins, amount - coin);</span><br><span class="line">        // 子问题无解</span><br><span class="line">        if (subProb == -1) continue;</span><br><span class="line">        ans = min(ans, subProb + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans == INT_MAX ? -1 : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* N 叉树遍历框架 */</span><br><span class="line">int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span><br><span class="line">    for (int coin : coins)</span><br><span class="line">        coinChange(coins, amount - coin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果细节出错，你得不到正确的答案，但是只要有框架，你再错也错不到哪去，因为你的方向是对的。<br>但是，你要是心中没有框架，那么你根本无法解题，给了你答案，你也不会发现这就是个树的遍历问题。<br>这就是框架的力量，能够保证你在快睡着的时候，依然能写出正确的程序；就算你啥都不会，都能比别人高一个级别。<br>初学阶段，根本没到纠结细节的地步。细节出错，可以有各种方法查出来，比如到处打 log，没有找不到的 bug。相比之下，别人还束手无策的时候，你已经做出了一个错误的答案；当别人没有框架的指导，被无限细节劝退数据结构的时候，你已经通过框架理解了数据结构的精髓。这不就是一种巨大的成功吗？真的得给你鼓掌。</p>
<hr>
<p><strong>栈是先进后出的线性表</strong><br>s.top():获取栈底元素<br>s.empty():判断栈是否为空<br>s.push():往栈中添加一个元素<br>s.pop():栈顶元素的弹出<br>s.size()：获取栈的长度</p>
<hr>
<p><strong>队列是先进先出的线性表</strong><br>q.front():获取队列的队头元素<br>q.push():在队尾添加一个新的元素进队列中<br>q.pop()：把我们的队头元素进行弹出<br>q.empty()：判断我们的队列是否为空<br>q.size():去求队列中的元素的个数</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/09/%E9%93%BE%E8%A1%A8%E5%92%8C%E6%A0%88%E4%BB%A5%E5%8F%8A%E9%98%9F%E5%88%97%E7%9A%84%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3%EF%BC%88%E6%8F%90%E7%BA%B2%E6%8C%88%E9%A2%86%E6%80%A7%E8%B4%A8%EF%BC%89/" data-id="claquc63j0031z0tke42u6a6m" data-title="链表和栈以及队列的深度理解（提纲挈领性质）" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gridea/" rel="tag">Gridea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" rel="tag">python知识小记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99%E7%9A%84%E5%B0%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/" rel="tag">工作之余的小的编程小知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" rel="tag">算法专栏（用python注写）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0/" rel="tag">读书摘记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Gridea/" style="font-size: 10px;">Gridea</a> <a href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" style="font-size: 13.33px;">python知识小记</a> <a href="/tags/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99%E7%9A%84%E5%B0%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/" style="font-size: 16.67px;">工作之余的小的编程小知识</a> <a href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" style="font-size: 20px;">算法专栏（用python注写）</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0/" style="font-size: 10px;">读书摘记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/21/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2022/11/12/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%BA%94%E7%9A%84%E5%90%8C%E6%AD%A5/">搭建自己的博客并进行相应的同步</a>
          </li>
        
          <li>
            <a href="/2022/10/03/vs%20code%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%B7%A5%E5%85%B7%E5%8C%85/">关于vs code导入本地工具包和消除&#39;import [module] could not be resolved in pylance&#39;</a>
          </li>
        
          <li>
            <a href="/2022/09/25/%E5%85%B3%E4%BA%8Ematalab%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">关于matalab的数据分析</a>
          </li>
        
          <li>
            <a href="/2022/07/30/%E5%85%B3%E4%BA%8Epython%E7%88%AC%E8%99%AB%E4%B8%80%E7%82%B9%E5%B0%8F%E7%9A%84%E6%95%B4%E7%90%86/">关于python爬虫一点小的整理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>