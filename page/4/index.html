<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-系统详细的整理关于python中的面向对象编程-面对对象高级编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/23/%E7%B3%BB%E7%BB%9F%E8%AF%A6%E7%BB%86%E7%9A%84%E6%95%B4%E7%90%86%E5%85%B3%E4%BA%8Epython%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2022-03-23T03:47:15.000Z" itemprop="datePublished">2022-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/23/%E7%B3%BB%E7%BB%9F%E8%AF%A6%E7%BB%86%E7%9A%84%E6%95%B4%E7%90%86%E5%85%B3%E4%BA%8Epython%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">系统详细的整理关于python中的面向对象编程/面对对象高级编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>类、实例、封装、继承以及多态</p>
<p>这里的搜集与整理主要是为了方便自己，是在自己有一定理解的基础上进行相应的阐述，目的是能够真正的去把问题弄懂，弄清楚。涉及到面向对象编程以及面向对象高级编程，后面可以不断的加入一些新的东西进行，加深对一些概念的理解和掌握也是非常值得自己去理解的。<br>参考资料如下：<br><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017501655757856">https://www.liaoxuefeng.com/wiki/1016959663602400/1017501655757856</a></p>
<h1 id="面向对象编程的重要概念：类和实例"><a href="#面向对象编程的重要概念：类和实例" class="headerlink" title="面向对象编程的重要概念：类和实例"></a>面向对象编程的重要概念：类和实例</h1><p>面向对象的设计思想是抽象出Class，根据Class创建Instance。<br>面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。<br>面对对象的三大特点：</p>
<ol>
<li>数据封装</li>
<li>继承</li>
<li>多态</li>
</ol>
<ul>
<li>类：Class(抽象的创建实例的模板)</li>
<li>实例 :Instance（根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但是各个的数据可能不同，相互独立，互不影响）</li>
<li>方法：与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；</li>
<li>通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。</li>
<li>Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">#定义Student类，该类是从object类继承下来的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment">#类起到了模板的作用，把一些认为必须绑定的属性强制填进去</span></span><br><span class="line">    <span class="comment">#定义一个特殊的方法，在创建实例的时候就把name、score等属性绑上去</span></span><br><span class="line">    <span class="comment">#self为方法的第一个参数，表示创建实例本身，把各种属性绑定到self上</span></span><br><span class="line">    <span class="comment">#self指向创建实例的本身</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):  </span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建bart实例（指向一个Stuedent的实例）</span></span><br><span class="line"><span class="comment">#必须传入与方法匹配的参数（self的传入由python解释器操作）</span></span><br><span class="line"><span class="comment">#每一个实例都有各自的name和score数据</span></span><br><span class="line">bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)   </span><br><span class="line"><span class="built_in">print</span>(bart.name)</span><br><span class="line"><span class="built_in">print</span>(bart.score)</span><br></pre></td></tr></table></figure>
数据封装：打印一个学生的成绩的方法（__init__方法）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment">#包含三个形参</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,score</span>):   </span><br><span class="line">        <span class="comment">#初始化属性 name,获取与形参name相关联的值,将其赋给变量name,然后该变量被关联到当前创建的实例中</span></span><br><span class="line">        <span class="comment">#可以通过实例来访问变量称为属性</span></span><br><span class="line">        self.name = name             </span><br><span class="line">        self.score = score        </span><br><span class="line"></span><br><span class="line">    <span class="comment">#内部定义访问数据的函数（打印一个学生的成绩）</span></span><br><span class="line">    <span class="comment">#直接在类的内部定于访问数据的函数，把数据给封装起来了，封装数据的函数是和类本身是关联的</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):           </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))</span><br><span class="line"></span><br><span class="line"><span class="comment">#从外部看，只需要知道创建实例给出的name和score,如何打印是Student类的内部定义的</span></span><br><span class="line"><span class="comment">#数据和逻辑被“封装起来”，调用很容易，不用知道内部实现的细节</span></span><br><span class="line">lisa = Student(<span class="string">&#x27;Lisa&#x27;</span>, <span class="number">99</span>)</span><br><span class="line">bart = Student(<span class="string">&#x27;Bart&#x27;</span>, <span class="number">59</span>)</span><br><span class="line">lisa.print_score()</span><br><span class="line">bart.print_score()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果为：</span></span><br><span class="line"><span class="comment">#Lisa: 99</span></span><br><span class="line"><span class="comment">#Bart: 59</span></span><br></pre></td></tr></table></figure>
更进一步：利用封装给Student类增加新的方法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,score</span>): </span><br><span class="line">        self.name = name             </span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="comment">#增加get_grade的方法</span></span><br><span class="line">    <span class="comment">#get_grade方法可以直接在实例变量上调用，不需要知道内部实现细节</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_grade</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.score &gt;= <span class="number">90</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> self.score &gt;= <span class="number">60</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span> </span><br><span class="line"></span><br><span class="line">lisa = Student(<span class="string">&#x27;Lisa&#x27;</span>, <span class="number">99</span>)</span><br><span class="line">bart = Student(<span class="string">&#x27;Bart&#x27;</span>, <span class="number">59</span>)</span><br><span class="line"><span class="built_in">print</span>(lisa.name, lisa.get_grade())</span><br><span class="line"><span class="built_in">print</span>(bart.name, bart.get_grade())</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果为：</span></span><br><span class="line"><span class="comment">#Lisa A</span></span><br><span class="line"><span class="comment">#Bart C</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="访问限值："><a href="#访问限值：" class="headerlink" title="访问限值："></a>访问限值：</h1><ol>
<li>如果想让内部属性不被外部访问，属性前加___，变成私有变量，只有内部可以访问，外部不能访问</li>
<li>效果：确保外部代码不能随意修改对象内部的状态，通过访问限制的保护，代码更加健壮<ul>
<li>不是一定不能从外部进行访问（不能访问的原因：python解释器把__name变量改成_Student__name,可以通过_Student__name来访问__name变量）</li>
</ul>
</li>
<li>需要获取的时候可以在类中加入get_name和get_score的方法。<ul>
<li>方法中可以对参数进行检查，避免传入无效的参数。</li>
</ul>
</li>
<li>如果还想修改的话：在类中增加set_score方法。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        <span class="comment">#在name和score的属性前面加双下划线__，使其变为私有变量（private）</span></span><br><span class="line">        <span class="comment">#内部可以访问，外部不能访问</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    <span class="comment">#参照上面做相同更改</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):           </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (self.__name, self.___score))</span><br><span class="line">   </span><br><span class="line">    <span class="comment">#为了保证外部可以访问，增加get_name方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line">    <span class="comment">#为了保证外部可以访问，增加get_score方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line"></span><br><span class="line">    <span class="comment">#为了允许外部代码修改score，增加set_score方法</span></span><br><span class="line">    <span class="comment">#同时在方法中还可以对参数做检查，避免传入无效的参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, score</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= score &lt;= <span class="number">100</span>:</span><br><span class="line">            self.__score = score</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;bad score&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#增加get_name方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_grade</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.__score &gt;= <span class="number">90</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> self.__score &gt;= <span class="number">60</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line"></span><br><span class="line">bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bart.get_name() =&#x27;</span>, bart.get_name())</span><br><span class="line"></span><br><span class="line">bart.set_score(<span class="number">60</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bart.get_score() =&#x27;</span>, bart.get_score())</span><br><span class="line"></span><br><span class="line"><span class="comment">#解释器把__name变量变成了_Student__name,仍然可以通过_Student__name来访问__name变量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;DO NOT use bart._Student__name:&#x27;</span>, bart._Student__name)</span><br></pre></td></tr></table></figure>

<h1 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h1><p>被继承的：父类（Base class&#x2F;Super class）<br>基于父类继承的：子类(Subclass)</p>
<ul>
<li>动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</li>
<li>动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。</li>
</ul>
<p>总结：</p>
<ul>
<li>继承可以把父类的所有功能都直接拿过来，这样就不必重零做起</li>
<li>子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写</li>
</ul>
<p><strong>多态：</strong></p>
<ol>
<li>当我们定义了一个class的时候，实际上就定义了一种数据类型，定义的数据类型与python自带的数据类型差不多，可以用isinstance()函数来判断</li>
<li>调用只管调用，不管细节，而当我们新增一种Animal的字类的时候，主要确保run()方法编写正确，不用管原来的代码是如何调用的</li>
<li>对扩展开放：允许新增Animal子类</li>
<li>对修改封闭：不需要修改依赖Animal类型的run_twice()函数</li>
<li>可以理解为一种接口，多种实现，从而提高代码的扩展性，接口的复用性，有几个必要条件：继承、重写（重载）、父类引用指向子类对象（覆盖）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment">#打印的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Animal is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义Dog类时，直接从Animal类继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Dog is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义Cat类时，直接从Animal类继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Cat is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个函数，接受一个Animal变量类型的变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_twice</span>(<span class="params">animal</span>):</span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个Tortoise类型的类，也从Animal派生：</span></span><br><span class="line"><span class="comment">#只要是Animal类或者子类，就会自动调用实际类型的run()方法（也即多态的本质）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tortoise</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Tortoise is running slowly...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a = Animal()  <span class="comment">#a是Animal类型的</span></span><br><span class="line">d = Dog()  <span class="comment">#d是Dog类型的</span></span><br><span class="line">c = Cat()    <span class="comment">#c是Cat类型的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断一个变量是否是某个类型可以用isinstance()判断</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a is Animal?&#x27;</span>, <span class="built_in">isinstance</span>(a, Animal))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a is Dog?&#x27;</span>, <span class="built_in">isinstance</span>(a, Dog))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a is Cat?&#x27;</span>, <span class="built_in">isinstance</span>(a, Cat))</span><br><span class="line"><span class="comment">#输出结果：</span></span><br><span class="line"><span class="comment">#a is Animal? True</span></span><br><span class="line"><span class="comment">#a is Dog? False</span></span><br><span class="line"><span class="comment">#a is Cat? False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;d is Animal?&#x27;</span>, <span class="built_in">isinstance</span>(d, Animal))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;d is Dog?&#x27;</span>, <span class="built_in">isinstance</span>(d, Dog))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;d is Cat?&#x27;</span>, <span class="built_in">isinstance</span>(d, Cat))</span><br><span class="line"><span class="comment">#输出结果：</span></span><br><span class="line"><span class="comment">#d is Animal? True</span></span><br><span class="line"><span class="comment">#d is Dog? True</span></span><br><span class="line"><span class="comment">#d is Cat? False</span></span><br><span class="line"></span><br><span class="line">run_twice(c)</span><br><span class="line"><span class="comment">#输出结果：</span></span><br><span class="line"><span class="comment">#Cat is running...</span></span><br><span class="line"><span class="comment">#Cat is running...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#当调用run_twice()时，传入Tortoise的实例：</span></span><br><span class="line"><span class="comment">#不需要对run_twice()做任何修改</span></span><br><span class="line"><span class="comment">#任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行</span></span><br><span class="line">run_twice(Tortoise())</span><br><span class="line"><span class="comment">#输出结果：</span></span><br><span class="line"><span class="comment">#Tortoise is running slowly...</span></span><br><span class="line"><span class="comment">#Tortoise is running slowly...</span></span><br></pre></td></tr></table></figure>
附上别人的代码进行辅助理解：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):   <span class="comment">#编写Animal类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Animal is running...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):  <span class="comment">#Dog类继承Amimal类，没有run方法</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):  <span class="comment">#Cat类继承Animal类，有自己的run方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Cat is running...&#x27;</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(<span class="title class_ inherited__">object</span>):  <span class="comment">#Car类不继承，有自己的run方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Car is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stone</span>(<span class="title class_ inherited__">object</span>):  <span class="comment">#Stone类不继承，也没有run方法</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_twice</span>(<span class="params">animal</span>):</span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br><span class="line"></span><br><span class="line">run_twice(Animal())</span><br><span class="line">run_twice(Dog())</span><br><span class="line">run_twice(Cat())</span><br><span class="line">run_twice(Car())</span><br><span class="line">run_twice(Stone())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果如下：</span></span><br><span class="line"><span class="comment"># Animal is running...</span></span><br><span class="line"><span class="comment"># Animal is running...</span></span><br><span class="line"><span class="comment"># Animal is running...</span></span><br><span class="line"><span class="comment"># Animal is running...</span></span><br><span class="line"><span class="comment"># Cat is running...</span></span><br><span class="line"><span class="comment"># Cat is running...</span></span><br><span class="line"><span class="comment"># Car is running...</span></span><br><span class="line"><span class="comment"># Car is running...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AttributeError: &#x27;Stone&#x27; object has no attribute &#x27;run&#x27;</span></span><br><span class="line"><span class="comment"># 除石头吃了不会跑的亏外，其余的都能run，都是“鸭子”。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="获取对象信息-待整理"><a href="#获取对象信息-待整理" class="headerlink" title="获取对象信息(待整理)"></a>获取对象信息(待整理)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用type()函数来判断对象类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;type(123) =&#x27;</span>, <span class="built_in">type</span>(<span class="number">123</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;type(\&#x27;123\&#x27;) =&#x27;</span>, <span class="built_in">type</span>(<span class="string">&#x27;123&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;type(None) =&#x27;</span>, <span class="built_in">type</span>(<span class="literal">None</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;type(abs) =&#x27;</span>, <span class="built_in">type</span>(<span class="built_in">abs</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;type(\&#x27;abc\&#x27;)==str?&#x27;</span>, <span class="built_in">type</span>(<span class="string">&#x27;abc&#x27;</span>)==<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果如下：</span></span><br><span class="line"><span class="comment"># type(123) = &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="comment"># type(&#x27;123&#x27;) = &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="comment"># type(None) = &lt;class &#x27;NoneType&#x27;&gt;</span></span><br><span class="line"><span class="comment"># type(abs) = &lt;class &#x27;builtin_function_or_method&#x27;&gt;</span></span><br><span class="line"><span class="comment"># type(&#x27;abc&#x27;)==str? True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.x = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.x * self.x</span><br><span class="line"></span><br><span class="line">obj = MyObject()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hasattr(obj, \&#x27;x\&#x27;) =&#x27;</span>, <span class="built_in">hasattr</span>(obj, <span class="string">&#x27;x&#x27;</span>)) <span class="comment"># 有属性&#x27;x&#x27;吗？</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hasattr(obj, \&#x27;y\&#x27;) =&#x27;</span>, <span class="built_in">hasattr</span>(obj, <span class="string">&#x27;y&#x27;</span>)) <span class="comment"># 有属性&#x27;y&#x27;吗？</span></span><br><span class="line"><span class="built_in">setattr</span>(obj, <span class="string">&#x27;y&#x27;</span>, <span class="number">19</span>) <span class="comment"># 设置一个属性&#x27;y&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hasattr(obj, \&#x27;y\&#x27;) =&#x27;</span>, <span class="built_in">hasattr</span>(obj, <span class="string">&#x27;y&#x27;</span>)) <span class="comment"># 有属性&#x27;y&#x27;吗？</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;getattr(obj, \&#x27;y\&#x27;) =&#x27;</span>, <span class="built_in">getattr</span>(obj, <span class="string">&#x27;y&#x27;</span>)) <span class="comment"># 获取属性&#x27;y&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;obj.y =&#x27;</span>, obj.y) <span class="comment"># 获取属性&#x27;y&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;getattr(obj, \&#x27;z\&#x27;) =&#x27;</span>,<span class="built_in">getattr</span>(obj, <span class="string">&#x27;z&#x27;</span>, <span class="number">404</span>)) <span class="comment"># 获取属性&#x27;z&#x27;，如果不存在，返回默认值404</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">getattr</span>(obj, <span class="string">&#x27;power&#x27;</span>) <span class="comment"># 获取属性&#x27;power&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"><span class="built_in">print</span>(f())</span><br></pre></td></tr></table></figure>
<h1 id="示例属性和类属性（待整理）"><a href="#示例属性和类属性（待整理）" class="headerlink" title="示例属性和类属性（待整理）"></a>示例属性和类属性（待整理）</h1><p>由于Python是动态语言，根据类创建的实例可以任意绑定属性。给实例绑定属性的方法是通过实例变量，或者通过self变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写一个Student类,并定义一个类属性，这个属性归Student类所有，但是所有实例都可以访问到</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;Student&#x27;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 创建实例s</span></span><br><span class="line">s = Student()</span><br><span class="line"><span class="comment"># 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性（向上查找）</span></span><br><span class="line"><span class="built_in">print</span>(s.name) </span><br><span class="line"><span class="comment"># 输出为Student</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印类的name属性（原本就定义了类的name属性）</span></span><br><span class="line"><span class="built_in">print</span>(Student.name) </span><br><span class="line"><span class="comment"># 输出为Student</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给实例绑定name属性</span></span><br><span class="line">s.name = <span class="string">&#x27;Michael&#x27;</span> </span><br><span class="line"><span class="comment"># 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性（优先输出实例的属性）</span></span><br><span class="line"><span class="built_in">print</span>(s.name) </span><br><span class="line"><span class="comment"># 但是类属性并未消失，用Student.name仍然可以访问</span></span><br><span class="line"><span class="built_in">print</span>(Student.name) </span><br><span class="line"><span class="comment"># 分别输出为：Michael     Student</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> s.name <span class="comment"># 如果删除实例的name属性</span></span><br><span class="line"><span class="built_in">print</span>(s.name) <span class="comment"># 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了（再次向上访问）</span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>实例属性属于各个实例所有，互不干扰；</li>
<li>类属性属于类所有，所有实例共享一个属性；</li>
<li>不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。</li>
</ol>
<h1 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h1><p>由面对对象的三个基础概念（封装、继承和多态）继续进行深入的延展——多重继承、定制类、元类等概念（面向对象高级编程）</p>
<h1 id="使用-slots"><a href="#使用-slots" class="headerlink" title="使用__slots__"></a>使用__slots__</h1><h1 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h1><p>在牛客网上的一些基础题上面经常碰到</p>
<h1 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h1><h1 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h1><h1 id="使用枚举类"><a href="#使用枚举类" class="headerlink" title="使用枚举类"></a>使用枚举类</h1><h1 id="使用元类"><a href="#使用元类" class="headerlink" title="使用元类"></a>使用元类</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/23/%E7%B3%BB%E7%BB%9F%E8%AF%A6%E7%BB%86%E7%9A%84%E6%95%B4%E7%90%86%E5%85%B3%E4%BA%8Epython%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" data-id="claqu8zzy002tiwtkgqe72a9u" data-title="系统详细的整理关于python中的面向对象编程/面对对象高级编程" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-哈希表问题汇总（散列函数）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/21/%E5%93%88%E5%B8%8C%E8%A1%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2022-03-21T15:48:30.000Z" itemprop="datePublished">2022-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/21/%E5%93%88%E5%B8%8C%E8%A1%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%EF%BC%89/">哈希表问题汇总（散列函数）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>1 Two Sum (Easy)</li>
<li>217 Contains Duplicate (Easy)</li>
<li>594 Longest Harmonious Subsequence (Easy)</li>
<li>128 Longest Consecutive Sequence (Hard)</li>
<li>349 两个数组的交集（easy）</li>
<li>350 两个数组的交集 II（easy）</li>
<li>242 有效的字母异位词（easy）</li>
<li>202 快乐数（easy）</li>
<li>205 同构字符串（easy）</li>
<li>451 根据字符出现频率排序（medium）</li>
<li>15 三数之和（medium）</li>
<li>18 四数之和（medium）</li>
<li>454 四数相加 II（medium）</li>
<li>49 字母异位词分组（medium）</li>
<li>447 回旋镖的数量（easy）</li>
<li>149 直线上最多的点数（hard）</li>
<li>219 存在重复元素 II（easy）</li>
<li>220 存在重复元素 III（medium）</li>
</ul>
<p><strong>哈希表的基础知识：</strong><br>散列表是一种数据结构，其中数据元素的地址或索引值是由散列函数生成的。这使得访问数据的速度更快，因为索引值是数据值的关键字。换句话说，哈希表存储键值对，但密钥是通过哈希函数生成的。<br>因此，数据元素的搜索和插入函数变得更快，因为键值本身成为存储数据的数组的索引。<br>在Python中，Dictionary数据类型表示哈希表的实现。以下为根据廖雪峰的资料做的整理：<br><strong>dic:</strong></p>
<ol>
<li>内置字典：dic的支持，在其他语言中称map，使用键-值（key-value）存储，具有极快的查找度</li>
<li>实现方法：给定一个名字，dic在内部就直接计算出名字对应的存放成绩的内存地址，直接取出来</li>
<li>存储条件：key-value存储方式：必须根据key算出value的存放位置，取出才能根据key直接拿到Value,可以通过 key放入来把数据放入dict中</li>
<li>一个key对应一个value，多次对一个key放入value，后面的值会把前面的值冲掉</li>
<li><strong>避免key不存在的错误的两种方法</strong><ol>
<li>通过in判断key是否存在：</li>
<li><strong>通过dict提供的get()方法</strong>，如果不存在的话，可以返回None，或者自己指定的value</li>
</ol>
</li>
<li>要删除一个key，用pop(key)方法，对应的value也会从dict中删除</li>
<li>dict内部存放的顺序和key放入的顺序是没有关系的</li>
</ol>
<p>哈希函数（Hash Function）：将哈希表中元素的关键键值映射为元素存储位置的函数<br>哈希冲突（Hash Collision）：将不同的关键字通过一个哈希函数可能得到同一个哈希地址<br>哈希表的核心问题：哈希函数的构建和哈希冲突的解决办法</p>
<p><strong>dict.get() 与 dict[‘key’] 的区别</strong><br>1.dict[‘key’]只能获取存在的值，如果不存在则触发KeyError<br>2.dict.get(key, default&#x3D;None)则如果不存在则返回一个默认值，如果设置了则是设置的，否则就是None</p>
<p><strong>和list比较后，dict的几个特点：</strong></p>
<ol>
<li>查找和插入的速度极快，不会随着key的增加而变慢，但是list相反，时间随元素的增加而增加</li>
<li>需要占用大量的内存，内存浪费多，但是list相反，占用空间小，浪费内存很小</li>
<li>在需要高速查找的地方无处不在，关键点：dict的key必须是不可变对象：通过key计算位置的算法为哈希算法，要保证算法的正确性，作为key的对象就不能变[字符串–整数等都是不可变的]（hash）,list是可变的，不能作为key</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 附上代码加强理解</span></span><br><span class="line"><span class="comment"># 新建一个字典，存入&#x27;名字-成绩&#x27;的对照表（无论表多大，查找的速度都不会慢）</span></span><br><span class="line">d = &#123; <span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Bob&#x27;</span>: <span class="number">75</span>,<span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;d[\&#x27;Michael\&#x27;] =&#x27;</span>, d[<span class="string">&#x27;Michael&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;d[\&#x27;Bob\&#x27;] =&#x27;</span>, d[<span class="string">&#x27;Bob&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;d[\&#x27;Tracy\&#x27;] =&#x27;</span>, d[<span class="string">&#x27;Tracy&#x27;</span>])</span><br><span class="line"><span class="comment"># 通过dict提供的get()方法，如果key不存在，返回自己指定的&#x27;-1&#x27;,这里是查看Thomas的成绩是否存在，如果不存在就返回-1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;d.get(\&#x27;Thomas\&#x27;, -1) =&#x27;</span>, d.get(<span class="string">&#x27;Thomas&#x27;</span>, -<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 打印输出结果</span></span><br><span class="line"><span class="comment"># d[&#x27;Michael&#x27;] = 95       </span></span><br><span class="line"><span class="comment"># d[&#x27;Bob&#x27;] = 75</span></span><br><span class="line"><span class="comment"># d[&#x27;Tracy&#x27;] = 85</span></span><br><span class="line"><span class="comment"># d.get(&#x27;Thomas&#x27;, -1) = -1</span></span><br></pre></td></tr></table></figure>
<p><strong>set:需要好好的理解，并且要运用好</strong></p>
<ol>
<li><strong>与dict比较的类似</strong>，一组key的集合，但不存储value，在set中没有重复的key</li>
<li>要创建一个set，需要提供一个list作为输入集合</li>
<li>重复元素在set中自动被过滤：</li>
<li>通过add(key)方法可以添加元素到set中，可以重复添加，但是没有效果</li>
<li>通过remove（key）方法可以删除元素</li>
<li><strong>set可以看成数学意义上的无序和无重复元素的集合</strong>，两个set可以做数学意义上的交集、并集等操作。</li>
<li><strong>和dic的唯一区别：没有存储对应的value值</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 附上代码，加强对set的理解</span></span><br><span class="line">s1 = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重复元素在set中自动被过滤</span></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line">s2 = <span class="built_in">set</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印s1和s2的交集</span></span><br><span class="line"><span class="built_in">print</span>(s1 &amp; s2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印s1和s2的并集</span></span><br><span class="line"><span class="built_in">print</span>(s1 | s2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过add(key)的方法添加4到set中</span></span><br><span class="line">s1.add(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过remove(key)的方法删除s2中的元素</span></span><br><span class="line">s2.remove(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(s2)</span><br><span class="line"><span class="comment"># 输出结果如下：</span></span><br><span class="line"><span class="comment"># &#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="comment"># &#123;2, 3&#125;</span></span><br><span class="line"><span class="comment"># &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="comment"># &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="comment"># &#123;3, 4&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="通俗理解set和dict背后的哈希表"><a href="#通俗理解set和dict背后的哈希表" class="headerlink" title="通俗理解set和dict背后的哈希表"></a>通俗理解set和dict背后的哈希表</h1><p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39657125/article/details/111293311">https://blog.csdn.net/weixin_39657125/article/details/111293311</a><br>set,dict都是基于哈希表的数据结构<br>哈希表的实现基于数组和链表<br>哈希表是重要的数据结构；Python使用它们来实现两种重要的内置数据类型，dict和set（哈希表不是字典，字典和集合这两种数据类型是由哈希表来实现的）<br>字典是将键映射到值的一般概念。实现这种映射有很多方法，红黑树也可以实现字典</p>
<h1 id="关于python中字典的一些操作"><a href="#关于python中字典的一些操作" class="headerlink" title="关于python中字典的一些操作"></a>关于python中字典的一些操作</h1><p>参考链接：<br><a target="_blank" rel="noopener" href="https://www.cjavapy.com/article/934/">https://www.cjavapy.com/article/934/</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/guifei010/article/details/79165785?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.pc_relevant_default&amp;utm_relevant_index=1">https://blog.csdn.net/guifei010/article/details/79165785?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.pc_relevant_default&amp;utm_relevant_index=1</a><br>因为字典相对运用的也不少，所以要做一个比较全面的总结，方便后续代码的撰写<br><strong>创建字典：</strong></p>
<ol>
<li>d &#x3D; {}</li>
<li>d &#x3D; dict()</li>
<li>导入pytho内置的模块：<br><strong>访问字典里面的值</strong></li>
<li>通过在方括号内引用其键名来访问字典的各项 ：x&#x3D; d[“name”]  获取key为“name”的值</li>
<li>用get()方法来访问:x&#x3D;d.get(“age”)   获取”age”键的值<br><strong>改变字典中的值</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thisdict = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;cjavapy&quot;</span>,<span class="string">&quot;age&quot;</span>: <span class="number">3</span>,<span class="string">&quot;gender&quot;</span>: <span class="string">&quot;man&quot;</span>&#125;</span><br><span class="line">thisdict[<span class="string">&quot;age&quot;</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(thisdict)</span><br><span class="line"><span class="comment"># &#123;&quot;name&quot;: &quot;cjavapy&quot;,&quot;age&quot;: 5,&quot;gender&quot;: &quot;man&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<strong>遍历字典（用的最多的）</strong><br>写在前面：遍历字典中这三个是用得非常非常多的，必须要牢记住： keys()  、values() 、items()，分别是返回字典中的所有key、返回字典中的所有值、返回字典中的所有key&#x3D;value的值（返回的就是一个可以迭代的对象）</li>
<li>用for 循环来遍历字典：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐行但打印字典中所有键的名称</span></span><br><span class="line">thisdict =&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;XR&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;man&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;web&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> thisdict:</span><br><span class="line">    <span class="comment">#print(x)</span></span><br><span class="line">    value=thisdict[x]</span><br><span class="line">    <span class="comment"># print(&quot;%s:%s&quot;%(x,value))</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;:&#125;:&#123;:&#125;&quot;</span>.<span class="built_in">format</span>(x,value))</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"><span class="comment"># 输出如下：</span></span><br><span class="line"><span class="comment"># name:XR</span></span><br><span class="line"><span class="comment"># age:28</span></span><br><span class="line"><span class="comment"># gender:man</span></span><br><span class="line"><span class="comment"># address:web</span></span><br><span class="line"><span class="comment"># 逐行打印字典中的所有值</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> thisdict:</span><br><span class="line">    <span class="built_in">print</span>(thisdict[x])</span><br></pre></td></tr></table></figure></li>
<li>用values()方法来返回字典的值(和上面输出的是相同的)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vales= thisdict.values()  # 这种就是取出了所有的value值了</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> thisdict.values():</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure></li>
<li>使用items()来循环遍历键和值<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这道题是牛客网上的一道题，用的字典来写的，磕磕巴巴的写出来的</span></span><br><span class="line">hashmap=&#123;<span class="string">&#x27;rzuwnjvnuz 633&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;atl 637&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;rwyfvzsopsuiqjnr 647&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;eez 648&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;fmwafhhgeyawnool 649&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;c 637&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;f 633&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;ywzqaop 631&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环遍历键和值</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> hashmap.items():</span><br><span class="line">    <span class="comment"># 注释的写法就是本质，不过这样写太麻烦了</span></span><br><span class="line">    <span class="comment"># print(key+ &quot; &quot; +str(value))</span></span><br><span class="line">    <span class="built_in">print</span>(key,value)</span><br><span class="line"><span class="comment"># 输出结果如下：</span></span><br><span class="line"><span class="comment"># rzuwnjvnuz 633 1</span></span><br><span class="line"><span class="comment"># atl 637 1</span></span><br><span class="line"><span class="comment"># rwyfvzsopsuiqjnr 647 1</span></span><br><span class="line"><span class="comment"># eez 648 1</span></span><br><span class="line"><span class="comment"># fmwafhhgeyawnool 649 1</span></span><br><span class="line"><span class="comment"># c 637 1</span></span><br><span class="line"><span class="comment"># f 633 1</span></span><br><span class="line"><span class="comment"># ywzqaop 631 2</span></span><br></pre></td></tr></table></figure>
<strong>判断Key是否存在：</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thisdict = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;cjavapy&quot;</span>,<span class="string">&quot;age&quot;</span>: <span class="number">3</span>,<span class="string">&quot;gender&quot;</span>: <span class="string">&quot;man&quot;</span>&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;name&quot;</span> <span class="keyword">in</span> thisdict:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#x27;name&#x27;存在字典中&quot;</span>)   </span><br><span class="line"><span class="comment"># &#x27;name&#x27;存在字典中</span></span><br></pre></td></tr></table></figure>
<strong>字典的长度：</strong><br>主要是为了确定字典中有多少项（键值对）<br>print(len(thisdict))</li>
</ol>
<p><strong>向字典中添加项目元素</strong><br>主要通过新的索引键为其分配值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thisdict = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;   XR&quot;</span>,<span class="string">&quot;age&quot;</span>: <span class="number">28</span>,<span class="string">&quot;gender&quot;</span>: <span class="string">&quot;man&quot;</span>&#125;</span><br><span class="line">thisdict[<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;web&quot;</span></span><br><span class="line"><span class="built_in">print</span>(thisdict)</span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;   XR&#x27;, &#x27;age&#x27;: 28, &#x27;gender&#x27;: &#x27;man&#x27;, &#x27;address&#x27;: &#x27;web&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>删除字典中项目元素</strong></p>
<ol>
<li>pop()方法移除具有指定key的项:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thisdict =&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;XR&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;man&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;web&#x27;</span>&#125;</span><br><span class="line">thisdict.pop(<span class="string">&quot;age&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(thisdict)</span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;XR&#x27;, &#x27;gender&#x27;: &#x27;man&#x27;, &#x27;address&#x27;: &#x27;web&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>popitem()方法删除最后插入的项<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">thisdict =&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;XR&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;man&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;web&#x27;</span>&#125;</span><br><span class="line">thisdict.popitem()</span><br><span class="line"><span class="built_in">print</span>(thisdict)</span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;XR&#x27;, &#x27;age&#x27;: 28, &#x27;gender&#x27;: &#x27;man&#x27;&#125;</span></span><br><span class="line">````</span><br><span class="line"><span class="number">3.</span> <span class="keyword">del</span>()关键字删除具有指定键名的项目</span><br><span class="line">```python</span><br><span class="line">thisdict =&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;XR&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;man&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;web&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">del</span> thisdict[<span class="string">&quot;gender&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(thisdict)</span><br><span class="line"><span class="comment">#  &#123;&#x27;name&#x27;: &#x27;XR&#x27;, &#x27;age&#x27;: 28, &#x27;address&#x27;: &#x27;web&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>clear()方法清空字典<br>thisdict.clear()<br><strong>复制一个字典：</strong><br>不能简单地通过输入dict2 &#x3D; dict1来复制字典，因为dict2将仅是对dict1的引用，对dict1所做的更改也将自动被改为indict2。<br>有很多方法可以制作副本，一种方法是使用内置的Dictionary方法copy()。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用copy（）方法制作字典的副本：</span></span><br><span class="line">thisdict =&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;XR&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;man&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;web&#x27;</span>&#125;</span><br><span class="line">mydict=thisdict.copy()</span><br><span class="line"><span class="built_in">print</span>(mydict)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用内置函数dict()</span></span><br><span class="line">```python</span><br><span class="line">thisdict =&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;XR&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;man&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;web&#x27;</span>&#125;</span><br><span class="line">mydict=<span class="built_in">dict</span>(thisdict)</span><br><span class="line"><span class="built_in">print</span>(mydict)</span><br></pre></td></tr></table></figure>
<strong>嵌套的字典：</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建一个字典，嵌套了三个字典</span></span><br><span class="line">myfamily = &#123;</span><br><span class="line"><span class="string">&quot;child1&quot;</span> : &#123;<span class="string">&quot;name&quot;</span> : <span class="string">&quot;Emil&quot;</span>,<span class="string">&quot;year&quot;</span> : <span class="number">2004</span>&#125;,</span><br><span class="line"><span class="string">&quot;child2&quot;</span> : &#123;<span class="string">&quot;name&quot;</span> : <span class="string">&quot;Tobias&quot;</span>,<span class="string">&quot;year&quot;</span> : <span class="number">2007</span>&#125;,</span><br><span class="line"><span class="string">&quot;child3&quot;</span> : &#123;<span class="string">&quot;name&quot;</span> : <span class="string">&quot;Linus&quot;</span>,<span class="string">&quot;year&quot;</span> : <span class="number">2011</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>通过 sorted函数，可以进行排序（</strong>）：**<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span>=&#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;APP&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;each&#x27;</span>: <span class="number">7</span>&#125;</span><br><span class="line">lis1=<span class="built_in">sorted</span>(<span class="built_in">dict</span>.items(),key=<span class="keyword">lambda</span> d:d[<span class="number">0</span>]) <span class="comment">#按键来排序</span></span><br><span class="line">lis2=<span class="built_in">sorted</span>(<span class="built_in">dict</span>.items(),key=<span class="keyword">lambda</span> d:d[<span class="number">1</span>]) <span class="comment">#按值来排序</span></span><br><span class="line"><span class="built_in">print</span>(lis1)</span><br><span class="line"><span class="built_in">print</span>(lis2)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[(<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;APP&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;C&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;each&#x27;</span>, <span class="number">7</span>)]</span><br><span class="line">[(<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;APP&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;C&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;each&#x27;</span>, <span class="number">7</span>)]</span><br></pre></td></tr></table></figure>
<strong>d.values()  以列表返回字典中的所有值</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hashmap = &#123;<span class="number">8</span>: <span class="number">46828</span>, <span class="number">24</span>: <span class="number">47153</span>, <span class="number">3</span>: <span class="number">93735</span>, <span class="number">13</span>: <span class="number">72600</span>, <span class="number">4</span>: <span class="number">44422</span>&#125;</span><br><span class="line">l=hashmap.values() </span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"><span class="comment"># dict_values([46828, 47153, 93735, 72600, 44422])</span></span><br></pre></td></tr></table></figure>
<strong>d.keys()    返回列表中所有的键</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hashmap = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;XR&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;man&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;web&#x27;</span>&#125;</span><br><span class="line">l=hashmap.keys() </span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># dict_keys([&#x27;name&#x27;, &#x27;age&#x27;, &#x27;gender&#x27;, &#x27;address&#x27;])</span></span><br></pre></td></tr></table></figure>
<strong>d.items()      以列表的形式返回可遍历的元组数组</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hashmap = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;XR&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;man&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;web&#x27;</span>&#125;</span><br><span class="line">l=hashmap.items() </span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"><span class="comment"># dict_items([(&#x27;name&#x27;, &#x27;XR&#x27;), (&#x27;age&#x27;, 28), (&#x27;gender&#x27;, &#x27;man&#x27;), (&#x27;address&#x27;, &#x27;web&#x27;)])</span></span><br></pre></td></tr></table></figure>
<strong>用dict.get()返回指定键的值</strong><br>语法如下：dict.get(key[,value])</li>
<li>key–字典中要查的键</li>
<li>value—如果指定的键值存在，返回默认值<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 辅助理解这个知识点</span></span><br><span class="line">hashmap = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;XR&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;man&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;web&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 直接查询</span></span><br><span class="line"><span class="built_in">print</span>(hashmap.get(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="comment"># 直接查询，查询不成功返回None</span></span><br><span class="line"><span class="built_in">print</span>(hashmap.get(<span class="string">&#x27;birth&#x27;</span>))</span><br><span class="line"><span class="comment"># 直接查询，查询不成功返回指定的输出</span></span><br><span class="line"><span class="built_in">print</span>(hashmap.get(<span class="string">&#x27;parent&#x27;</span>),<span class="string">&#x27;该项信息缺失&#x27;</span>)</span><br><span class="line"><span class="comment"># 打印结果如下</span></span><br><span class="line">XR</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="literal">None</span> 该项信息缺失</span><br></pre></td></tr></table></figure>
与dict[key]的区别：</li>
<li>get(key) 方法在 key（键）不在字典中时，可以返回默认值 None 或者设置的默认值。</li>
<li>dict[key]：在Key不在字典中的时候，会触发KeyError异常</li>
</ol>
<p><strong>d.fromkeys(seq[,val])   创建一个新字典   以序列seq中的元素做键   val做字典所有键对应的初始值</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums =[<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>]</span><br><span class="line">d1=<span class="built_in">dict</span>.fromkeys(nums, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(d1)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># &#123;0: 1, 2: 1, 5: 1, 8: 1&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>使用模块里面的字典以及与lambda结合的用法</strong><br>以一个例子来说明：<br>需要生成一个字典，对于任意key的查询，value都返回XR</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种实现</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="keyword">return</span> XR</span><br><span class="line">func2=defaultdict(func1)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二种实现：采用与lambda结合的方式（不用这种方式就会忘掉）</span></span><br><span class="line"><span class="comment"># 表示用默认的字典defaultdict,如果没有找到对应的value值，会返回一个默认值</span></span><br><span class="line">func2=defaultdict(<span class="keyword">lambda</span>:XR)</span><br></pre></td></tr></table></figure>
<p><strong>用于统计一个字符中各个字符串的数量</strong><br>这个例子使用字典特别的巧妙，值得自己去整理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t=<span class="string">&quot;ABBC&quot;</span></span><br><span class="line"><span class="comment"># hashmap=dict((i,t.count(i)) for i t)</span></span><br><span class="line"><span class="comment"># 换一种好理解的方式</span></span><br><span class="line">hashmap=<span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">    <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">        hashmap[c]=<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        hashmap[c]+=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(hashmap)</span><br><span class="line"><span class="comment"># 打印结果如下：</span></span><br><span class="line">&#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;B&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>以下为leetcoad上的一些关于哈希表的比较典型的几道题目，需要重点掌握。</p>
<h1 id="leetcoad01-两数之和"><a href="#leetcoad01-两数之和" class="headerlink" title="leetcoad01-两数之和"></a>leetcoad01-两数之和</h1><p>这是leetcoad上一道比较简单的题目，也是第一题，解法一用到了常规的思路，解法二用到了散列表也即哈希表的知识点<br>解题思路如下：<br>    * 定义一个二维数组（为了存储找到的两个数）<br>    * 写一个两层的循环，范围是0~num.size<br>    * 判断如下：如果下标为i和j的两个数之和等于目标值并且下标不相等<br>    * 把下标为i和j的两个数储存在定义的数组a里面去。<br>    * 循环结束将a输出来</p>
<p>解法一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> :</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="built_in">list</span> = [<span class="number">0</span>,<span class="number">0</span>]    <span class="comment">#定义一个二维的数组</span></span><br><span class="line">        <span class="comment">#写两层循环直接进行遍历寻找到符合相应条件的值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[j] == target <span class="keyword">and</span> i != j:</span><br><span class="line">                <span class="comment">#把相应的符合条件的下标赋值给之前定义的数组</span></span><br><span class="line">                    <span class="built_in">list</span>[<span class="number">0</span>]=i</span><br><span class="line">                    <span class="built_in">list</span>[<span class="number">1</span>]=j</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span></span><br></pre></td></tr></table></figure>
<p>解法二：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本质上将数组的值和索引存入map中，当遍历到某个值num的时候，判断map中是否含有target-x</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        two sum的做法，实际就是在nums[i+1:],求解target为-nums[i]的two sum</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">       <span class="comment"># 首先构建一个哈希表，用来存放数组的元素值以及索引值</span></span><br><span class="line">       <span class="comment"># 其中 key 是数组中的元素值</span></span><br><span class="line">       <span class="comment"># value 为数组中元素值的索引</span></span><br><span class="line">       <span class="built_in">map</span> = <span class="built_in">dict</span>()</span><br><span class="line">       <span class="comment"># 接下来，遍历整个数组，利用enumerate函数可以输出下标以及对应的值</span></span><br><span class="line">       <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">           <span class="comment"># 另外的一个值用目标值-num</span></span><br><span class="line">           anotherNum = target - num</span><br><span class="line">           <span class="comment"># 查看这个值是否在哈希表中</span></span><br><span class="line">           <span class="keyword">if</span> anotherNum <span class="keyword">in</span> <span class="built_in">map</span> :</span><br><span class="line">               <span class="comment"># 因为题目的意思答案是唯一额，如果有就可以直接输出来，返回两个数的下标</span></span><br><span class="line">               <span class="keyword">return</span> [ <span class="built_in">map</span>[ target - num ] , i ]</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               <span class="comment"># 按照nums[i] :i的格式添加到res中，key是对应的值，value是对应的下标</span></span><br><span class="line">             <span class="built_in">map</span>[nums[i]] = i</span><br><span class="line">       <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<h1 id="leetcoad15-三数之和"><a href="#leetcoad15-三数之和" class="headerlink" title="leetcoad15-三数之和"></a>leetcoad15-三数之和</h1><p>leetcoad链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a><br>视频链接：<a target="_blank" rel="noopener" href="https://www.algomooc.com/1287.html">https://www.algomooc.com/1287.html</a><br>难点分析：如何去除重复解的问题(这道题也是一个关键的题目。务必要牢牢的掌握里面的框架以及实现的细节)<br><strong>算法流程：排序+双指针</strong><br>不重复的本质：（用排序就可以解决）</p>
<ol>
<li>第二重循环枚举到的元素不小于当前第一重循环枚举到的元素</li>
<li>第三重循环枚举到的元素不小于当前第二重循环枚举到的元素<br>对于每一重循环 :相邻两次枚举的元素不能相同，也需要剔除掉，跳到下一个不相同的元素<br>基于三重循环的伪代码实现：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums.sort()</span><br><span class="line"><span class="keyword">for</span> first = <span class="number">0</span> .. n-<span class="number">1</span></span><br><span class="line">    // 只有和上一次枚举的元素不相同，我们才会进行枚举</span><br><span class="line">    <span class="keyword">if</span> first == <span class="number">0</span> <span class="keyword">or</span> nums[first] != nums[first-<span class="number">1</span>] then</span><br><span class="line">        <span class="keyword">for</span> second = first+<span class="number">1</span> .. n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> second == first+<span class="number">1</span> <span class="keyword">or</span> nums[second] != nums[second-<span class="number">1</span>] then</span><br><span class="line">                <span class="keyword">for</span> third = second+<span class="number">1</span> .. n-<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> third == second+<span class="number">1</span> <span class="keyword">or</span> nums[third] != nums[third-<span class="number">1</span>] then</span><br><span class="line">                        // 判断是否有 a+b+c==<span class="number">0</span></span><br><span class="line">                        check(first, second, third)</span><br></pre></td></tr></table></figure>
由于固定一个a，那么另外的b和c是联动的，也即第二重循环和第三重循环是并列的关系，继续优化，保持第二重循环不变，将第三重循环变成从数组的最右端开始向左移动的指针<br>伪代码实现如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums.sort()</span><br><span class="line">for first = 0 .. n-1</span><br><span class="line">    if first == 0 or nums[first] != nums[first-1] then</span><br><span class="line">        // 第三重循环对应的指针</span><br><span class="line">        third = n-1</span><br><span class="line">        for second = first+1 .. n-1</span><br><span class="line">            if second == first+1 or nums[second] != nums[second-1] then</span><br><span class="line">                // 向左移动指针，直到 a+b+c 不大于 0</span><br><span class="line">                while nums[first]+nums[second]+nums[third] &gt; 0</span><br><span class="line">                    third = third-1</span><br><span class="line">                // 判断是否有 a+b+c==0</span><br><span class="line">                check(first, second, third)</span><br></pre></td></tr></table></figure>
流程如下：</li>
<li>特判，对于数组长度 n，如果数组为 null 或者数组长度小于 3，返回 []。</li>
<li>对数组进行排序。</li>
<li>遍历排序后数组：
        
          <p class="article-more-link">
            <a href="/2022/03/21/%E5%93%88%E5%B8%8C%E8%A1%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%EF%BC%89/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/21/%E5%93%88%E5%B8%8C%E8%A1%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%EF%BC%89/" data-id="claqu8zzn0028iwtk57sh9u30" data-title="哈希表问题汇总（散列函数）" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-二叉树相关题目汇总二" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%BA%8C/" class="article-date">
  <time class="dt-published" datetime="2022-03-21T01:52:36.000Z" itemprop="datePublished">2022-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%BA%8C/">二叉树相关题目汇总二</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="leetcoad105-二叉树的最大路径和"><a href="#leetcoad105-二叉树的最大路径和" class="headerlink" title="leetcoad105-二叉树的最大路径和"></a>leetcoad105-二叉树的最大路径和</h1><p>题目描述：路径 被定义为<strong>一条从树中任意节点出发</strong>，沿<strong>父节点-子节点连接</strong>，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。<br><strong>路径和 是路径中各节点值的总和</strong>。<br>给你一个二叉树的根节点 root ，返回其 <strong>最大路径和 <strong>。<br>示例一：<br>输入：root &#x3D; [1,2,3]<br>输出：6<br>解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6<br>示例二：<br><img src="https://runnerxr.github.io/post-images/1653916663996.jpg"><br>这个例子相对比较抽象，所以放了一张图上去<br>输入：root &#x3D; [-10,9,20,null,null,15,7]<br>输出：42<br>解释：最优路径是 15 -&gt; 20 -&gt; 7 ，</strong>路径和为 15 + 20 + 7 &#x3D; 42</strong><br>解题思路：<br>按照后序遍历的框架思路来解题：要求最大的路径和，对于一个二叉树结点，先计算<strong>左子树</strong>和<strong>右子树</strong>的<strong>最大路径和</strong>，然后<strong>加上自己的值</strong>，最后得出新的最大的路径和</p>
<h2 id="看官方题解做的一点整理的东西："><a href="#看官方题解做的一点整理的东西：" class="headerlink" title="看官方题解做的一点整理的东西："></a>看官方题解做的一点整理的东西：</h2><p>路径和二叉树的数据结构有什么区别：</p>
<ol>
<li>二叉树的特点：一个节点，被<strong>一个父节点连接</strong>，连接<strong>左右两个子节点</strong></li>
<li>路径的特点：途径一个节点只能选择来去两个方向</li>
</ol>
<p>思路：从根节点递归，每次递归分别走左边、右边、不动三种情况，用当前节点+左右子树的最大路径和不断的更新最大路径和（重复写了），注意不能同时走左边和右边<br><img src="https://runnerxr.github.io/post-images/1653923132300.png"><br>定义dfs（oneSideMax）函数，返回当前子树能向父节点提供的最大路径和（<strong>一条从父节点延申下来的路径</strong>，能在当前子树中捞取的的最大收益），分为三种情况：</p>
<ol>
<li>路径停在当前子树的根节点，在当前子树的最大收益：root.val</li>
<li>走入左子树，在当前子树的最大收益：root.val+dfs(root.left)</li>
<li>走入右子树，在当前子树的最大收益：root.val+dfs(root.right)</li>
</ol>
<p>最大的收益取三者的最大值：root.val+max(0,dfs(root.left),dfs(root.right))<br>子树中的内部路径要包含根节点：</p>
<ol>
<li>最大路径和，是可能产生于其中一个子树中的</li>
<li>每递归一个子树，都求一下当前子树内部的最大路径和，从中比较出最大的</li>
<li>个子树内部的路径，要包含当前子树的根节点</li>
<li>综合分析：<strong>一个子树内部的最大路径和&#x3D;左子树提供的最大路径和+根节点+右子树提供的最大路径和</strong>（dfs(root.left）+root.val+dfs(root.right))</li>
</ol>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 定义一个全局变量，用于记录全局的最大路径和</span></span><br><span class="line">        <span class="comment"># 先初始化最大的一个路径和</span></span><br><span class="line">        self.ans=<span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="comment"># 定义递归函数：递归函数要做的就是返回当前节点可以为父节点提供的最大的收益</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">oneSideMax</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="comment"># 采用的是后续遍历的框架</span></span><br><span class="line">            <span class="comment"># 递归计算左子树的最大路径和</span></span><br><span class="line">            left=<span class="built_in">max</span>(<span class="number">0</span>,oneSideMax(root.left))</span><br><span class="line">            <span class="comment"># 递归计算右子树的最大路径和</span></span><br><span class="line">            right=<span class="built_in">max</span>(<span class="number">0</span>,oneSideMax(root.right))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大路径</span></span><br><span class="line">            <span class="comment"># 在递归的过程中还要不断的更新节点的最大路径（left--root---right的路径与历史最大值的一个比较）</span></span><br><span class="line">            self.ans=<span class="built_in">max</span>(self.ans,left+right+root.val)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 返回结点的最大路径和（返回经过root的单边最大分支给当前root的父节点计算使用）</span></span><br><span class="line">            <span class="comment"># 从上往下看，每次只能选择左或右，每次递归返回的是以当前节点可以为父节点提供的收益</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+root.val</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用oneSideMax函数，从根节点开始递归</span></span><br><span class="line">        oneSideMax(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
<p>做题反思：通过这题，更要加深对递归的认识，之前认识的可能还真不够充分，题解也是需要自己写了之后才能真正的明白，而且要反复的去咀嚼里面的文字和思想，这真的是一项很重要的功底….看别人的题解的时候就会发现别人是多么的努力尽管别人已经很优秀了。</p>
<p>联系其中的一题：</p>
<h1 id="leetcoad543-二叉树的直径"><a href="#leetcoad543-二叉树的直径" class="headerlink" title="leetcoad543-二叉树的直径"></a>leetcoad543-二叉树的直径</h1><p>给定一棵二叉树，你需要计算<strong>它的直径长度</strong>。一棵二叉树的直径长度是<strong>任意两个结点路径长度中的最大值</strong>。这条路径可能穿过也可能不穿过根结点。<br>代码略</p>
<h1 id="leetcoad99-恢复二叉搜索树"><a href="#leetcoad99-恢复二叉搜索树" class="headerlink" title="leetcoad99-恢复二叉搜索树"></a>leetcoad99-恢复二叉搜索树</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%BA%8C/" data-id="claqu8zz4001giwtk3kvd39ar" data-title="二叉树相关题目汇总二" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-搜索算法、回溯算法系类二" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/21/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E7%B1%BB%E4%BA%8C/" class="article-date">
  <time class="dt-published" datetime="2022-03-21T01:50:46.000Z" itemprop="datePublished">2022-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/21/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E7%B1%BB%E4%BA%8C/">搜索算法、回溯算法系类二</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="leetcaod22-括号生成："><a href="#leetcaod22-括号生成：" class="headerlink" title="leetcaod22-括号生成："></a>leetcaod22-括号生成：</h1><p>正确的思考思路应该是这样的：(暴力解法)</p>
<ol>
<li>生成所有的序列</li>
<li>检查是否有效</li>
<li>模式识别：子问题和原问题具有相同的结构，考虑至上而下的递归</li>
</ol>
<p>然后通过判断优化解题方法：（回溯）<br>暴力解法中直到序列生成完才进行相应的筛选，其中已经生成了很多无序的序列，现在<strong>考虑在生成过程中确保每一步都能产生有序序列</strong>，利用回溯搜索其他可能的解答。</p>
<p>1. </p>
<p>这点有一题解写的非常好，摘录在这里<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/">https://leetcode.cn/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/</a></p>
<p>根据题解的思路自己也手动模拟一个这个实现的过程，十分标准的二叉树的回溯过程，其中上面的一张是不管其他条件，生成的类似于全排列的序列，下面的是看考虑剪枝的一个过程：右边的括号数量大于左边的时候就需要剪枝（可以去除很多无用的答案），所以这题既是要有思路，同时对于回溯算法的具体还要熟悉，实际的要求并不算低，还是很考验能力水平的。自己既然做这道题就把相应的每个细节都要考虑到。<br><img src="https://runnerxr.github.io/post-images/1652618958937.jpg"><br>先把最基本的实现所有组合实现出来，然后再去改进这个过程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本质上是一个树的深度优先搜索（前序遍历：首先收集左孩子，然后走到底，到了叶子节点再回头收拾右子节点）</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">if</span> n &lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">paths</span>):</span><br><span class="line">            <span class="comment"># 括号是成队出现的</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(paths)==n*<span class="number">2</span>:</span><br><span class="line">                res.append(paths)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(paths+<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            dfs(paths+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        dfs(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ans=Solution().generateParenthesis(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br><span class="line"><span class="comment"># 打印结果如下：</span></span><br><span class="line">[<span class="string">&#x27;((((&#x27;</span>, <span class="string">&#x27;((()&#x27;</span>, <span class="string">&#x27;(()(&#x27;</span>, <span class="string">&#x27;(())&#x27;</span>, <span class="string">&#x27;()((&#x27;</span>, <span class="string">&#x27;()()&#x27;</span>, <span class="string">&#x27;())(&#x27;</span>, <span class="string">&#x27;()))&#x27;</span>, <span class="string">&#x27;)(((&#x27;</span>, <span class="string">&#x27;)(()&#x27;</span>, <span class="string">&#x27;)()(&#x27;</span>, <span class="string">&#x27;)())&#x27;</span>, <span class="string">&#x27;))((&#x27;</span>, <span class="string">&#x27;))()&#x27;</span>, <span class="string">&#x27;)))(&#x27;</span>, <span class="string">&#x27;))))&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>在上面的基础上，将一些不用的结果进行去除：限制左括号与右括号的数量，增加left与right参数，分别代表左括号与右括号的数量，每生成一个就增加一个<br>其中不是有效的情况是：右边的括号数量大于左边的括号数量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">if</span> n &lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">paths,left,right</span>):</span><br><span class="line">            <span class="comment"># 限制左括号的数量不超过n，右括号的数量不超过左括号的数量</span></span><br><span class="line">            <span class="keyword">if</span> left&gt;n <span class="keyword">or</span> right &gt;left:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 括号是成队出现的</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(paths)==n*<span class="number">2</span>:</span><br><span class="line">                res.append(paths)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(paths+<span class="string">&#x27;(&#x27;</span>,left+<span class="number">1</span>,right)</span><br><span class="line">            dfs(paths+<span class="string">&#x27;)&#x27;</span>,left,right+<span class="number">1</span>)</span><br><span class="line">        dfs(<span class="string">&#x27;&#x27;</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ans=Solution().generateParenthesis(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;(())&#x27;</span>, <span class="string">&#x27;()()&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>采用深度优先搜索的方式解题：<br>&lt;&gt;<br>可以生出左枝叶的条件：左括号的剩余数量（严格）大于0：<br>可以生出右枝叶的条件：左括号剩余数量（严格）小于右括号剩余数量</p>
<p>采用动态规划的思路来解题：</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/21/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E7%B1%BB%E4%BA%8C/" data-id="claqu8zzt002iiwtkduelehud" data-title="搜索算法、回溯算法系类二" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-搜索算法、回溯算法系列一" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/21/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B8%80/" class="article-date">
  <time class="dt-published" datetime="2022-03-21T01:50:27.000Z" itemprop="datePublished">2022-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/21/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B8%80/">搜索算法、回溯算法系列一</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="深度优先搜索（Depth-First-Search-DFS）"><a href="#深度优先搜索（Depth-First-Search-DFS）" class="headerlink" title="深度优先搜索（Depth-First-Search,DFS）"></a>深度优先搜索（Depth-First-Search,DFS）</h1><p>类似于树的先序遍历，这种搜素算法尽可能深的去搜索一个图<br>参考链接：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/">https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/</a></p>
<h2 id="DFS和回溯算法的区别："><a href="#DFS和回溯算法的区别：" class="headerlink" title="DFS和回溯算法的区别："></a>DFS和回溯算法的区别：</h2><p>DFS:一种用于遍历或搜索树或图的算法，尽可能深的搜索树的分支，当结点 v 的所在边都己被探寻过，搜索将 回溯 到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。<br>回溯算法：采用试错的思想，尝试分步的去解决问题，在分步解决的过程中，当尝试发现有的分步答案不能得到有效的正确的解答的时候，<strong>取消上一步甚至上几步的计算</strong>，再通过其他可能的分步解答再次尝试寻找问题的答案。反复重复上诉过程后会有两种情况：</p>
<ol>
<li>找到一个可能存在的正确的答案</li>
<li>再尝试了所有可能的分步办法后宣告该问题没有答案。</li>
</ol>
<p>DFS 是一个劲的往某一个方向搜索，而回溯算法建立在 DFS 基础之上的，但不同的是在搜索过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索。因此回溯算法与 DFS 的区别就是有无状态重置，它强调了回退操作对于搜素的合理性，DFS强调一种遍历的思想。（广度优先遍历是另外的一种思想）</p>
<h2 id="与动态规划的区别："><a href="#与动态规划的区别：" class="headerlink" title="与动态规划的区别："></a>与动态规划的区别：</h2><p>共同点：用于求解多阶段的决策问题</p>
<ol>
<li>求解一个问题分为很多的步骤（阶段）</li>
<li>每一个步骤（阶段）可以有多种选择<br>不同点：</li>
<li>动态规划只是要求我们评估最优解是多少，最优解对应的具体解是什么并不要求，很适合应用于评估一个方案的效果</li>
<li>回溯算法可以得到所有方案（最优解含在内），本质是一种遍历算法，时间复杂度很高</li>
</ol>
<h2 id="何时使用回溯算法："><a href="#何时使用回溯算法：" class="headerlink" title="何时使用回溯算法："></a>何时使用回溯算法：</h2><p>当问题需要 “回头”，以此来查找出所有的解的时候，使用回溯算法。即<strong>满足结束条件或者发现不是正确路径的时候(走不通)，要撤销选择</strong>，<strong>回退到上一个状态，继续尝试，直到找出所有解为止</strong>。一般题目中看到需要求所有可能的结果，而不是结果个数的时候，我们就需要用暴力搜索所有的可行解，可以采用回溯法。</p>
<h2 id="递归函数的下面就是回溯的逻辑"><a href="#递归函数的下面就是回溯的逻辑" class="headerlink" title="递归函数的下面就是回溯的逻辑"></a>递归函数的下面就是回溯的逻辑</h2><p>树具有天然的递归：一般这种回溯的题目都是用的树来理解十分的清晰<br><strong>树的宽度用一个for循环来遍历，树的深度就是用的递归的性质</strong></p>
<h2 id="对于剪枝的理解："><a href="#对于剪枝的理解：" class="headerlink" title="对于剪枝的理解："></a>对于剪枝的理解：</h2><p>回溯算法的时间复杂度很高，在遍历的时候如果 能提前知道这一条分支不能搜索到满意的结果，就可以提前结束，加快搜索速度，有时候也需要做一些预处理（排序）才能达到剪枝的目的，预处理也耗时间，但是能够剪枝节约的时间更多。本质上是一种技巧，需要根据不同问题的场景采用不同的剪枝策略，需要在做题的过程中不断的进行总结。由于时间复杂度高，能够用空间换时间就尽量的换。</p>
<h2 id="一般来说回溯算法的思考步骤如下："><a href="#一般来说回溯算法的思考步骤如下：" class="headerlink" title="一般来说回溯算法的思考步骤如下："></a>一般来说回溯算法的思考步骤如下：</h2><p>（结合子集的题目来重点分析将大部分回溯算法的题目掌握清楚，当作一套模板背一下）</p>
<ol>
<li>画出递归树，找到状态变量（当画出树形图之后，整个思路就会一目了然，回溯函数的参数）：不断的去思考<ol>
<li>分支如何产生</li>
<li>题目需要的解在哪里？是在<strong>叶子节点</strong>，还是在<strong>非叶子节点</strong>，还是<strong>从根节点到叶子节点的路径</strong>？</li>
<li><strong>哪些搜索会产生不需要的解</strong>？产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？</li>
</ol>
</li>
<li>寻找结束条件，由于回溯算法是<strong>借助递归</strong>实现的，所以就是需要去寻找递归的终止条件（当前想要遍历的元素操作数组的长度）</li>
<li>确定选择列表，即需要把什么数据存储到结果里面</li>
<li>判断是否需要剪枝，去判断此时存储的数据是否之前已经被储存过（子集II,组合总和II,除去一些不符合题目要求的数，一些比较垃圾的逻辑，需要提前一步剪短）</li>
<li>做出选择，<strong>递归调用该函数，进入下一层继续搜索</strong></li>
<li><strong>撤销选择</strong>，回到上一层的状态（5和6就是通过两个函数来执行选与不选的操作的）</li>
</ol>
<h2 id="回溯算法的模板"><a href="#回溯算法的模板" class="headerlink" title="回溯算法的模板"></a>回溯算法的模板</h2><p>（参考东哥的算法小抄的理解）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ressult=[]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">路径，选择列表</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.append(路径)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrace(路径，选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>
<p>根据书上的额一些讲解，整理一些相对比较重点的点：</p>
<ol>
<li>核心就是for 循环里面的递归，<strong>在递归调用前做选择，在递归调用之后做撤销选择</strong></li>
<li>定义的回溯函数就像时一个指针，在决策树上进行遍历，同时正确维护每个节点的属性，每当走到树的底层，其”路径”就是一个子集（以子集举例）</li>
<li>前序遍历的代码：在进入某个节点之前的那个时间点执行；后序遍历的代码：在离开某个节点之后的那个时间点执行</li>
<li>做选择：从选择列表中拿出一个作为选择，并将它加入路径之中</li>
<li>撤销选择：从路径中拿出一个选择，将它恢复到“选择列表中”</li>
</ol>
<p>在写一遍框架模板：(加深印象)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">    <span class="comment"># 做选择</span></span><br><span class="line">    将该选择从列表中移除</span><br><span class="line">    路径.append(选择)</span><br><span class="line">    backtarce(路径，选择)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    路径.pop(选择)</span><br><span class="line">    将该选择恢复到选择列表中</span><br></pre></td></tr></table></figure>
<p>这里既然已经谈到了回溯的算法（DFS）,也顺便把广度优先搜索的也整理一下，相应的思想要做一些区分的工作，而且层序遍历、滑动窗口的最大值这两道题也用到了BSF的思想还有二叉树的最小高度<br>主要是想把BFS的框架整理一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 未完待续</span></span><br><span class="line"><span class="comment"># 计算从起点start到终点tareget的最短距离</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">start,target</span>):</span><br><span class="line">    q=queqe()  <span class="comment"># 核心数据结构</span></span><br><span class="line">    visted=[]    <span class="comment">#避免走回头路</span></span><br><span class="line">    <span class="comment"># 将起点加入队列中</span></span><br><span class="line">    q.add(start)</span><br><span class="line">    visited.append(start)</span><br><span class="line">    step = <span class="number">0</span> <span class="comment"># 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> q <span class="keyword">not</span> empty:</span><br><span class="line">        n=<span class="built_in">len</span>(q)</span><br><span class="line">        <span class="comment"># 将当前队列中的所有结点向四周扩散</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cur=</span><br></pre></td></tr></table></figure>
<p>以下为回溯法的一些题目，这里先做一些汇总如下：主要是做了这么多的题目要找到相应的一些套路是十分重要的，多做总结，多归类才能进步的更快，一点一滴的要整理清楚。</p>
<h1 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h1><ol>
<li>leetcoad200-岛屿数量（很经典，值得多做，而且里面的方法也是值得在很多题目里面借鉴的）</li>
</ol>
<h1 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h1><ol>
<li>leetcoad78-子集（*）</li>
<li>leetcoad90-子集II（**）：需要排序，然后还要剪枝</li>
</ol>
<h1 id="组合问题："><a href="#组合问题：" class="headerlink" title="组合问题："></a>组合问题：</h1><ol>
<li>leetcoad77-组合（*递归出口地条件比较特殊）</li>
<li>leetcoad39-组合总和（**递归出口地条件有两个：目标值小于和目标值等于0，后续地一切元素地选择只能从函数地参数开始）</li>
<li>leetcoad40-组合总数II（***在组合总和地基础上其他条件不变，附加需要对元素先排序，然后再剪枝）</li>
<li>leetcoad216-组合总和III（暂时未涉及）</li>
</ol>
<h1 id="排列问题："><a href="#排列问题：" class="headerlink" title="排列问题："></a>排列问题：</h1><ol>
<li>leetcoad46-全排列</li>
<li>leetcoad47-全排列II</li>
</ol>
<h1 id="leetcoad200-岛屿数量"><a href="#leetcoad200-岛屿数量" class="headerlink" title="leetcoad200-岛屿数量(****)"></a>leetcoad200-岛屿数量(****)</h1><p>非常好的一道题，值得认真反复的回味清楚，而且可能还有其他的一些解法什么的，都是需要理解的，也是很基础的DFS的题目，是一道很单纯的题目，每次做一遍都会有新的发现,做个10几遍都不为过。<br>解题思路：</p>
<ol>
<li>创建一个同样大小的二维网格mark(初始化每个都是0)：用这个网格来统计二维数组中的岛屿数量的</li>
<li>每次判断网格是1的时候就记录下来，开始按照上、左、下、右的顺序去搜索当前的网格</li>
<li>0代表当前网格没有被访问，1代表当前网格被访问了</li>
<li>遍历二维网格，对每行、每列进行一个访问<ol>
<li>如果发现（i，j）是没有标记的陆地</li>
<li>对该位置进行搜索，调用DFS函数</li>
</ol>
</li>
<li>DFS函数的书写：<ol>
<li>先找一个已经遍历的</li>
<li>定义方向组</li>
<li>通过for循环来找到相邻的四个方向<ol>
<li>如果新的方向发生了越界（超出了数组边界）<ol>
<li>跳出循环</li>
</ol>
</li>
<li>如果发现新的位置是陆地，并且没有被标记过<ol>
<li>递归搜索函数发现新的位置（用递归的时候就要注意将标记改为1，防止被重复的访问，找到一处就标记一处）</li>
<li>搜索完之后，岛屿数量+1</li>
<li>每次完成一次搜索，都会往前回退（原路返回，回退一步就扩大岛的面积，不断扩大，直至形成一个孤岛）<br><img src="https://runnerxr.github.io/post-images/1651335354445.png"><br><img src="https://runnerxr.github.io/post-images/1651335481424.png"><br><img src="https://runnerxr.github.io/post-images/1651335984684.png"><br><img src="https://runnerxr.github.io/post-images/1651336156364.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># count 代表岛屿数量</span></span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="comment"># mark 标记已经搜索的位置，大小与 grid 一致(这里需要理解，这里借助的是另外的数组，没有更改原数组的值，有些题解中，将原来为1的值经过搜索后改为0，直到搜索后不再发现0为止)</span></span><br><span class="line">        <span class="comment"># mark 初始化为 0，代表当前网格没有被访问</span></span><br><span class="line">        mark=[[<span class="number">0</span>]*<span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid))]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历 grid，对每行每列都进行访问</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[i])):</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果发现位置 （i ，j）是没有标记的陆地(是陆地，并且没有被搜索过)</span></span><br><span class="line">                <span class="keyword">if</span> grid[i][j] ==<span class="string">&quot;1&quot;</span><span class="keyword">and</span> mark[i][j]==<span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 对该位置进行搜索，看看有没有其他的陆地和它共同的组成岛屿</span></span><br><span class="line">                    <span class="comment"># 调用私有函数</span></span><br><span class="line">                    self.DFS(grid,i,j,mark)</span><br><span class="line">                    <span class="comment"># 对 （i ，j）完成搜索后，岛屿数量加 1</span></span><br><span class="line">                    count +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将 grid 中与 x ，y 相连的位置在 mark 中进行标记</span></span><br><span class="line">    <span class="comment"># x表示行坐标，y表示列坐标</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">self,grid,x,y,mark: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) :</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前搜索位置在 mark 中标记为 1 ，代表已经遍历了</span></span><br><span class="line">        mark[x][y]=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 循环遍历当前位置的上、下、左、右四个方向，这里写成了循环的方式，有的地方是分别按照4个敌对来写的</span></span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> ((-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>)):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># newX 代表新的行</span></span><br><span class="line">            newX=dx + x</span><br><span class="line"></span><br><span class="line">            <span class="comment"># newY 代表新的列</span></span><br><span class="line">            newY = dy + y</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果新的位置超出了数组边界</span></span><br><span class="line">            <span class="comment"># x坐标超出左右边界，y坐标超出上下边界</span></span><br><span class="line">            <span class="keyword">if</span> newX&lt; <span class="number">0</span> <span class="keyword">or</span> newX&gt;=<span class="built_in">len</span>(mark) <span class="keyword">or</span> newY &lt;<span class="number">0</span> <span class="keyword">or</span> newY &gt;=<span class="built_in">len</span>(mark[newX]):</span><br><span class="line">                <span class="comment"># 跳出该位置</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果发现新位置是陆地，并且没有被标记过</span></span><br><span class="line">            <span class="keyword">if</span> grid[newX][newY]==<span class="string">&quot;1&quot;</span> <span class="keyword">and</span> mark[newX][newY]==<span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 递归搜索新的位置，查看是否还有新的位置是陆地，共同的加入形成岛屿</span></span><br><span class="line">                self.DFS(grid,newX,newY,mark)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 算例（和自己的手抄笔记匹配的）</span></span><br><span class="line"><span class="comment"># [[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]</span></span><br><span class="line"><span class="comment"># 输出 ：3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尝试简化一些写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        mark=[[<span class="number">0</span>]*<span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid))]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[i])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] ==<span class="string">&quot;1&quot;</span><span class="keyword">and</span> mark[i][j]==<span class="number">0</span>:</span><br><span class="line">                    self.DFS(grid,i,j,mark)</span><br><span class="line">                    count +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">self,grid,x,y,mark: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) :</span><br><span class="line">        mark[x][y]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> ((-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>)):</span><br><span class="line">            newX=dx + x</span><br><span class="line">            newY = dy + y</span><br><span class="line">            <span class="keyword">if</span> newX&lt; <span class="number">0</span> <span class="keyword">or</span> newX&gt;=<span class="built_in">len</span>(mark) <span class="keyword">or</span> newY &lt;<span class="number">0</span> <span class="keyword">or</span> newY &gt;=<span class="built_in">len</span>(mark[newX])</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> grid[newX][newY]==<span class="string">&quot;1&quot;</span> <span class="keyword">and</span> mark[newX][newY]==<span class="number">0</span>:</span><br><span class="line">                self.DFS(grid,newX,newY,mark)</span><br></pre></td></tr></table></figure>
5月1日再次回顾：也不知道这是自己写的第几遍的过程了，但是还是存在问题，这里将问题记录如下，不仅是算法思维要正确，同样的代码也要过关才行，否则就是一堆的bug：</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>问题一：边界出现问题。<img src="https://runnerxr.github.io/post-images/1651411102787.png">，dfs函数里面的x和y为矩阵的行坐标和列坐标（从0开始的），出界的条件是x&gt;&#x3D;行数，y&gt;&#x3D;列数</li>
<li>问题二，<img src="https://runnerxr.github.io/post-images/1651411240693.png">判断条件漏写，这里在最后的时候，满足搜索条件有两个，一个是当前访问的是陆地，另一个是当前这块陆地没有被标记。</li>
<li>问题三，这里不像其他的复杂的回溯问题，没有取消元素选择并弹出元素的过程。</li>
</ol>
<p><strong>甚至还可以采用并查集的思想来做题</strong>（主要是理解思路 ）<br>参考链接：<a target="_blank" rel="noopener" href="https://liweiwei1419.gitee.io/leetcode-algo/2017/10/26/leetcode-algo/0200-number-of-islands/">https://liweiwei1419.gitee.io/leetcode-algo/2017/10/26/leetcode-algo/0200-number-of-islands/</a><br><img src="https://runnerxr.github.io/post-images/1650609416171.png"><br>设计算法如下：</p>
<ol>
<li>如果是陆地，尝试与周围合并</li>
<li>如果是水域，把水域合并在一起<br>需要注意的点：</li>
<li>将二维数组与一维数组进行互换的过程需要熟悉（x*列数+y）</li>
<li>对水域也需要计数</li>
<li>最后的数量&#x3D;原数组数量-陆地连通后减少的数量-水域的数量（其实是有一点间接的感觉，不过也是主流的做法之一）</li>
<li>和DFS一样，也是需要做边界情况的判断</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后续代码自己整理</span></span><br><span class="line"><span class="comment"># 值得自己反复的做多遍，因为是python，所以有些代码相教Java是做了一些简化的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 边界条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m,n = <span class="built_in">len</span>(grid),<span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 水域的数量</span></span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 初始化并查集</span></span><br><span class="line">        <span class="comment"># 一行代码解决,注意数组的大小</span></span><br><span class="line">        p = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m*n)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 开始遍历，合并为1的节点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 如果存在陆地，调用_union函数,将所有的陆地进行合并</span></span><br><span class="line">                <span class="comment"># 需要把二维问题转化为一维问题</span></span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    <span class="comment"># self._union(p,i,j)，这是适用于一维的情况</span></span><br><span class="line">                    <span class="comment"># 合并上下左右为1的节点,改为一个共同的祖先</span></span><br><span class="line">                    directions = [(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>)]</span><br><span class="line">                    <span class="keyword">for</span> x,y <span class="keyword">in</span> directions:</span><br><span class="line">                        x= x + i</span><br><span class="line">                        y= y + j</span><br><span class="line">                        <span class="comment"># 对于新的行和列，如果行列都不越界，并且此时的标记也是为1的话，就进行合并祖先的操作。</span></span><br><span class="line">                        <span class="keyword">if</span> x &gt;=<span class="number">0</span> <span class="keyword">and</span> y &gt;=<span class="number">0</span> <span class="keyword">and</span> x &lt;m <span class="keyword">and</span> y &lt;n <span class="keyword">and</span> grid[x][y]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                            <span class="comment"># 经过union操作后，祖先都变为相同了，此时数组的值并没有改变，但是下一次遍历到数值虽然是1，祖先已经被同化了</span></span><br><span class="line">                            self._union(p,x*n+y,i*n+j)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 把水域的数量+1</span></span><br><span class="line">                    water +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 看n里面总共有几个parent</span></span><br><span class="line">        <span class="comment"># 这里取值的问题</span></span><br><span class="line">        <span class="comment"># return len(set([self._parent(p,i) for i in range(m*n)]))</span></span><br><span class="line">        res = [self._parent(p,i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m*n)]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">set</span>(res))-water</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># _union和_parent直接按模板抄上来</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_union</span>(<span class="params">self,p,i,j</span>):</span><br><span class="line">        p1 = self._parent(p,i)</span><br><span class="line">        p2 = self._parent(p,j)</span><br><span class="line">        p[p2]=p1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类似于find函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_parent</span>(<span class="params">self,p,i</span>):</span><br><span class="line">        root = i</span><br><span class="line">        <span class="comment"># 本质上也是一个递归操作</span></span><br><span class="line">        <span class="keyword">while</span> p[root] != root:</span><br><span class="line">            root = p[root]</span><br><span class="line">        <span class="comment"># 路径压缩</span></span><br><span class="line">        <span class="keyword">while</span> p[i] != i:</span><br><span class="line">            x ,i,p[x] = i,p[i],root</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>对python代码做一点修改，主要是为了和java以及主流的代码思路保持一致</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 边界条件:如果网格为空或者行数为0,直接返回空</span></span><br><span class="line">        <span class="keyword">if</span> grid <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(grid)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 统计水域的数量,初始化为0</span></span><br><span class="line">        waters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 为了方便调用函数,因为union  find和getCount都在uf类之下</span></span><br><span class="line">        uf = UnionFind(grid)</span><br><span class="line">        m,n=<span class="built_in">len</span>(grid),<span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 如果发现的是水域,就把水域数量+1</span></span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                    waters +=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果是陆地,就需要朝四个方向进行搜索</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 合并上下左右为1的节点,改为一个共同的祖先</span></span><br><span class="line">                    <span class="comment"># 合并上边节点(i-1,j)，注意不能出界</span></span><br><span class="line">                    directions = [(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>)]</span><br><span class="line">                    <span class="keyword">for</span> x,y <span class="keyword">in</span> directions:</span><br><span class="line">                        x= x + i</span><br><span class="line">                        y= y + j</span><br><span class="line">                        <span class="comment"># 对于新的行和列，如果行列都不越界，并且此时的标记也是为1的话，就进行合并祖先的操作。</span></span><br><span class="line">                        <span class="keyword">if</span> x &gt;=<span class="number">0</span> <span class="keyword">and</span> y &gt;=<span class="number">0</span> <span class="keyword">and</span> x &lt;m <span class="keyword">and</span> y &lt;n <span class="keyword">and</span> grid[x][y]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                            uf.union(x*n+y,i*n+j)</span><br><span class="line">        <span class="keyword">return</span> uf.getCount() - waters</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义UnionFind类,当作模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="comment"># 方法,类似于构造一个和网格类似的一维数组</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,grid</span>):</span><br><span class="line">        m,n=<span class="built_in">len</span>(grid),<span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 创建一个一维的root数组,长度与grid的长度相同</span></span><br><span class="line">        self.root= [-<span class="number">1</span>]*m*n</span><br><span class="line">        <span class="comment"># 一开始初始化为多少个元素</span></span><br><span class="line">        <span class="comment"># 最终应该减去水域的个数-联通之后的减少的个数</span></span><br><span class="line">        self.count = m*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m*n):</span><br><span class="line">            self.root[i]=i </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self,x</span>):</span><br><span class="line">        <span class="keyword">if</span> x ==self.root[x]:</span><br><span class="line">            <span class="keyword">return</span> self.root[x]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.root[x]=self.find(self.root[x])</span><br><span class="line">            <span class="keyword">return</span> self.root[x]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self,x,y</span>):</span><br><span class="line">        rootX = self.find(x)</span><br><span class="line">        rootY = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> rootX !=rootY:</span><br><span class="line">            self.root[rootX] = rootY</span><br><span class="line">            self.count -=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getCount</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br></pre></td></tr></table></figure>
<p>在上面的一个题解的基础上做进一步的优化（建议把上面的几种方式十分熟练之后再做相应的处理，还会让自己更上一步台阶）<br>优化的两个点：参考资料<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Q5411H7v5?p=2">https://www.bilibili.com/video/BV1Q5411H7v5?p=2</a></p>
<ol>
<li>优化包括quick find和quick  union,这里主要还是quick union,对树的高度进行了优化，权重的优化</li>
<li>对搜索的方向进行了优化（这个只是作为平时的解答，在面试的时候，还是按照常规思路来作答比较的好）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义UnionFind类,模板,但是也是做了一定的修改的.(根据题目的不同)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="comment"># 方法,类似于构造一个和网格类似的一维数组</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,grid</span>):</span><br><span class="line">        m,n=<span class="built_in">len</span>(grid),<span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 创建一个一维的root数组,长度与grid的长度相同</span></span><br><span class="line">        self.root= [-<span class="number">1</span>]*m*n</span><br><span class="line">        <span class="comment"># 定义了一个rank数组，记录每一组树的高度，初始化为0</span></span><br><span class="line">        self.rank = [<span class="number">0</span>]*m*n</span><br><span class="line">        <span class="comment"># 一开始初始化为0</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 以下的代码既构造一个序列号==祖先的数组,同时还记录了陆地的数量</span></span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    self.root[i*n+j]=i*n+j </span><br><span class="line">                    self.count+=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self,x</span>):</span><br><span class="line">        <span class="keyword">if</span> x ==self.root[x]:</span><br><span class="line">            <span class="keyword">return</span> self.root[x]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.root[x]=self.find(self.root[x])</span><br><span class="line">            <span class="keyword">return</span> self.root[x]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self,x,y</span>):</span><br><span class="line">        rootX = self.find(x)</span><br><span class="line">        rootY = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> rootX !=rootY:</span><br><span class="line">            <span class="comment"># 再加入一个判断,保证并查集不会退化为单链,树形结构尽量的矮一点,从而快速获得结点的根</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 比较两个树的树高,rootX的树高小于rootY的树高，把矮的树连接到高的树上面去</span></span><br><span class="line">            <span class="comment"># 即把rootX的根节点放到rootY</span></span><br><span class="line">            <span class="keyword">if</span> self.rank[rootX] &lt;self.rank[rootY]:</span><br><span class="line">                rootX,rootY=rootY,rootX</span><br><span class="line">            <span class="comment"># 否则：把rootY的根节点放到rootX(把 y连到x)</span></span><br><span class="line">            self.root[rootY] = rootX</span><br><span class="line">            <span class="comment"># 以上的三行代码是做了相应的优化的实际上是这四行代码</span></span><br><span class="line">            <span class="comment"># if self.rank[rootX] &lt;self.rank[rootY]:</span></span><br><span class="line">            <span class="comment">#      self.root[rootX] = rootY</span></span><br><span class="line">            <span class="comment"># elif self.rank[rootX] &lt;self.rank[rootY]:</span></span><br><span class="line">            <span class="comment">#     self.root[rootY] = rootX</span></span><br><span class="line">            <span class="keyword">elif</span> self.rank[rootX] ==self.rank[rootY]:</span><br><span class="line">                self.rank[rootX] +=<span class="number">1</span></span><br><span class="line">            self.count -=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getCount</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 边界条件:如果网格为空或者行数为0,直接返回空</span></span><br><span class="line">        <span class="keyword">if</span> grid <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(grid)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 为了方便调用函数,因为union  find和getCount都在uf类之下</span></span><br><span class="line">        uf = UnionFind(grid)</span><br><span class="line">        m,n=<span class="built_in">len</span>(grid),<span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 如果是陆地,就需要朝四个方向进行搜索</span></span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 合并上下左右为1的节点,改为一个共同的祖先</span></span><br><span class="line">                    <span class="comment"># 合并上边节点(i-1,j)，注意不能出界</span></span><br><span class="line">                    <span class="comment"># directions = [(-1,0),(1,0),(0,-1),(0,1)]</span></span><br><span class="line">                    <span class="comment"># 对于方向向量,可以只用右边和下边</span></span><br><span class="line">                    directions = [(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>)]</span><br><span class="line">                    <span class="keyword">for</span> x,y <span class="keyword">in</span> directions:</span><br><span class="line">                        x= x + i</span><br><span class="line">                        y= y + j</span><br><span class="line">                        <span class="comment"># 对于新的行和列，如果行列都不越界，并且此时的标记也是为1的话，就进行合并祖先的操作。</span></span><br><span class="line">                        <span class="keyword">if</span> x &gt;=<span class="number">0</span> <span class="keyword">and</span> y &gt;=<span class="number">0</span> <span class="keyword">and</span> x &lt;m <span class="keyword">and</span> y &lt;n <span class="keyword">and</span> grid[x][y]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                            uf.union(x*n+y,i*n+j)</span><br><span class="line">                    <span class="comment"># if i+1&lt;m and grid[i+1][j]==&#x27;1&#x27;:</span></span><br><span class="line">                    <span class="comment">#     uf.union((i+1)*n+j,i*n+j)</span></span><br><span class="line">                    <span class="comment"># if j+1&lt;n and grid[i][j+1]==&#x27;1&#x27;:</span></span><br><span class="line">                    <span class="comment">#     uf.union(i*n+j+1,i*n+j)</span></span><br><span class="line">        <span class="keyword">return</span> uf.getCount()</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h1><p>解题思路：<br>用空间换时间的操作<br>一旦发现是错的，就需要推到重来<br>还有浅拷贝和深拷贝的情况：值传递和引用传递的区别<br>运用数学公式去更新棋盘<br>回溯和递归的关系：用递归的代码来解决回溯的算法，需要把某些代码做一个重置、剪枝操作（一定要深入理解递归的算法）</p>
<ol>
<li>构建两个数组,一个数组是攻击数组:attack(是否可以放置皇后)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 待整理</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad78-子集-middle"><a href="#leetcoad78-子集-middle" class="headerlink" title="leetcoad78-子集(middle)"></a>leetcoad78-子集(middle)</h1><p><strong>非常重要-重点掌握，每一行代码都要清楚，并且还要清楚相应的调试过程，把DFS+剪枝的操作掌握得烂熟于心的程度（本题没有剪枝过程），由子集的解题步骤衍生出的7道题目的写法</strong><br>方法一：采用树形递归的方式（结合树形图理解相应的递归路线，本质是一种深度优先搜索DFS）<br><img src="https://runnerxr.github.io/post-images/1649694805789.png"><br>结合着张图以及后面自己在本地调式的过程，基本上是把这个过程给完完全全的整理清楚了。<br>方法二：采用循环的思路来解决（与方法一的区别：把子集加入结果数组的时机不一样，本质的思路是一样的）<br>方法三：采用广度优先搜索（BFS）,是一种分层搜索的方法，不是递归形式的，不需要回退<br>函数：</p>
<ol>
<li>每次调用这个函数，我们都会在当前数组中可用的区间中搜索出一个元素来，每找到一个元素就在原先的路径上添加的一个元素，此时你无论添加一个什么样的元素，当前都已经有一条完整的路径了，形成的一个路径就是一个子集，加入到我们的结果数组中</li>
<li>i肯定会超过数组，一旦超过数组的话，就结束相应的判断，否则的话：确定选了1之后，开始查看后面有多少种选择，利用三行代码把所有的子集添加进去：<ol>
<li>利用subset.add扩充新的元素进去，判断是否需要剪枝，去判断此时储存的数据是否之前已经被储存过</li>
<li>做出选择，递归调用该函数，进入下一层继续 （当前的这个搜索区间不再是从2开始的，从2的后面的元素开始的。）backtrack</li>
<li>撤销选择，回到上一层的状态：subset.remove</li>
</ol>
</li>
</ol>
<p>看视频做的一点记录：<br>对于每个元素都有两种选择方案：选或者不选，总共有2^n种<br>无法利用一次循环来把所有的元素都选出来：对于某个元素做出选或者不选的决定后，之前选择的元素与该元素共同组成一个新的组合，会漏掉一个不选的元素<br>把选1的策略全部走完<br>然后把选2的策略全部走完</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照吴师兄的思路一步步的调试清楚</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 结果集合</span></span><br><span class="line">        sets=[]</span><br><span class="line">        <span class="comment">#每次的子集</span></span><br><span class="line">        subset=[]</span><br><span class="line">        <span class="comment"># 执行回溯算法</span></span><br><span class="line">        self.backtrack(<span class="number">0</span>,nums,subset,sets)</span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> sets</span><br><span class="line">    <span class="comment"># i 表示递归时正在访问的数组元素下标</span></span><br><span class="line">    <span class="comment"># nums 表示当前集合中的元素</span></span><br><span class="line">    <span class="comment"># subset 表示每次递归后生成的子集，就是路径上的那些元素,类似于临时的子数组</span></span><br><span class="line">    <span class="comment"># sets 表示最终生成的所有子集合</span></span><br><span class="line">    <span class="comment"># 画出递归树，找到状态变量（回溯函数的参数）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self,i:<span class="built_in">int</span>,nums:<span class="type">List</span>[<span class="built_in">int</span>],subset:<span class="type">List</span>[<span class="built_in">int</span>],sets:<span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 每次确定好一个子集，都把它加入到结果集合中</span></span><br><span class="line">        sets.append(subset[:])</span><br><span class="line">        <span class="comment"># 此处在调试的时候加入一个打印，有助于了解相应的不断递归过程</span></span><br><span class="line">        <span class="comment"># print(&quot;  递归前subset =&gt; &quot; ,subset)</span></span><br><span class="line">        <span class="comment"># print(&quot;  递归前sets =&gt; &quot; ,sets)</span></span><br><span class="line">        <span class="comment"># 2、寻找结束条件，由于回溯算法是借助递归实现，所以也就是去寻找递归终止条件</span></span><br><span class="line">        <span class="comment"># 本题中可以不加这个判断，大家可以思考一下为什么可以不加，结合 for 循环的边界来思考</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 当访问的数组下标超过了nums数组的长度时，递归结束（这里的理解非常重要，只有递归结束了，才会有回溯的操作过程，这是一体的）</span></span><br><span class="line">        <span class="comment"># 此处也可以不加判断，理由，通过调试的过程中我们就会发现，当n=len(nums)的时候，此时不会进入到循环之中，直接跳到subset.pop(len(subset) - 1)这一行代码，类似于是递归的最后一次循环了。</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;=n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 3、确定选择列表，需要把什么数据存储到结果里面</span></span><br><span class="line">        <span class="comment"># for 循环就是一个选择的过程</span></span><br><span class="line">        <span class="comment"># 遍历本层集合中的元素</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">            <span class="comment"># 把本次递归访问的元素加入到 subset 数组中</span></span><br><span class="line">            subset.append(nums[j])</span><br><span class="line">            <span class="comment"># 4、判断是否需要剪枝，去判断此时存储的数据是否之前已经被存储过</span></span><br><span class="line">            <span class="comment"># 本题不需要剪枝</span></span><br><span class="line">            <span class="comment"># 5、做出选择，递归调用该函数，进入下一层继续搜索</span></span><br><span class="line">            <span class="comment"># 递归</span></span><br><span class="line">            <span class="comment"># 此时需要传入新的参数</span></span><br><span class="line">            self.backtrack( j+<span class="number">1</span>,nums , subset , sets)</span><br><span class="line">            <span class="comment"># 6、撤销选择，回到上一层的状态</span></span><br><span class="line">            <span class="comment"># 取消对 nums[i] 的选择（这里的取消选择的过程，自己也可以通过代码来进行调试，让自己更加熟悉这个过程：只有在递归到尽头的时候才会进行回溯的操作）</span></span><br><span class="line">            subset.pop(<span class="built_in">len</span>(subset) - <span class="number">1</span>)</span><br><span class="line">            <span class="comment">#print(&quot; 取消subset最后一个元素 =&gt; &quot; ,subset)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 输入一个特定的需要求解的数组</span></span><br><span class="line">    nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    res = Solution().subsets(nums)</span><br><span class="line">    <span class="comment">#print(res)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;  输出 =&gt; &quot;</span> ,res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果如下</span></span><br><span class="line"><span class="comment"># 一开始就选1时，从头递归到尾</span></span><br><span class="line"><span class="comment">#  递归前subset =&gt;  []</span></span><br><span class="line"><span class="comment">#   递归前sets =&gt;  [[]]</span></span><br><span class="line"><span class="comment">#   递归前subset =&gt;  [1]</span></span><br><span class="line"><span class="comment">#   递归前sets =&gt;  [[], [1]]</span></span><br><span class="line"><span class="comment">#   递归前subset =&gt;  [1, 2]</span></span><br><span class="line"><span class="comment">#   递归前sets =&gt;  [[], [1], [1, 2]]</span></span><br><span class="line"><span class="comment">#   递归前subset =&gt;  [1, 2, 3]</span></span><br><span class="line"><span class="comment">#   递归前sets =&gt;  [[], [1], [1, 2], [1, 2, 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一开始就选1时，从递归结束的地方开始回溯</span></span><br><span class="line"><span class="comment">#   取消subset最后一个元素 =&gt;  [1, 2]</span></span><br><span class="line"><span class="comment">#   取消subset最后一个元素 =&gt;  [1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 一开始就选1时，回退到选3不选2的过程</span></span><br><span class="line"><span class="comment">#   递归前subset =&gt;  [1, 3]</span></span><br><span class="line"><span class="comment">#   递归前sets =&gt;  [[], [1], [1, 2], [1, 2, 3], [1, 3]]</span></span><br><span class="line"><span class="comment">#   取消subset最后一个元素 =&gt;  [1]</span></span><br><span class="line"><span class="comment">#   取消subset最后一个元素 =&gt;  []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   回退到空，然后开始选2的过程</span></span><br><span class="line"><span class="comment">#   递归前subset =&gt;  [2]</span></span><br><span class="line"><span class="comment">#   递归前sets =&gt;  [[], [1], [1, 2], [1, 2, 3], [1, 3], [2]]</span></span><br><span class="line"><span class="comment">#   递归前subset =&gt;  [2, 3]</span></span><br><span class="line"><span class="comment">#   递归前sets =&gt;  [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选2的时候递归结束开始回溯的一个过程</span></span><br><span class="line"><span class="comment">#   取消subset最后一个元素 =&gt;  [2]</span></span><br><span class="line"><span class="comment">#   取消subset最后一个元素 =&gt;  []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   回退到空，然后开始选3的过程</span></span><br><span class="line"><span class="comment">#   递归前subset =&gt;  [3]</span></span><br><span class="line"><span class="comment">#   递归前sets =&gt;  [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   回退到空，然后开始选3的下一个元素的过程（发现此时已经无元素可以选择了）</span></span><br><span class="line"><span class="comment">#   取消subset最后一个元素 =&gt;  []</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终对sets进行输出</span></span><br><span class="line"><span class="comment">#   输出 =&gt;  [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己对代码做一点简化，比如我把函数写在了subsets里面，就不需要再另外的去定义sets和subset变量。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        sets=[]</span><br><span class="line">        subset=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">i:<span class="built_in">int</span>,nums</span>):</span><br><span class="line">            sets.append(subset[:])</span><br><span class="line">            <span class="comment"># print(&quot; subset =&gt; &quot; ,subset)</span></span><br><span class="line">            <span class="comment"># print(&quot; sets =&gt; &quot; ,sets)</span></span><br><span class="line">            n = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="keyword">if</span> i &gt;=n:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                subset.append(nums[j])</span><br><span class="line">                backtrack( j+<span class="number">1</span>,nums )</span><br><span class="line">                <span class="comment"># 弹出subset中的最后一个元素</span></span><br><span class="line">                subset.pop()</span><br><span class="line">                <span class="comment"># print(&quot; 取消subset最后一个元素的选择 =&gt; &quot; ,subset)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用回溯算法</span></span><br><span class="line">        backtrack(<span class="number">0</span>,nums)</span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> sets</span><br></pre></td></tr></table></figure>
<p><strong>迭代法</strong>（待整理）<br>参考链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/">https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = [[]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            res = res + [[i] + num <span class="keyword">for</span> num <span class="keyword">in</span> res]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="leetcoad90-子集II-middle"><a href="#leetcoad90-子集II-middle" class="headerlink" title="leetcoad90-子集II(middle)"></a>leetcoad90-子集II(middle)</h1><p><img src="https://runnerxr.github.io/post-images/1652361154485.png"><br>相比于子集，加入了一个剪枝的操作：判断当前的元素是否和之前的元素相同，如果相同就不去执行后面的代码。（后面的代码是将当前元素作为一种选择情况下的那一个子集加入到相应的结果数组中，当前的情况已经在之前分析过了，不需要再执行了,子集那道题已经限制了给定的值是互不相同的）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 并加入头文件进行调试，选用的例子是nums=[1,2,2],如果选用[1,2,3],得到的结果和子集I是一样的结果</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 对原数组排序，这样才能对比当前元素和之前的元素是否相同</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        sets=[]</span><br><span class="line">        subset=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">i:<span class="built_in">int</span>,nums</span>):</span><br><span class="line">            sets.append(subset[:])</span><br><span class="line">            n = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="keyword">if</span> i &gt;=n:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                <span class="comment"># 剪枝</span></span><br><span class="line">                <span class="keyword">if</span> j &gt;i <span class="keyword">and</span> nums[j-<span class="number">1</span>]==nums[j]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                subset.append(nums[j])</span><br><span class="line"></span><br><span class="line">                backtrack( j+<span class="number">1</span>,nums )</span><br><span class="line">                <span class="comment"># 弹出subset中的最后一个元素</span></span><br><span class="line">                subset.pop()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用回溯算法</span></span><br><span class="line">        backtrack(<span class="number">0</span>,nums)</span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> sets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 输入一个特定的需要求解的数组</span></span><br><span class="line">    nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">    res = Solution().subsetsWithDup(nums)</span><br><span class="line">    <span class="comment">#print(res)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;  输出 =&gt; &quot;</span> ,res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果如下：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一开始就选1时，从头递归到尾</span></span><br><span class="line"><span class="comment"># subset =&gt;  []</span></span><br><span class="line"><span class="comment">#  sets =&gt;  [[]]</span></span><br><span class="line"><span class="comment">#  subset =&gt;  [1]</span></span><br><span class="line"><span class="comment">#  sets =&gt;  [[], [1]]</span></span><br><span class="line"><span class="comment">#  subset =&gt;  [1, 2]</span></span><br><span class="line"><span class="comment">#  sets =&gt;  [[], [1], [1, 2]]</span></span><br><span class="line"><span class="comment">#  subset =&gt;  [1, 2, 2]</span></span><br><span class="line"><span class="comment">#  sets =&gt;  [[], [1], [1, 2], [1, 2, 2]]  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一开始就选1时，从递归结束的地方开始回溯，由于后面还有一个2，与上一次选择相同，不会再选择，直接回溯到空</span></span><br><span class="line"><span class="comment">#  取消subset最后一个元素的选择 =&gt;  [1, 2]</span></span><br><span class="line"><span class="comment">#  取消subset最后一个元素的选择 =&gt;  [1]   </span></span><br><span class="line"><span class="comment">#  取消subset最后一个元素的选择 =&gt;  []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   回退到空，然后开始选2的过程</span></span><br><span class="line"><span class="comment">#  subset =&gt;  [2]</span></span><br><span class="line"><span class="comment">#  sets =&gt;  [[], [1], [1, 2], [1, 2, 2], [2]]</span></span><br><span class="line"><span class="comment">#  subset =&gt;  [2, 2]</span></span><br><span class="line"><span class="comment">#  sets =&gt;  [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]</span></span><br><span class="line"><span class="comment">#  取消subset最后一个元素的选择 =&gt;  [2]</span></span><br><span class="line"><span class="comment">#  取消subset最后一个元素的选择 =&gt;  []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   回退到空，然后开始选2的下一个元素的过程（发现此时已经无元素可以选择了）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   输出 =&gt;  [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]</span></span><br></pre></td></tr></table></figure>
<h1 id="leetcoad77-组合-middle"><a href="#leetcoad77-组合-middle" class="headerlink" title="leetcoad77-组合(middle)"></a>leetcoad77-组合(middle)</h1><p>题目描述：给定两个整数 n 和 k，返回范围 [1, n] 中<strong>所有可能的 k 个数的组合</strong>。<br>你可以按 任何顺序 返回答案。<br>输入：n &#x3D; 4, k &#x3D; 2<br>输出：<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]<br>做题链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/">https://leetcode-cn.com/problems/combinations/</a><br><img src="https://runnerxr.github.io/post-images/1652362914174.png"><br><img src="https://runnerxr.github.io/post-images/1652363742876.png"><br>做题思路：<br>这里用4个元素中找出3个数的组合来解题</p>
<ol>
<li>理解题目的意思：当前总共有三个坑，如何<strong>从四个元素中去寻找三个元素</strong>去填满这些坑，可以将数组中的每一个元素作为三个坑的第一个元素，然后在剩下的三个元素中去寻找两个元素出来，将剩下的这两个坑填满。然后在填了两个坑的基础上，查看后面的以后个坑如何选择</li>
<li>实现地具体过程以及相应地注意点：<ol>
<li>递归地终止条件变了：需要填入地数为0</li>
<li>确定选择列表地时候也变了，选择地终止索引为后面地数刚好能凑齐k个数截至（想要保证数不重复，又要把元素填满）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">暂时没有代码，待补充</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="leetcoad39-组合总和-middle"><a href="#leetcoad39-组合总和-middle" class="headerlink" title="leetcoad39-组合总和(middle)"></a>leetcoad39-组合总和(middle)</h1><p>题目描述：<br>给你一个 <strong>无重复元素</strong> 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。<br>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。<br>理解题目的意思之后再谈做题的方法：</p>
<ol>
<li>仍然可以用回溯的算法思想</li>
<li>第一次是可以选择任意元素，在第一次选择的基础上，剩下的就是要凑出target-nums[i]的和，然后继续进行下一轮的选择，<strong>在选数的时候不能选比当前需要值大的数</strong>。<br>以下结合这几张图来辅助理解这里的过程<br><img src="https://runnerxr.github.io/post-images/1652364640585.png"></li>
<li>罗列所有选择并排除不合适的选择，这样就选出了[2,2,3] [2,3,2] [3,2,2] [7],但是这和题目的意思是不符合的，组合的话是不用管顺序的<br><img src="https://runnerxr.github.io/post-images/1652364808224.png"></li>
<li>紧接着就思考，如何进行剪枝的问题？对于想要凑齐5的情况，由于第一次已经选了2 2 3，当下一次选到2 3的时候就会发现之前是舍弃了2没有选的，那么在接下的选择中就也不能选择2，只能从3开始选择，同理在凑齐4的过程中，由于前面是选择了3的，所以后面就不能再选比3小的数，也就只能从3开始选，也就有了下面的这张图的理解过程<br><img src="https://runnerxr.github.io/post-images/1652364824518.png"></li>
<li>再紧接着就思考递归结束的条件： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. target&lt;0</span><br><span class="line">2. target==0</span><br></pre></td></tr></table></figure>
4.再接着就是确定选择列表，需要将什么样的数加入进去，精髓就在于递归的时候传入的数据：backtrack(nums,target-nums[i],path,newposition)<br>5.初调用函数的时候表示：从第0个元素开始选择，要筹齐的目标数为原始目标数，然后随着不断地递归,target不断地减小，最后达到递归地出口地位置。
        
          <p class="article-more-link">
            <a href="/2022/03/21/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B8%80/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/21/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B8%80/" data-id="claqu8zzv002miwtk0jfz009h" data-title="搜索算法、回溯算法系列一" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-二分查找-位运算" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E4%BD%8D%E8%BF%90%E7%AE%97/" class="article-date">
  <time class="dt-published" datetime="2022-03-21T01:49:23.000Z" itemprop="datePublished">2022-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E4%BD%8D%E8%BF%90%E7%AE%97/">二分查找-位运算</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>二分查找也即折半查找：只能用于数组是有序的，不论是递增还是递减<br>针对二分查找，也整理相应的模板和框架出来，帮助自己来理解题目的意思</p>
<h1 id="二分查找框架"><a href="#二分查找框架" class="headerlink" title="二分查找框架"></a>二分查找框架</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在写框架的时候，不要用else语句，尽量把每个条件的细节都展示清楚</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binarySearch</span>(<span class="params">nms,target</span>):</span><br><span class="line">    left,right=<span class="number">0</span>,...</span><br><span class="line">    <span class="keyword">while</span> (...):</span><br><span class="line">        mid = left +(left+right)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid]==target:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">elif</span> nums[mid]&lt;target:</span><br><span class="line">            left=...</span><br><span class="line">        <span class="keyword">elif</span> nums[mid]&gt;target:</span><br><span class="line">            right=...</span><br></pre></td></tr></table></figure>
<h2 id="常规的二分搜索的框架："><a href="#常规的二分搜索的框架：" class="headerlink" title="常规的二分搜索的框架："></a>常规的二分搜索的框架：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果能够找到，返回相应的值，如果不能找到返回-1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binarySearch</span>(<span class="params">nums,target</span>):</span><br><span class="line">    left,right=<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right):</span><br><span class="line">        mid = left +(left+right)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid]==target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid]&lt;target:</span><br><span class="line">            left=mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid]&gt;target:</span><br><span class="line">            right=mid-<span class="number">1</span></span><br><span class="line">    <span class="comment"># 循环结束的时候：left=right+1，最后形成的区间是：[right+1,right]</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="寻找左侧边界的二分搜索"><a href="#寻找左侧边界的二分搜索" class="headerlink" title="寻找左侧边界的二分搜索"></a>寻找左侧边界的二分搜索</h2><p>具体的用途：<br>nums&#x3D;[1,2,2,2,3] target&#x3D;2  :最终返回-1  表明nums中小于2的数只有一个<br>nums&#x3D;[2,3,5,7] target&#x3D;8，最终返回4，表明nums中小于8的数有4个<br>也即返回的是在[0,len(nums]中left的变量值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">left_bound</span>(<span class="params">nums,target</span>):</span><br><span class="line">    <span class="comment"># right指针的值也是变了的</span></span><br><span class="line">    left,right=<span class="number">0</span>,<span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 此时的循环终止条件变了</span></span><br><span class="line">    <span class="keyword">while</span> (left&lt;right):</span><br><span class="line">        mid = left +(right-left)//<span class="number">2</span></span><br><span class="line">        <span class="comment"># 目的是想把区间分成两部分：[left,mid)  和[mid+1,right)</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid]==target:</span><br><span class="line">            <span class="comment"># 不立即返回，而是缩小区间的上界right，使区间不断地向左收缩，达到锁定左侧边界地目的</span></span><br><span class="line">            right=mid  </span><br><span class="line">        <span class="keyword">elif</span> nums[mid]&lt;target:</span><br><span class="line">            left=mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid]&gt;target:</span><br><span class="line">            <span class="comment"># 之所以这样写，是由我们的循环条件决定的</span></span><br><span class="line">            right=mid</span><br><span class="line">    <span class="comment"># 循环结束的时候：left=right，最后形成的区间是：[right,right），因为该区间是左闭右开的，所以不会有索引的问题</span></span><br><span class="line">    <span class="keyword">return</span>  left</span><br><span class="line">    <span class="comment"># 如果想要知道如果没有符合条件的数返回-1，可以加入以下的两行代码</span></span><br><span class="line">    <span class="comment"># 当left走到len(nums)，必然会索引越界</span></span><br><span class="line">    <span class="comment"># if left==len(nums):</span></span><br><span class="line">    <span class="comment">#     return -1</span></span><br><span class="line">    <span class="comment"># return left if nums[left]==target else -1 </span></span><br><span class="line">nums=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">target=<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(left_bound(nums,target))</span><br></pre></td></tr></table></figure>
<h2 id="寻找右侧边界的二分搜索"><a href="#寻找右侧边界的二分搜索" class="headerlink" title="寻找右侧边界的二分搜索"></a>寻找右侧边界的二分搜索</h2><p>关键代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nums[mid]==target:</span><br><span class="line">            left=mid+<span class="number">1</span> </span><br></pre></td></tr></table></figure>
<p> 以下为完整的代码的实现，进行比较分析写出来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">right_bound</span>(<span class="params">nums,target</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">0</span>:<span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># right指针的值也是变了的</span></span><br><span class="line">    left,right=<span class="number">0</span>,<span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 此时的循环终止条件变了</span></span><br><span class="line">    <span class="keyword">while</span> (left&lt;right):</span><br><span class="line">        mid = left +(right-left)//<span class="number">2</span></span><br><span class="line">        <span class="comment"># 目的是想把区间分成两部分：[left,mid)  和[mid+1,right)</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid]==target:</span><br><span class="line">            <span class="comment">#  不立即返回，而是增大区间的下界left，使得区间不断地向右收缩，达到锁定右侧边界地目的</span></span><br><span class="line">            left=mid+<span class="number">1</span>  </span><br><span class="line">        <span class="keyword">elif</span> nums[mid]&lt;target:</span><br><span class="line">            left=mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid]&gt;target:</span><br><span class="line">            <span class="comment"># 之所以这样写，是由我们的循环条件决定的</span></span><br><span class="line">            right=mid</span><br><span class="line">    <span class="comment"># 循环结束的时候：left=right，最后形成的区间是：[right,right），因为该区间是左闭右开的，所以不会有索引的问题</span></span><br><span class="line">    <span class="keyword">return</span>  left-<span class="number">1</span></span><br><span class="line">    <span class="comment"># 如果想要知道如果没有符合条件的数返回-1，可以加入以下的代码</span></span><br><span class="line">    <span class="comment"># if left==0:return -1</span></span><br><span class="line">    <span class="comment"># return left if nums[left-1]==target else -1 </span></span><br><span class="line"></span><br><span class="line">nums=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">target=<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(right_bound(nums,target))</span><br></pre></td></tr></table></figure>
<p>经过上面的一系列总结之后，做最后的一个归纳：</p>
<ol>
<li>分析代码的时候，不要出现else,全部展开为elif ，方便理解</li>
<li>注意搜索区间和while的终止条件，<strong>搞清楚搜索区间的开闭情况</strong>，left与right的更新完全取决于搜索区间，如果存在漏掉的元素记得最后检查</li>
<li>需要定义左闭右开的搜索区间来搜索左 右边界的时候，只要在nums[mid]&#x3D;&#x3D;target的时候做相应的修改就行，搜索右侧边界的时候后面返回的时候需要-1</li>
</ol>
<h1 id="二分查找相关例题总结："><a href="#二分查找相关例题总结：" class="headerlink" title="二分查找相关例题总结："></a>二分查找相关例题总结：</h1><h1 id="leetcoad704-二分查找（半折查找）（easy）"><a href="#leetcoad704-二分查找（半折查找）（easy）" class="headerlink" title="leetcoad704-二分查找（半折查找）（easy）"></a>leetcoad704-二分查找（半折查找）（easy）</h1><p>leetcoad链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search/">https://leetcode-cn.com/problems/binary-search/</a><br>视频链接：<a target="_blank" rel="noopener" href="https://www.algomooc.com/1362.html">https://www.algomooc.com/1362.html</a><br>迭代写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">      <span class="comment">#在左闭右闭的区间里去查找目标值  </span></span><br><span class="line">      <span class="comment">#left为当前区间最左侧的元素，可以获取到</span></span><br><span class="line">      left = <span class="number">0</span></span><br><span class="line">      <span class="comment">#right为当前区间最右侧的元素，可以获取到</span></span><br><span class="line">      n = <span class="built_in">len</span>(nums)</span><br><span class="line">      right = n -<span class="number">1</span></span><br><span class="line">      <span class="comment">#在while循环里面，left和right不断的向中间移动</span></span><br><span class="line">      <span class="comment">#当[left,right]区间中不存在元素的时候，跳出相应的循环（left &gt; right的时候跳出相应的循环）</span></span><br><span class="line">      <span class="comment">#left = right +1之后，搜索区间就不再有元素了</span></span><br><span class="line">      <span class="comment">#left和right相遇的时候指向同一个元素，元素存在于这个区间之中，这个区间就一个元素</span></span><br><span class="line">      <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">          mid = left + (right - left)//<span class="number">2</span></span><br><span class="line">          <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">              <span class="keyword">return</span> mid</span><br><span class="line">          <span class="comment">#中间的那个元素都是大于目标值的，需要将右区间缩小</span></span><br><span class="line">          <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">              right = mid -<span class="number">1</span></span><br><span class="line">          <span class="comment">#中间的那个元素都是小于目标值的，需要将左区间缩小</span></span><br><span class="line">          <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">              left = mid + <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p> 递归写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#但是存在一个问题：此处的写法中nums[]会导致原来的nums被破会，虽然能够找到相应的值，但是对应的下标已经不是最初始的下标了，已经有了变动，所以此时输出的下标（如果要输出的话）并不是原链表中相应的下标。（nums的范围缩小了，对应的新的下标也变小了）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">nums,target</span>):</span><br><span class="line">    n=<span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">#递归出口</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    mid=n//<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> nums[mid] &lt; target: <span class="comment">#右边列表查找</span></span><br><span class="line">        <span class="keyword">return</span> binary_search(nums[mid+<span class="number">1</span>:],target)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">return</span>  binary_search(nums[<span class="number">0</span>:mid],target)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">    <span class="built_in">print</span>(binary_search(nums,<span class="number">9</span>))</span><br><span class="line">    <span class="built_in">print</span>(binary_search(nums,<span class="number">19</span>))</span><br><span class="line">````</span><br><span class="line"><span class="comment"># leetcoad35-搜索插入值位置(easy)</span></span><br><span class="line">leetcoad链接：&lt;https://leetcode-cn.com/problems/search-insert-position/&gt;</span><br><span class="line">视频链接：&lt;https://www.algomooc.com/<span class="number">1364.</span>html&gt;</span><br><span class="line">时间复杂度：O(logn)</span><br><span class="line">空间复杂度：O(<span class="number">1</span>),只需要常数空间存放若干变量</span><br><span class="line">重要思路如下：完成最后一次循环后插入数据的问题</span><br><span class="line"><span class="number">1.</span> 如果nums[mid] &gt; target，right会向左移动,此时right = left -<span class="number">1</span>，后面所有的元素都想后移动，left的位置就是需要插入的位置</span><br><span class="line"><span class="number">2.</span> 如果nums[mid] &lt; target，left会向左移动,此时left = right +<span class="number">1</span>，left向后移动一位，原来的left位置就是需要插入的位置</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#在左闭右闭的区间里去查找目标值  </span></span><br><span class="line">        <span class="comment">#left为当前区间最左侧的元素，可以获取到</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="comment">#right为当前区间最右侧的元素，可以获取到</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        right = n -<span class="number">1</span></span><br><span class="line">        <span class="comment">#在while循环里面，left和right不断的向中间移动</span></span><br><span class="line">        <span class="comment">#当[left,right]区间中不存在元素的时候，跳出相应的循环（left &gt; right的时候跳出相应的循环）</span></span><br><span class="line">        <span class="comment">#left = right +1之后，搜索区间就不再有元素了</span></span><br><span class="line">        <span class="comment">#left和right相遇的时候指向同一个元素，元素存在于这个区间之中，这个区间就一个元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">            mid = left + (right - left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="comment">#中间的那个元素都是大于目标值的，需要将右区间缩小</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid -<span class="number">1</span></span><br><span class="line">            <span class="comment">#中间的那个元素都是小于目标值的，需要将左区间缩小</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment">#while执行完最后一次循环后，left = right,此时的mid = left = right</span></span><br><span class="line">        <span class="comment">#nums[mid]左边的数全部小于目标值target,nums[mid]右边的数全部大于目标值target</span></span><br><span class="line">        <span class="comment">#1.如果nums[mid] &gt; target，right会向左移动,此时right = left -1</span></span><br><span class="line">        <span class="comment">#此时target应该插入到nums[mid]的前一个位置，顶替nums[mid],nums[mid]后面的元素都向后移动，</span></span><br><span class="line">        <span class="comment">#left指向的就是nums[mid]这个元素，left就是插入的位置</span></span><br><span class="line">        <span class="comment">#2.如果nums[mid] &lt; target，left会向左移动,此时left = right +1</span></span><br><span class="line">        <span class="comment">#此时target应该插入到nums[mid]的后一个位置，left向后移动了一次，这个位置就是插入的位置</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">````</span><br><span class="line"><span class="comment"># leetcoad34-在排序数组中查找元素的第一个和最后一个位置(middle)</span></span><br><span class="line">leetcoad链接：&lt;https://leetcode-cn.com/problems/find-first-<span class="keyword">and</span>-last-position-of-element-<span class="keyword">in</span>-<span class="built_in">sorted</span>-array/&gt;</span><br><span class="line">视频链接：&lt;https://www.algomooc.com/<span class="number">1000.</span>html&gt;</span><br><span class="line">重要思路如下：</span><br><span class="line"><span class="number">1.</span> 第一次查找开始的位置</span><br><span class="line">    - nums[mid] == target</span><br><span class="line">        - mid ==<span class="number">0</span> <span class="keyword">or</span> nums[mid -<span class="number">1</span>]&lt; target那么此时的中间值就是第一个元素</span><br><span class="line">（此处的判断条件是有两个的）</span><br><span class="line">        - 否则就需要在左边继续缩小范围之后再查找</span><br><span class="line">    - nums[mid] &gt; target</span><br><span class="line">    - nums[mid] &lt; target</span><br><span class="line"><span class="number">2.</span> 第二此查找结束的位置:同查找开始位置相同的思路</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment">#寻找目标值在数组中的开始位置</span></span><br><span class="line">        firstIdx = findBegininPosition(nums,target)</span><br><span class="line">        <span class="comment">#寻找目标值在数组中的结束位置</span></span><br><span class="line">        lastIdx = findEndinPosition(nums,target)</span><br><span class="line">        <span class="comment">#返回寻找到的结果</span></span><br><span class="line">        result = [firstIdx,lastIdx]</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment">#寻找目标值在数组中的开始位置   </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findBegininPosition</span>(<span class="params">nums, target</span>):</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    right = n -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#在while循环里面，left和right不断的向中间移动</span></span><br><span class="line">    <span class="comment">#当[left,right]区间中不存在元素的时候，跳出相应的循环（left &gt; right的时候跳出相应的循环）</span></span><br><span class="line">    <span class="comment">#left = right +1之后，搜索区间就不再有元素了</span></span><br><span class="line">    <span class="comment">#left和right相遇的时候指向同一个元素，元素存在于这个区间之中，这个区间就一个元素</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = left + (right - left)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="comment">#如果中间位置mid的左边没有元素（mid为当前区间的起始位置），或者mid的前一个元素小于target，则说明mid就为元素的第一个位置</span></span><br><span class="line">            <span class="keyword">if</span> mid ==<span class="number">0</span> <span class="keyword">or</span> nums[mid -<span class="number">1</span>]&lt; target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="comment">#否则说明mid的左边依然有元素值等于target，mid值就不是target的起始位置，需要在mid左边进行查找</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid -<span class="number">1</span></span><br><span class="line">        <span class="comment">#如果中间的那个元素都是大于目标值的，需要将右区间缩小</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid -<span class="number">1</span></span><br><span class="line">        <span class="comment">#中间的那个元素都是小于目标值的，需要将左区间缩小</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#寻找目标值在数组中的结束位置   </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findEndinPosition</span>(<span class="params">nums, target</span>):</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    right = n -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#在while循环里面，left和right不断的向中间移动</span></span><br><span class="line">    <span class="comment">#当[left,right]区间中不存在元素的时候，跳出相应的循环（left &gt; right的时候跳出相应的循环）</span></span><br><span class="line">    <span class="comment">#left = right +1之后，搜索区间就不再有元素了</span></span><br><span class="line">    <span class="comment">#left和right相遇的时候指向同一个元素，元素存在于这个区间之中，这个区间就一个元素</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = left + (right - left)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="comment">#如果中间位置mid的右边没有元素（mid为当前区间的结束位置），或者mid的后面一个元素大于target，则说明mid就为元素的结束位置</span></span><br><span class="line">            <span class="keyword">if</span> mid ==n-<span class="number">1</span> <span class="keyword">or</span> nums[mid +<span class="number">1</span>]&gt; target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="comment">#否则说明mid的右边依然有元素值等于target，mid值就不是target的起始位置，需要在mid右边进行查找</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid +<span class="number">1</span></span><br><span class="line">        <span class="comment">#如果中间的那个元素都是大于目标值的，需要将右区间缩小</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid -<span class="number">1</span></span><br><span class="line">        <span class="comment">#中间的那个元素都是小于目标值的，需要将左区间缩小</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="leetcoad33-搜索旋转排序数组-middle"><a href="#leetcoad33-搜索旋转排序数组-middle" class="headerlink" title="leetcoad33-搜索旋转排序数组(middle)"></a>leetcoad33-搜索旋转排序数组(middle)</h1><p>leetcoad链接<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">https://leetcode-cn.com/problems/search-in-rotated-sorted-array/</a><br>视频链接：<a target="_blank" rel="noopener" href="https://www.algomooc.com/998.html">https://www.algomooc.com/998.html</a><br>重要思路如下：</p>
<ol>
<li>确定好mid的左边还是右边是有序区间（只要是有序区间就可以通过二分查法来搜索target）</li>
<li>确定target是否是在有序区间<ul>
<li>是的话就直接用二分查找法</li>
<li>不是的话就不断的缩小区间到相应的有序区间去查找<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#在左闭右闭的区间里去查找目标值  </span></span><br><span class="line">        <span class="comment">#left为当前区间最左侧的元素，可以获取到</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="comment">#right为当前区间最右侧的元素，可以获取到</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        right = n -<span class="number">1</span></span><br><span class="line">        <span class="comment">#在while循环里面，left和right不断的向中间移动</span></span><br><span class="line">        <span class="comment">#当[left,right]区间中不存在元素的时候，跳出相应的循环（left &gt; right的时候跳出相应的循环）</span></span><br><span class="line">        <span class="comment">#left = right +1之后，搜索区间就不再有元素了</span></span><br><span class="line">        <span class="comment">#left和right相遇的时候指向同一个元素，元素存在于这个区间之中，这个区间就一个元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">            mid = left + (right - left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="comment">#否则需要先确定mid的左边还是右边是有序区间</span></span><br><span class="line">            <span class="comment">#如果当前区间nums[left] &lt; nums[mid],说明从left到mid是有序的，右侧是无序的区间</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= nums[mid]:</span><br><span class="line">                <span class="comment">#先判断target是否在左侧的有序区间内</span></span><br><span class="line">                <span class="comment">#如果target大于nums[left]，小于nums[mid]，说明target需要在有序区间去查找</span></span><br><span class="line">                <span class="keyword">if</span> nums[left]&lt;= target <span class="keyword">and</span> target &lt;=nums[mid]:</span><br><span class="line">                    right = mid -<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid]&lt;= target <span class="keyword">and</span> target &lt;=nums[right]:</span><br><span class="line">                    left = mid +<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">````</span><br><span class="line"><span class="comment"># leetcoad74-搜索二维矩阵(middle)</span></span><br><span class="line">隐含的意思：该二维数组从上到下和从左到右都是一个递增的过程，在解题的时候没有用到第i行最后一个数小于第i+<span class="number">1</span>行的第一个数的信息（运用如下的方法好像用不到这样的一个信息）</span><br><span class="line"><span class="number">1.</span> 从数组的左下角开始去搜索这个二维数组</span><br><span class="line"><span class="number">2.</span> 当发现当前遍历的元素大于target时，意味着这个元素后面的所有元素也都大于target，就不用去搜索这一行</span><br><span class="line"><span class="number">3.</span> 当发现当前遍历的元素小于target时，意味着这个元素上面的所有元素也都小于target,不用再去搜索这样的一个列</span><br><span class="line"><span class="number">4.</span> 按照如下的思路解题的时候，要注意<span class="keyword">while</span>循环的一个边界条件，因为是从走下角开始循环遍历的，这里是非常重要的</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 从数组的最左下角位置开始去搜索整个二维数组</span></span><br><span class="line">        <span class="comment"># 1、当发现当前遍历的元素大于 target 时，意味着这个元素后面的所有元素也都大于 target</span></span><br><span class="line">        <span class="comment"># 那么就不用去搜索这一行了</span></span><br><span class="line">        <span class="comment"># 2、当发现当前遍历的元素小于 target 时，意味着这个元素上面的所有元素也都小于 target</span></span><br><span class="line">        <span class="comment"># 那么就不用去搜索这一列了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化 i 和 j 为数组左下角元素</span></span><br><span class="line">        <span class="comment"># 最后一行</span></span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        i = m -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 第 0 列</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 从数组的左下角开始出发，只要 i 和 j 没有越界继续判断（循环条件的判断）</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;=<span class="number">0</span> <span class="keyword">and</span> j &lt;=n-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 当发现当前遍历的元素大于 target 时，意味着这个元素后面的所有元素也都大于 target</span></span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] &gt; target:</span><br><span class="line">                <span class="comment"># 行索引向上移动一格（即 i-- ），即消去矩阵第 i 行元素</span></span><br><span class="line">                i -=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 当发现当前遍历的元素小于 target 时，意味着这个元素上面的所有元素也都小于 target</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] &lt; target:</span><br><span class="line">                <span class="comment">#列索引向右移动一格（即 j++ ），即消去矩阵第 j 列元素</span></span><br><span class="line">                j +=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 否则，说明找到目标值</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 直接返回 ture</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 遍历了整个二维数组，没有找到目标值，返回 False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<strong>leetcoad4-寻找两个正序数组的中位数</strong>(middle)<br>利用多个技巧，</li>
</ul>
</li>
<li>一个长度很长，一个长度更短，始终保持m是长的那个数组，n是短的那个数组</li>
<li>将两个数组都扩充一下，长度之和，有可能为奇数也有可能为偶数，对于偶数是中间两个数的平均值。隐性的在数字的前面和后面都加上一个#号（是人为的进行的一个设想的），两者之后后是2的倍数，也就是偶数个，中位数就是中间两个数的平均值，不用进行分类讨论和判断</li>
<li>扩充前和扩充后有一个对应的关系：原先的&#x3D;（现在-1）&#x2F;2</li>
<li>寻找中间那个数的一个特征、</li>
<li>与其在合并后切割，不如在合并前就进行相应的切割</li>
<li>如果刚好左边元素的最大值&lt;右边元素最小值，整个左边区间元素&lt;整个右边区间的元素</li>
<li>基于上面砍刀的位置决定下面的砍刀的位置，这也就是为什么需要将上面的数组长度置为比下一个大的原因<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">后面再整理（leetcoad上已经提交过了）</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad611-有效三角形个数-middle"><a href="#leetcoad611-有效三角形个数-middle" class="headerlink" title="leetcoad611-有效三角形个数(middle)"></a>leetcoad611-有效三角形个数(middle)</h1><p>根据吴师兄的思路也大致的整理一下(排序+二查找)</p>
<ol>
<li>先对所有的数进行一个排序的操作：只需要保障 a + b &gt; c这个条件就可以了</li>
<li>通过两个循环来定位三角形中的两条边（😎：这里也是一个关键点：固定两短的两条边）</li>
<li>注意两个循环的一个范围：和冒泡排序循环的范围有点类似</li>
<li>用到了二分查找的思路，在[j+1,n-1]不断的去缩小相应的区间去判断中间的元素是否是小于所选的两个数之和（也即用二分查找的思路去寻找最长的边的问题）</li>
<li>用到了统计所有符合条件数计数</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triangleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#先将数组进行排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="comment">#获取数组的长度</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment">#统计可以组成三角形三条边的三元组个数，一开始为0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#通过两个循环来定位三角形的两边</span></span><br><span class="line">        <span class="comment">#nums[i]为三条边中最短的，i的取值范围为：[0,n-3]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n-<span class="number">2</span>):</span><br><span class="line">            <span class="comment">#其中nums[j]为三边中较短的边，j的取值范围[i+1,n-2]</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n-<span class="number">1</span>):</span><br><span class="line">                <span class="comment">#判断三条边组成三角形的条件，a+b &gt;c</span></span><br><span class="line">                <span class="comment">#nums[i]和nums[j]分别为a 和 b,计算出a和b的和</span></span><br><span class="line">                a = nums[i]</span><br><span class="line">                b = nums[j]</span><br><span class="line">                <span class="built_in">sum</span> = a + b</span><br><span class="line"></span><br><span class="line">                <span class="comment">#在[j+1,n-1]这个区间去寻找最长的边c</span></span><br><span class="line">                <span class="comment">#left为当前区间最左侧的元素</span></span><br><span class="line">                left = j+<span class="number">1</span></span><br><span class="line">                <span class="comment">#right为当前区间最右侧的元素</span></span><br><span class="line">                right = n -<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt;= right:  </span><br><span class="line">                    mid = left + (right - left) //<span class="number">2</span></span><br><span class="line">                    <span class="comment">#两边之和大于中间元素的值，说明两边之和肯定大于[left,mid]这个区间中所有的元素</span></span><br><span class="line">                    <span class="comment">#也即[left, mid]这个区间中所有元素都和nums[i] nums[j]构成三角形</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">sum</span> &gt; nums[mid]:</span><br><span class="line">                        <span class="comment">#缩小查找区间，查看[mid+1 , right]中是否还有元素可以和nums[i] 和nums[j]构成三角形</span></span><br><span class="line">                        left = mid +<span class="number">1</span></span><br><span class="line">                    <span class="comment">#两边之和小于中间元素的值，需要在区间[left mid-1]这个区间来找是否有元素可以和nums[i] 和nums[j]构成三角形</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#elif sum &lt;= nums[mid]:</span></span><br><span class="line">                        right = mid -<span class="number">1</span></span><br><span class="line">                <span class="comment">#跳出while循环之后，left = right + 1</span></span><br><span class="line">                <span class="comment">#如果两边之和大于了right指向的nums[right],此时nums[i] nums[j] 和nums[right]之间是可以构成相应的三角形的</span></span><br><span class="line">                <span class="comment">#[j+1 ,right]之间所有的元素都是可以和nums[i] nums[j]构成相应的三角形</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span> &gt; nums[right]:</span><br><span class="line">                    <span class="comment">#计算[j +1, right]区间内的所有元素</span></span><br><span class="line">                    ans = right-(j + <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">                    <span class="comment">#将结果累加上去</span></span><br><span class="line">                    res += ans</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="leetcoad162-寻找峰值-middle"><a href="#leetcoad162-寻找峰值-middle" class="headerlink" title="leetcoad162-寻找峰值(middle)"></a>leetcoad162-寻找峰值(middle)</h1><p>思路：仍然是是用二分查找的思路:不断排除无效区间，缩小有效区间的范围<br>还有就是要读懂题目的相关意思<br>关键点：查找大的大一半一定会有峰值</p>
<ol>
<li>往下坡方向走，有可能遇到新的峰值，也有可能一路到谷底（中间的值大于中间+1的值）<ul>
<li>需要在左侧去寻找：right &#x3D; mid</li>
</ul>
</li>
<li>往上坡方向走，由于最后是深渊，所以一定会有山峰<ul>
<li>需要在右侧去寻找峰值：left &#x3D; mid +1<br>自己认为要注意的点：（中间的值小于中间+1的值）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findPeakElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left ,right = <span class="number">0</span>,<span class="built_in">len</span>(nums) -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) //<span class="number">2</span></span><br><span class="line">            <span class="comment">#如果nums[mid] &gt; nums[mid +1]，此时在往下坡的方向走</span></span><br><span class="line">            <span class="comment">#如果存在山峰，那么这一段是右侧下降的那一段，因此需要在左侧去寻找上升的那一段</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[mid +<span class="number">1</span>]:</span><br><span class="line">                <span class="comment">#缩小区间，从[left , mid]里面去找,此处因为不确定mid到底是不是第一个满足的，需要将mid放到下一轮的二分中，所以right=mid而不是mid -1</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="comment">#如果nums[mid] &lt; nums[mid +1]</span></span><br><span class="line">            <span class="comment">#如果存在山峰，那么这一段是左侧上升的那一段，因此需要在右侧去寻找下降的那段</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid +<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line"><span class="comment">#时间复杂度：O(logn)</span></span><br></pre></td></tr></table></figure>
其他的一些解法：<br>直接暴力的方式：由于题目保证了 nums[i]≠nums[i+1]，那么数组 nums 中最大值两侧的元素一定严格小于最大值本身。因此，最大值所在的位置就是一个可行的峰值位置。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findPeakElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;nums[index]:</span><br><span class="line">                index =i</span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line"><span class="comment">#时间复杂度：O(n),n是数组的长度</span></span><br><span class="line"><span class="comment">#空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="leetcoad278-第一个错误的版本-easy"><a href="#leetcoad278-第一个错误的版本-easy" class="headerlink" title="leetcoad278-第一个错误的版本(easy)"></a>leetcoad278-第一个错误的版本(easy)</h1><p>思路：仍然采用二分查找的思路<br>重点：</p>
<ol>
<li>如果中间的值不是错误的版本，那左区间一定都是正确的版本，需要在[mid +1,right]中间去寻找</li>
<li>如果中间的值就是错误的版本，那么这个版本有可能是第一个错误的版本，也有可能不是第一个错误的版本，因此，需要在[left,mid]这个区间来继续进行相应的查找<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return an integer</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">firstBadVersion</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#这里right的值需要注意，由于没用用到nums[right]这种写法，所以这里是不需要n -1的</span></span><br><span class="line">        left,right = <span class="number">1</span>,n</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> isBadVersion(mid) <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                right = mid </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#elif isBadVersion(mid) is False:</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad268-丢失的数字-easy"><a href="#leetcoad268-丢失的数字-easy" class="headerlink" title="leetcoad268-丢失的数字(easy)"></a>leetcoad268-丢失的数字(easy)</h1><p>利用位运算的两个特征：</p>
<ol>
<li>相同的数字异或为0</li>
<li>任何数字和0异或为它本身<br>解决思路：<br>让nums中的所有值与[0,n]的每一位值进行相应的异或操作<br>两个相同的结果异或的结果是0<br>任何一个数字和0进行异或还是它本身<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/missing-number/comments/">https://leetcode-cn.com/problems/missing-number/comments/</a>看到该链接的评论区有一个四种解法的大佬<br>采用位异或运算符：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        missing = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            missing = missing ^ nums[i] ^(i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> missing</span><br></pre></td></tr></table></figure>
采用排序+循环遍历的方法：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从左到右遍历数组 nums，如果存在 0≤i&lt;n 使得 nums[i]≠i=i，则缺失的数字是满足 nums[i]≠i的最小的 i；</span></span><br><span class="line"><span class="comment">#如果对任意0&lt;=i&lt;n，都有nums[i] = i 那么缺失的数字就是n</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i !=nums[i]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="comment">#时间复杂度：O(nlogn),排序的时间复杂度:O(nlogn)+ 遍历数组寻找丢失的数字时间复杂度:O(n)</span></span><br><span class="line"><span class="comment">#空间复杂度：O(logn)，主要取决于排序的递归调用栈空间</span></span><br></pre></td></tr></table></figure>
采用数学公式的方法：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[0,n]全部数的和与nums中的所有数字和的差值即为丢失的那个数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="built_in">sum</span> = <span class="built_in">sum</span> + nums[i]</span><br><span class="line">        <span class="keyword">return</span> n * (n + <span class="number">1</span>)//<span class="number">2</span> - <span class="built_in">sum</span></span><br><span class="line"><span class="comment">#时间复杂度：O(n),计算0~n的全部整数和的时间复杂度:O(1)+ 计算数组的元素之和的时间复杂度:O(n)</span></span><br><span class="line"><span class="comment">#空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure>
采用哈希集合<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad231-2的幂-easy"><a href="#leetcoad231-2的幂-easy" class="headerlink" title="leetcoad231-2的幂(easy)"></a>leetcoad231-2的幂(easy)</h1><p>思路：<br>对于一个二进制的数来说，如果是2的幂次方，那么是有有且仅有一个1的，这个数与n-1的按位与操作的结果是0<br>n&amp;(n-1):是将n的二进制表示的最低位1移除，如果n&amp;(n-1)&#x3D;&#x3D;0，则n是2的幂次方<br>n&amp;(-n):可以直接获取 n 二进制表示的最低位的 1,如果n&amp;(-n)&#x3D;&#x3D;n，则n是2的幂次方</p>
<ol>
<li>先将整数转化为2进制</li>
<li>找出n-1的二进制</li>
<li>让n和n -1进行一个按位与的操作</li>
<li>如果n不是2次幂，就会在两个地方出现1，最后相互之间的按位与的操作不是0<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> n &gt;<span class="number">0</span> <span class="keyword">and</span> n &amp; (n-<span class="number">1</span>)==<span class="number">0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> n &gt;<span class="number">0</span> <span class="keyword">and</span> n &amp; (-n)==n</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad338-比特位计数"><a href="#leetcoad338-比特位计数" class="headerlink" title="leetcoad338-比特位计数"></a>leetcoad338-比特位计数</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E4%BD%8D%E8%BF%90%E7%AE%97/" data-id="claqu8zz3001eiwtk46xrf6li" data-title="二分查找-位运算" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-二叉树相关题目汇总一" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%B8%80/" class="article-date">
  <time class="dt-published" datetime="2022-03-19T09:15:17.000Z" itemprop="datePublished">2022-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%B8%80/">二叉树相关题目汇总一</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>这里对递归的掌握十分的重要，<strong>后面很多的思想和题目都是来自于递归的方法</strong>，所以自己必须<strong>狠狠的啃下来，理解下来，而且要从本质上去理解递归，用的实在是太多的地方了</strong>（二次回顾的时候就再次强调这里的内容了）!!!!!!</p>
<h2 id="内涵："><a href="#内涵：" class="headerlink" title="内涵："></a>内涵：</h2><ol>
<li>从已知问题的结果出发，用迭代表达式逐步推算出问题的开始的条件</li>
<li>把规模大的、较难解决的问题变成规模较小的、易解决的同一问题。规模较小的问题又变成规模更小的问题，并且小到一定程度可以直接得出它的解，从而得到原来问题的解。</li>
<li><strong>递归需要用到栈的调用</strong>，而对栈的理解又是一大核心<br>参考链接：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44143702/article/details/86551826">https://blog.csdn.net/weixin_44143702/article/details/86551826</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1B4411H76f?p=43">https://www.bilibili.com/video/BV1B4411H76f?p=43</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kubidemanong/p/10538799.html">https://www.cnblogs.com/kubidemanong/p/10538799.html</a></li>
</ol>
<h2 id="满足的条件："><a href="#满足的条件：" class="headerlink" title="满足的条件："></a>满足的条件：</h2><ol>
<li>必须包含一个明确的递归的结束条件（也即递归的出口或者是边界）</li>
<li>自己调用自己:在一个函数的定义中又直接或间接的调用本身</li>
</ol>
<h2 id="递归需要遵守的一些重要的规则："><a href="#递归需要遵守的一些重要的规则：" class="headerlink" title="递归需要遵守的一些重要的规则："></a>递归需要遵守的一些重要的规则：</h2><ol>
<li>执行一个方法的时候，就会创建一个新的受保护的独立空间（栈空间）</li>
<li>方法的局部变量是独立的，不会受影响</li>
<li>递归必须向退出递归的条件逼近，否则就是无限循环</li>
<li>当一个方法执行完毕或者遇到return，就会返回。<strong>遵守谁调用就将结果返回给谁</strong>，同时当方法执行完毕或返回的时候，该方法也会执行完毕。</li>
</ol>
<h2 id="递归的优缺点："><a href="#递归的优缺点：" class="headerlink" title="递归的优缺点："></a>递归的优缺点：</h2><p>优点：符合人的思维方式，递归程序结构清晰，可读性，容易理解<br>缺点：通过调用函数实现，当递归层数过多时，程序的效率低</p>
<h2 id="递归的应用场景："><a href="#递归的应用场景：" class="headerlink" title="递归的应用场景："></a>递归的应用场景：</h2><ol>
<li>数据的定义形式是递归的，例如求Fibonacii数列的第n项</li>
<li>数据之间的逻辑关系（即数据结构）是递归的，如树、图等的定义和操作</li>
<li>某些问题虽然没有明显的递归关系或结构，但问题的解法是不断重复执行一组操作，只是问题规模由大化小，直至某个原操作（基本操作）就结束。例如：汉诺塔问题。</li>
</ol>
<h2 id="递归常常的一些问题以及算法：（基础中的基础部分）"><a href="#递归常常的一些问题以及算法：（基础中的基础部分）" class="headerlink" title="递归常常的一些问题以及算法：（基础中的基础部分）"></a>递归常常的一些问题以及算法：（基础中的基础部分）</h2><ol>
<li>8皇后问题</li>
<li>汉诺塔问题</li>
<li>迷宫问题</li>
<li>球和篮子的问题</li>
<li>阶乘问题</li>
<li>归并排序</li>
<li>二分查找</li>
<li>分治算法</li>
<li>用栈解决的问题，递归代码比较的简洁</li>
</ol>
<h2 id="真正自己在用递归的时候需要强迫自己思考的几个步骤"><a href="#真正自己在用递归的时候需要强迫自己思考的几个步骤" class="headerlink" title="真正自己在用递归的时候需要强迫自己思考的几个步骤"></a>真正自己在用递归的时候需要强迫自己思考的几个步骤</h2><ol>
<li>明确这个函数想要干什么？（第一步就在这，有了方向就有了接下来的实现）</li>
<li>寻找递归结束条件（这里的结束条件可能不止一个，需要通过第三不进行反推）</li>
<li>找出函数的等价关系式</li>
</ol>
<h2 id="还是得熟悉几个递归的小例子"><a href="#还是得熟悉几个递归的小例子" class="headerlink" title="还是得熟悉几个递归的小例子"></a>还是得熟悉几个递归的小例子</h2><p>写在前面：多思考，多总结，多练习，多调试</p>
<h1 id="python二叉树类定义"><a href="#python二叉树类定义" class="headerlink" title="python二叉树类定义"></a>python二叉树类定义</h1><p>列表转二叉树，leetcode本地调试的方法：（自己暂时没有解决这个问题）<br>链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35376241/article/details/106070293">https://blog.csdn.net/qq_35376241/article/details/106070293</a>,后面自己有精力自己琢磨一下<br><a target="_blank" rel="noopener" href="https://vimsky.com/examples/detail/python-ex-TreeNode-TreeNode-fromArray-method.html">https://vimsky.com/examples/detail/python-ex-TreeNode-TreeNode-fromArray-method.html</a>这篇文章后面自己也可以参考一下<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Mr_111000/article/details/119680459">https://blog.csdn.net/Mr_111000/article/details/119680459</a>这篇里面也写得不错</p>
<ol>
<li>通过二叉树的类定义</li>
<li>通过将列表转化为二叉树</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">   <span class="string">&quot;&quot;&quot; 定义树的节点类型 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="literal">None</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">makeTree</span>(<span class="params">l:<span class="type">List</span></span>) -&gt; TreeNode:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 由输入列表生成树，返回根节点 &quot;&quot;&quot;</span></span><br><span class="line">    q = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    root = TreeNode(val=l.pop(<span class="number">0</span>))</span><br><span class="line">    q.append(root)</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        t = q.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> l:</span><br><span class="line">            <span class="keyword">if</span> l[<span class="number">0</span>] != <span class="string">&#x27;null&#x27;</span>:</span><br><span class="line">                t.left = TreeNode(val=l.pop(<span class="number">0</span>))</span><br><span class="line">                q.append(t.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> l:</span><br><span class="line">            <span class="keyword">if</span> l[<span class="number">0</span>] != <span class="string">&#x27;null&#x27;</span>:</span><br><span class="line">                t.right = TreeNode(val=l.pop(<span class="number">0</span>))</span><br><span class="line">                q.append(t.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将列表转换为二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List2Tree</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="built_in">list</span></span>):</span><br><span class="line">        self.nums = nums</span><br><span class="line">        self.queue = []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            self.root = TreeNode(self.nums.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = self.nums.pop(<span class="number">0</span>)</span><br><span class="line">            b = self.nums.pop(<span class="number">0</span>)</span><br><span class="line">            c = self.nums.pop(<span class="number">0</span>)</span><br><span class="line">            self.root = TreeNode(a)</span><br><span class="line">            <span class="keyword">if</span> b <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                self.root.left = TreeNode(b)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.root.left = b</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                self.root.right = TreeNode(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.root.right = c</span><br><span class="line">            self.queue.append(self.root.left)</span><br><span class="line">            self.queue.append(self.root.right)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.nums) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(self.queue)&gt; <span class="number">0</span>:</span><br><span class="line">            node = self.queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                num= self.nums.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    node.left = TreeNode(num)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node.left = num</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(self.nums) &gt; <span class="number">0</span>:</span><br><span class="line">                    num = self.nums.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    num = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    node.right = TreeNode(num)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node.right = num</span><br><span class="line">                self.queue.append(node.left)</span><br><span class="line">                self.queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> self.root</span><br></pre></td></tr></table></figure>
<p><strong>二叉树的基础知识：</strong></p>
<ul>
<li>有且仅有一个父节点</li>
<li>除了根节点之外，其余节点只有一个父节点</li>
<li>每个节点都可以构成以它为根的树</li>
<li>每个节点最多有两个孩子，有左右之分<br>几个特殊的二叉树：</li>
</ul>
<ol>
<li>满二叉树：叶子节点在最下层，除叶子节点外，每个节点度均为2（总节点数：1+2^1+…+2^(k-1)&#x3D;2^k-1)</li>
<li>完全二叉树：若有度为1的节点，则只可能有一个，并且该节点只有左孩子而无右孩子(是一种除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐的树)</li>
<li>二叉排序树（BST，也叫二叉搜索树&#x2F;查找树）：<strong>左子树</strong>上所有节点的关键字均<strong>小于****根节点</strong>的关键字，<strong>右子树</strong>上的所有节点的关键字均<strong>大于****根节点</strong>的关键字，<strong>左子树和右子树</strong>又各是一棵<strong>二叉排序树</strong>（相对特殊，有排序的概念，<strong>对一个二叉排序树做中序遍历可以得到一个递增的有序序列</strong>）</li>
<li>平衡二叉树：任意节点的左子树和右子树的深度之差不超过1</li>
</ol>
<p>二叉搜索树:(Binnary Search Tree)<br>二叉搜索树与链表的关系(left right parent)<br><img src="https://runnerxr.github.io/post-images/1648386022929.jpg"><br>二叉树的插入操作<br>二叉树的删除操作<br>二叉树的四种遍历方式要十分的熟悉其中的思路和逻辑，程序模板烂熟于心。属于基础中的基础要掌握的部分，其中的书中的内容也是一样的（<strong>按照某条搜索路径访问树中的每个节点</strong>）：<br>掌握的主要解决方式就是自己再重新的做一遍。<br>递归算法（<strong>短小精悍，重在理解</strong>）与非递归算法（<strong>利用栈队列的思路来解题</strong>）</p>
<p><strong>最常见的四种遍历（根节点在何时被访问）：</strong></p>
<ol>
<li>前序遍历：preorder</li>
<li>中序遍历:inorder</li>
<li>后序遍历:posrorder</li>
<li>层序遍历</li>
</ol>
<p><strong>三种遍历方式的总结：</strong></p>
<ul>
<li>每个节点都访问一次且仅访问一次，时间复杂度O(n)</li>
<li>递归工作栈的栈深为树的深度，空间复杂度为O(n)</li>
</ul>
<p><strong>构建一个二叉树的类</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当成模板来记忆的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val</span>):</span><br><span class="line">        self.val=val</span><br><span class="line">        self.left =<span class="literal">None</span></span><br><span class="line">        self.right=<span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>以下为二叉树的一些主要的题目：要多多的做，多多的总结，并总结出二叉树的一些具体的框架出来（很重要），之所以要多多做，因为这类题目涉及到后面的一些理解，很多时候是前面的基础没有打牢靠，概念没有吃透，这种不像数组那类题目至少是有思路的，这种就是完全没有没有，很多时候就无从下手的感觉，也是因为没有抽象出来的原因……，再做了这么多题目之后，也要总结出一些<strong>相应的框架思维</strong>出来，即使具体的代码可能不会写，但是<strong>大的方向不会错</strong>，剩下的就是<strong>往里面填充东西</strong>。</p>
<ol>
<li>leetcoad144-前序遍历(easy)</li>
<li>leetcoad102-层序遍历(middle)</li>
<li>leetcoad100-相同的树(easy)</li>
<li>leetcoad101-对称二叉树(easy)</li>
<li>leetcoad-104二叉树的最大&#x2F;最小深度</li>
<li>leetcoad108-将有序数组转化为二叉搜索树(easy)</li>
<li>leetcoad110-平衡二叉树(easy)</li>
<li>leetcoad105-从前序与中序遍历构造二叉树(middle)</li>
<li>leetcoad235-二叉搜索树的最近公共祖先(middle)</li>
<li>leetcoad236-二叉树的最近公共祖先(middle)</li>
<li>leetcoad113-路径总和III（middle）</li>
<li>leetcoad199-二叉树的右视图（middle）</li>
<li>leetcoad114-二叉树展开为链表</li>
<li>leetcoad538-把二叉搜索树转换为累加树</li>
<li>leetcoad450-删除二叉搜索树中的节点</li>
<li>leetcoad297-二叉树的序列化与反序列化</li>
<li>leetcoad222-完全二叉树的节点个数</li>
<li>leetcoad257二叉树的所有路径</li>
<li>leetcoad404-左叶子之和</li>
<li>leetcoad513-找树左下角的值</li>
<li>leetcoad669-修剪二叉搜索树</li>
<li>leetcoad530-二叉搜索树的最小绝对差</li>
</ol>
<p>三种遍历方式要全部掌握相应的核心递归和迭代写法<br><img src="https://runnerxr.github.io/post-images/1653632922377.png"><br><strong>leetcoad144-前序遍历:(easy)</strong><br>若二叉树为空，则什么也不做，否则：</p>
<ul>
<li><strong>访问根节点</strong><br>-** 先序遍历左子树**</li>
<li><strong>先序遍历右子树</strong></li>
</ul>
<p><strong>非递归的写法：</strong>（需要借助栈和指针来完成）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个版本暂时放在这里，不做处理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        node,stack,preorderReslut=root,[],[]</span><br><span class="line">        nodeLeft = <span class="number">100</span></span><br><span class="line">        nodeRight = <span class="number">200</span></span><br><span class="line">        nodeUp = <span class="number">300</span></span><br><span class="line">        nodeState = nodeLeft</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对二叉树进行遍历</span></span><br><span class="line">        <span class="keyword">while</span> node :</span><br><span class="line">            <span class="keyword">if</span> nodeState == nodeLeft :</span><br><span class="line">                <span class="comment"># 在将要访问左孩子地时候加入节点值，形成根--左---右</span></span><br><span class="line">                preorderReslut.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left :</span><br><span class="line">                    stack.append(node)</span><br><span class="line">                    node = node.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nodeState = nodeRight</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> nodeState == nodeRight:</span><br><span class="line">                <span class="keyword">if</span> node.right :</span><br><span class="line">                    stack.append(node)</span><br><span class="line">                    node = node.right</span><br><span class="line">                    nodeState = nodeLeft</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nodeState = nodeUp</span><br><span class="line">            <span class="keyword">elif</span> nodeState == nodeUp : </span><br><span class="line">                parent = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">if</span> stack :</span><br><span class="line">                    parent = stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> parent.left == node :</span><br><span class="line">                        nodeState = nodeRight</span><br><span class="line">                node = parent</span><br><span class="line">        <span class="keyword">return</span> preorderReslut</span><br></pre></td></tr></table></figure>
<p>下面的一些代码是自己经过精心整理的部分，统一了模板的形式（迭代与递归的写法）<br><strong>非递归的写法</strong>：（需要借助栈和指针来完成）<br>递归实现时，是函数自己调用自己，一层层的嵌套下去，操作系统&#x2F;虚拟机自动帮我们用栈来保存了每个调用的函数，现在我们需要自己模拟这样的调用过程</p>
<p>前序遍历<br>利用栈先进后出的原则，先将右子树入栈，再将左子树入栈，下面的流程图很好的解释了根–左–右的过程（打印的过程）<br><img src="https://runnerxr.github.io/post-images/1654567780516.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 一开始就将头节点加入栈中</span></span><br><span class="line">        stack,res=[root],[]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node=stack.pop()</span><br><span class="line">            <span class="comment"># 将根节点的值加入到结果中(打印) </span></span><br><span class="line">            res.append(node.val) </span><br><span class="line">            <span class="comment"># 右子树入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="comment"># 左子树入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>为了与下面中序和后序的模板对应，有了第二种写法，与上面的解法有点不同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 根结点为空则返回空列表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        cur,stack,res=root,[],[]</span><br><span class="line">        <span class="comment"># 利用的是两层循环</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> cur:  </span><br><span class="line">                <span class="comment">#根节点和左孩子入栈，不断地往左子树的方向走，直至cur为空 </span></span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur=cur.left</span><br><span class="line">            <span class="comment"># 每弹出一个元素就达到右孩子，又执行上面的操作</span></span><br><span class="line">            temp=stack.pop()  </span><br><span class="line">            cur=temp.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>中序遍历<br>不断往左边走，当左边走不下去了，就打印节点，并转向右边，然后右边继续这个过程<br><img src="https://runnerxr.github.io/post-images/1654568007885.gif"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与前序遍历的模板相同，只是节点temp加入的时机不同</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 根结点为空则返回空列表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        cur,stack,res=root,[],[]</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> cur: </span><br><span class="line">                <span class="comment">#cur入栈，并达到最左端的叶子节点，模拟递归的调用  </span></span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur=cur.left</span><br><span class="line">            <span class="comment"># 当前节点为空了，说明左边走到尽头了，从栈中弹出节点并保存</span></span><br><span class="line">            temp=stack.pop()</span><br><span class="line">             <span class="comment"># 出栈时再加入结果（**）</span></span><br><span class="line">            res.append(temp.val) </span><br><span class="line">            <span class="comment"># 转向右边的节点，继续上面的整个过程</span></span><br><span class="line">            cur=temp.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>后序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与前序遍历的代码几乎相同，这里是不断地往右子树方向走，为空后再不断地往左子树方向走</span></span><br><span class="line"><span class="comment"># 最后输出的时候要注意翻转</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 根结点为空则返回空列表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        cur,stack,res=root,[],[]</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> cur: </span><br><span class="line">                <span class="comment"># 先到达最右端</span></span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur=cur.right</span><br><span class="line">            temp=stack.pop()</span><br><span class="line">            cur=temp.left</span><br><span class="line">        <span class="comment"># 将最终的数组翻转输出</span></span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]  </span><br></pre></td></tr></table></figure>
<p>采用递归的方式：当成模板记忆就行,只是换了三行代码的顺序<br>递归的写法是巧妙地利用了系统栈，而迭代写法就是用stack来模拟系统栈<br>前序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:        </span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            res.append(root.val)   <span class="comment">#访问根节点</span></span><br><span class="line">            dfs(root.left)      <span class="comment">#递归遍历左子树</span></span><br><span class="line">            dfs(root.right)   <span class="comment">#递归遍历右子树</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>中序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:        </span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            dfs(root.left)      <span class="comment">#递归遍历左子树</span></span><br><span class="line">            res.append(root.val)   <span class="comment">#访问根节点</span></span><br><span class="line">            dfs(root.right)   <span class="comment">#递归遍历右子树</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>后序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:        </span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            dfs(root.left)      <span class="comment">#递归遍历左子树</span></span><br><span class="line">            dfs(root.right)   <span class="comment">#递归遍历右子树</span></span><br><span class="line">            res.append(root.val)   <span class="comment">#访问根节点</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<p><strong>leetcoad102-层序遍历(middle)</strong><br>leetcoad链接：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a><br>视频链接：<a target="_blank" rel="noopener" href="https://www.algomooc.com/795.html">https://www.algomooc.com/795.html</a></p>
<p>方法不止一种，可以用迭代，也可以用递归的方式来完成，也可以从总结前 中 后序的遍历过程中知道<br>注意的几个地方：<br>需要创建用辅助的数组构成的队列来完成<br>循环的出口，当队列为空的时候，此时遍历就去全部完成<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 迭代写法：本质是一种广度优先搜索</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment">#设置res用来保存输出结果</span></span><br><span class="line">        res =[]</span><br><span class="line">        <span class="comment">#边界情况的处理</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment">#设置一个队列，用来存储二叉树中的元素</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="comment">#在队列中添加二叉树的根节点</span></span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="comment">#遍历根节点，直到队列为空，说明访问了二叉树中所有的节点</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment">#用来记录queue的长度，即每层节点的个数</span></span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="comment">#用来保存每一层节点，保存成功后添加到res中</span></span><br><span class="line">            temp = []</span><br><span class="line">            <span class="comment">#使用for循环，将queue中元素添加到temp中</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,size):</span><br><span class="line">                <span class="comment">#从queue中取出一个节点</span></span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="comment">#把节点存放到temp中</span></span><br><span class="line">                temp.append(node.val)</span><br><span class="line">                <span class="comment">#判断当前节点的左子节点是否有值，如果有，就添加到queue中</span></span><br><span class="line">                <span class="keyword">if</span> node.left !=<span class="literal">None</span>:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right !=<span class="literal">None</span>:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            res.append(temp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><br><strong>leetcoad100-相同的树(easy)</strong><br>leetcoad链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree/">https://leetcode-cn.com/problems/same-tree/</a><br>解题思路如下：（深度优先搜索-从概念进行入手的）</p>
<ol>
<li>如果两个二叉树都为空，则两个二叉树相同</li>
<li>如果两个二叉树有且只有一个为空，则两个二叉树一定不相同</li>
<li>如果两个二叉树都不为空<ol>
<li>判断根节点的值是否相同<br> * 若不同，二叉树一定不同<br> * 若相同再判断<br>          - 判断两个二叉树的左子树是否相同以及右子树是否相同<br>采用深度优先搜索的方法：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSameTree</span>(<span class="params">self, p: TreeNode, q: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">#如果两个二叉树都为空，则两个二叉树相同</span></span><br><span class="line">        <span class="comment">#if not p and not q:</span></span><br><span class="line">        <span class="keyword">if</span> p ==<span class="literal">None</span> <span class="keyword">and</span> q == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment">#如果两个二叉树有且只有一个为空，则两个二叉树一定不相同</span></span><br><span class="line">        <span class="comment">#elif not p or not q:</span></span><br><span class="line">        <span class="keyword">elif</span> p== <span class="literal">None</span> <span class="keyword">or</span> q == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#如果两个二叉树都不为空</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#判断根节点的值是否相同</span></span><br><span class="line">            <span class="keyword">if</span> p.val != q.val:</span><br><span class="line">                <span class="comment">#如果根节点不同，那么二叉树一定不同</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment">#判断两个二叉树的左子树是否相同以及右子树是否相同</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.isSameTree(p.left,q.left) <span class="keyword">and</span> self.isSameTree(p.right,q.right)</span><br></pre></td></tr></table></figure>
时间复杂度：O(mim(m,n)),m和n为两个二叉树的节点数，只有当两个二叉树中对应的节点都不为空时才会访问到该节点，因此访问到的节点数不会超过较小的二叉树的节点树。<br>空间复杂度：O(min(m,n))<br>从这道题中衍生出来的一些知识点的问题（耐心细致的整理）<br><strong>leetcoad101-对称二叉树(easy)</strong><br>leetcoad链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">https://leetcode-cn.com/problems/symmetric-tree/</a><br>采用递归的方式来写：<br>在尝试判断左树与右数对称的条件时，发现跟两树的孩子的对称情况是有关联的<br>直接写：<br>def 函数A(左树，右树)：左树节点值等于右树节点值且函数A（左树的左子树，右树的右子树），函数A（左树的右子树，右树的左子树）均为真才返回真<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isSymmetric(self, root: TreeNode) -&gt; bool:</span><br><span class="line">        #如果两个二叉树都为空，则两个二叉树一定为对称二叉树</span><br><span class="line">        if not root:</span><br><span class="line">            return True</span><br><span class="line">        def search(left,right):</span><br><span class="line">            #递归的终止条件是两个节点都为空</span><br><span class="line">            #或者两个节点中有一个为空</span><br><span class="line">            #或者两个节点的值不相等</span><br><span class="line">            if not left and not right :</span><br><span class="line">                return True</span><br><span class="line">            elif not left or not right :</span><br><span class="line">                return False</span><br><span class="line">            else:</span><br><span class="line">                if left.val!=right.val:</span><br><span class="line">                    return False</span><br><span class="line">                else:</span><br><span class="line">                    return search(left.left,right.right) and search(left.right,right.left)</span><br><span class="line">        return search(root.left,root.right)</span><br></pre></td></tr></table></figure>
采用迭代的方式来写：<br>略</li>
</ol>
</li>
</ol>
<p><strong>leetcoad-104二叉树的最大&#x2F;最小深度</strong><br>二叉树的深度：根节点到最远叶子节点的最长路径上的节点数<br>辅助于理解递归的思路，其实是用的深度优先搜索（DFS+分治）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#如果root为空，直接返回0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#递归调用 maxDepth,求出当前节点的左子树的最大深度</span></span><br><span class="line">        left = self.maxDepth(root.left)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#递归调用 maxDepth,求出当前节点的右子树的最大深度</span></span><br><span class="line">        right = self.maxDepth(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#求出当前节点的左右子树较大的值</span></span><br><span class="line">        childMaxDepth = <span class="built_in">max</span>(left,right)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#二叉树的最大深度就是它的左右子树较大的值加上1</span></span><br><span class="line">        <span class="keyword">return</span> childMaxDepth +<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>代码可以更加的简化（建立于充分理解的基础上）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.maxDepth(root.left),self.maxDepth(root.right))+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(h)  h表示二叉树的高度，递归函数需要栈空间，而栈空间取决于递归的深度<br>采用迭代的方式来写（广度优先搜索）：<br>略<br>参考链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/comments/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/comments/</a>派大星星</p>
<p><strong>leetcoad108-将有序数组转化为二叉搜索树(easy)</strong><br>leetcoad链接：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/</a><br>视频链接：&lt;&gt;<br>给你一个整数数组 nums ，其中元素已经按升序排列，请你将其转换为一棵 高度平衡 二叉搜索树。<br>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。<br>这里有几个点需要注意的：</p>
<ol>
<li>高度平衡二叉树</li>
<li>二叉搜索树</li>
<li>我反正没有做过，所以是一摸瞎的感觉，但是对于基础不是很好的我，还是很难的，所以相关的一些基础的知识必须在做题的时候认真的补充起来！！！！</li>
</ol>
<p>看几篇题解的知识，一边整理一边学习：<br><strong>二叉搜索树</strong>中的<strong>中序遍历</strong>是<strong>升序</strong>遍历，题目中由于是升序排列的有序数组，那么必然就是<strong>二叉搜索树中的中序遍历序列</strong>。（也算是一种分析题目吧）<br>给定的二叉搜索树的中序遍历，能否唯一的确定二叉搜索树？不能，题目中还有一个附加的条件：要满足一个高度平衡的二叉树，如果忽略这个条件，<strong>任何一个数字都可以作为二叉搜索树的根节点，因此可能的二叉搜索树是有多个的</strong><br><img src="https://runnerxr.github.io/post-images/1653460732646.png"><br>如果增加要求二叉搜索树高度平衡之后，仍然不能唯一的确定二叉搜索树<br><img src="https://runnerxr.github.io/post-images/1653461040852.png"><br>通过上面的分析我们可以得出：可以选择中间数字作为二叉搜索树的根节点，这样左右两边的数字的个数只相差1，确定平衡二叉搜索树的根节点之后，<strong>其余的数字</strong>分别位于平衡二叉搜索树的<strong>左子树</strong>和<strong>右子树</strong>中，<strong>左子树和右子树分别也是平衡二叉搜索树</strong>，因此可以通过递归的方式创建平衡二叉搜索树。因此本题的本质在于：<strong>高度平衡的理解</strong>。</p>
<p>解题步骤：</p>
<ol>
<li>先去找排序数组中中间的那个元素：设置两个索引，分别指向开头位置和结束位置</li>
<li>利用二叉搜索树递归的特性</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">return</span> self.toBST(nums,<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 需要另外写一个函数 toBST</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">toBST</span>(<span class="params">self,nums,begin,end</span>):</span><br><span class="line">        <span class="keyword">if</span> begin &gt;end:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 获取begin到end排序数组的中间元素的下标</span></span><br><span class="line">        mid=(begin+end)//<span class="number">2</span></span><br><span class="line">        <span class="comment"># 获取以mid为下标的元素，并把这个元素作为转换后的二叉树的根节点</span></span><br><span class="line"></span><br><span class="line">        root=TreeNode(nums[mid])</span><br><span class="line">        <span class="comment"># 递归的将mid左侧的所有元素转换为平衡二叉树</span></span><br><span class="line"></span><br><span class="line">        left=self.toBST(nums,begin,mid-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 递归的将mid右侧的所有元素转换为平衡二叉树</span></span><br><span class="line">        right=self.toBST(nums,mid+<span class="number">1</span>,end)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将mid左侧的所有元素转换为平衡二叉排序树后作为root的左子树</span></span><br><span class="line">        root.left=left</span><br><span class="line">        <span class="comment"># 将mid右侧的所有元素转换为平衡二叉排序树后作为root的左子树</span></span><br><span class="line">        root.right=right</span><br><span class="line">        <span class="comment"># 返回转换好的平衡二叉树</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p><strong>leetcoad110-平衡二叉树(easy)</strong><br>leetcoad链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">https://leetcode-cn.com/problems/balanced-binary-tree/</a><br>视频链接：&lt;&gt;<br>思路：应该是有很多种解法的，这里采用<strong>自底向上</strong>的方式<br>有一个重要的概念：只有<strong>某子树不平衡</strong>，那么该树就<strong>一定不平衡</strong></p>
<ol>
<li>要想判断是否是高度平衡的二叉树，先看左子树是不是高度平衡的，再看右子树是不是高度平衡的二叉树</li>
<li>如果是的话，就算左右子树的高度差是否超过1，如果超过1的话就不是一个平衡二叉树</li>
<li>有不符合的情况可以提前返回（在代码中有好几处是可以直接返回不满足的结果的，相当于存在一个剪枝的过程）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 此时如果根节点的左右深度之差的返回值不为-1，就是平衡二叉树（True）</span></span><br><span class="line">        <span class="keyword">return</span> self.recur(root)!=-<span class="number">1</span></span><br><span class="line">    <span class="comment"># 自己写一个私有函数,需要不断的递归调用这个函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recur</span>(<span class="params">self,curNode</span>):</span><br><span class="line">        <span class="comment"># 递归的终止条件</span></span><br><span class="line">        <span class="comment"># 如果当前的节点为空，那么高度就是0(当访问的左右子节点为叶子节点的时候)</span></span><br><span class="line">        <span class="keyword">if</span> curNode==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归的计算当前节点的左子树的高度</span></span><br><span class="line">        left = self.recur(curNode.left)</span><br><span class="line">        <span class="comment"># 如果发现为-1，即3表示左子树中出现了高度差大于2的情况，已经不是平衡二叉树，直接返回这个结果给上层</span></span><br><span class="line">        <span class="comment"># 提前终止后续的判断,全树不平衡</span></span><br><span class="line">        <span class="keyword">if</span> left==-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 左子树是平衡二叉树</span></span><br><span class="line">        <span class="comment"># 递归的计算当前节点的右子树的高度</span></span><br><span class="line">        right=self.recur(curNode.right)</span><br><span class="line">        <span class="comment"># 如果发现为-1，即3表示右子树中出现了高度差大于2的情况，已经不是平衡二叉树，直接返回这个结果给上层</span></span><br><span class="line">        <span class="comment"># 提前终止后续的判断</span></span><br><span class="line">        <span class="keyword">if</span> right==-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 左右子树都是平衡二叉树</span></span><br><span class="line">        <span class="comment"># 计算当前左指数与右子树的高度差值</span></span><br><span class="line">        <span class="comment"># 如果发现小于2，那么返回以当前节点为根节点的子树的最大高度</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(left-right)&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
看了吴师兄的写法，大体上还是不太好想，不过具体的思路还是不错的，是值得自己借鉴和学习的，也许是因为还没有理解到精髓，所以自己再多看几篇题解之后多多总结一下。<br>这里<strong>再次结合K神的题解</strong>一起来理解这道题吧，再难也要把这类题目给合理的啃下来呀。<br><strong>递归返回值</strong>：</li>
<li>当节点root的左&#x2F;右子树的高度差小于2,返回以节点root为根节点的子树的最大高度</li>
</ol>
<p><code>（max(left,right）+1）</code><br>2. 当节点root的左&#x2F;右子树的高度差大于等于2，可以提前剪枝，返回-1，代表不是平衡二叉树</p>
<p><strong>递归终止条件</strong>：</p>
<ol>
<li>当越过叶子节点时，返回高度0</li>
<li>当左（右）子树高度 left&#x3D;&#x3D; -1 时，代表此子树的 左（右）子树 不是平衡树，因此直接返回 −1 ；<br>下面采用的是自<strong>顶向下的方法</strong>，但是存在重复的部分（类似一种暴力的解法）<br>本质上需要定义一个<strong>计算节点高度的函数</strong><br>如果p 是非空节点​：height(p)&#x3D;max(height(p.left),height(p.right))+1​<br>如果p是空节点：height(p)&#x3D;0<br>类似于二叉树的前序遍历：对于当前遍历到的节点，<strong>先计算左右子树的高度</strong>，如果左右子树的<strong>高度差不超过1</strong>，再分别递归遍历左右子节点，并判断左子树和右子树是否平衡。<strong>是一个自顶向下的递归过程</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(self.height(root.right)-self.height(roo.left)) &lt;<span class="number">2</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root,right)</span><br><span class="line">    <span class="comment"># 求二叉树高度的函数（重要的四句代码）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">self,node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left=self.height(node.left)</span><br><span class="line">        right=self.height(node.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+<span class="number">1</span></span><br><span class="line">        <span class="comment"># return 1+max(self.height(node.right),self.height(node.left))</span></span><br></pre></td></tr></table></figure>

<p><strong>leetcoad105-从前序与中序遍历构造二叉树(middle)</strong><br>leetcoad链接：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
<ol>
<li>任意二叉树的<strong>前序遍历序列</strong>中的<strong>第一个元素</strong>一定是二叉树的<strong>根节点</strong></li>
<li>在<strong>中序遍历中</strong>，根节点将序列分成两个子序列，如果该元素在根的左边，该元素就是根的左孩子，否则就是右孩子。（序列的排布规则：先是全部的左子节点，然后是根节点，然后是全部的右子节点）</li>
<li>在先序序列中，左子序列的第一个节点是左子树的根节点，右子序列的第一个节点是右子树的根节点。（序列的排布规则：<strong>先是一个根节点</strong>，然后是<strong>全部的左节点</strong>，接着是<strong>全部的右节点</strong>）<strong>如此递归下去，唯一的确定这颗二叉树</strong></li>
<li>其实推广开来：都是由遍历序列构造二叉树：<ol>
<li><strong>前序</strong>和<strong>中序</strong>可以唯一确定一颗二叉树</li>
<li><strong>中序</strong>和<strong>后续</strong>也可以唯一确定一棵二叉树</li>
<li><strong>层序</strong>和<strong>中序</strong>也可以唯一确定一颗二叉树</li>
</ol>
</li>
<li>本质就是一次深度优先遍历的过程<br><img src="https://runnerxr.github.io/post-images/1653536346729.png"></li>
</ol>
<p>迭代写法：<br>具体步骤如下：</p>
<ol>
<li>根据中序遍历，建立索引与中序值的哈希表的关系</li>
<li>根据前序遍历确定根节点，然后继续遍历其他元素思考应该放在哪里，执行一个插入函数</li>
<li>插入函数的撰写：<ol>
<li>如果待插入的节点值等于根节点值，说明已经插入完毕，可以用while循环来写这个插入的过程</li>
<li>如果通过哈希表获取的节点值的位置小于根节点获取的位置（说明一定是根的左子节点，按照中序遍历的过程，序列的索引大小一定是<code>左&lt;根&lt;右</code>）,这里还要判断一下以root为根的左孩子是否有值，      如果有值就需要<strong>插入到左孩子节点的孩子节点上</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="comment">#题目中preorder和inorder中没有重复的元素</span></span><br><span class="line">        <span class="comment">#通过哈希表把中序遍历序列中的值和顺序建立映射关系</span></span><br><span class="line">        n =  <span class="built_in">len</span>(inorder)</span><br><span class="line">        <span class="built_in">map</span> = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#通过for循环，遍历完中序遍历序列中的所有元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment">#以中序序列中的元素值inorder[i]作为key,以位置i作为value,存放到哈希表中</span></span><br><span class="line">            <span class="built_in">map</span>[inorder[i]] = i</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#开始构建二叉树</span></span><br><span class="line">        <span class="comment">#把前序遍历序列中的第一个元素preorder[0]，作为二叉树的根节点</span></span><br><span class="line">        <span class="comment">#任意二叉树的前序遍历序列中的第一个元素，一定是二叉树的根节点</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#继续遍历前序遍历序列中的其他元素</span></span><br><span class="line">        m = <span class="built_in">len</span>(preorder)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m):</span><br><span class="line">            <span class="comment">#先把当前遍历的元素构造为一个二叉树的节点</span></span><br><span class="line">            node = TreeNode(preorder[i])</span><br><span class="line"></span><br><span class="line">            <span class="comment">#把构造的节点插入到以root为根节点的二叉树中</span></span><br><span class="line">            self.insertNode(root,node,<span class="built_in">map</span>)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertNode</span>(<span class="params">self,root:TreeNode,node :TreeNode,<span class="built_in">map</span> :<span class="built_in">dict</span></span>):</span><br><span class="line">        <span class="comment">#当root和node指向的节点相同的时候，跳出循环</span></span><br><span class="line">        <span class="keyword">while</span> root != node :</span><br><span class="line">            <span class="comment">#如果node的中序遍历序列位置小于root的中序遍历序列位置</span></span><br><span class="line">            <span class="comment">#说明node应该在root的左子树中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">map</span>[node.val] &lt; <span class="built_in">map</span>[root.val]:</span><br><span class="line">                <span class="comment">#如果此时root没有左子树</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root.left:</span><br><span class="line">                    <span class="comment">#将node设置为root的左子树</span></span><br><span class="line">                    root.left = node</span><br><span class="line">                <span class="comment">#如果之前root已经有了左子树，不能直接把root插入到root的左子树上</span></span><br><span class="line">                <span class="comment">#需要判断应该把node插入到root左子树上的孩子节点的那个位置</span></span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#如果node的中序遍历序列位置大于root的中序遍历序列位置</span></span><br><span class="line">                <span class="comment">#说明node应该在root的右子树</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">#如果此时root没有右子树</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                    <span class="comment">#直接就把node设置为root的右子树</span></span><br><span class="line">                    root.right = node</span><br><span class="line">                root = root.right</span><br></pre></td></tr></table></figure>
递归写法：<br>总体上是采用了分治的思想：</li>
</ol>
</li>
<li>前序遍历数组的第 1个数（索引为 0）的数一定是二叉树的根结点</li>
<li>在<strong>中序遍历</strong>中找这个<strong>根结点的索引</strong>;</li>
<li>把前序遍历数组”和“中序遍历数组”分为两个部分，分别对应二叉树的左子树和右子树，分别递归完成</li>
<li>总结一下就是：<strong>前序找根，中序来分</strong>，每次通过前序找到根节点，再用中序遍历确定新的左右子树的范围，最后递归这个过程。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (preorder <span class="keyword">and</span> inorder):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 根据前序序列的第一个元素确定根节点</span></span><br><span class="line">        root=TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用preorder[0]去查找中序数组中对应的元素</span></span><br><span class="line">        mid_index = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归的处理前序数组的的左边部分和中序数组的左边部分</span></span><br><span class="line">        root.left=self.buildTree(preorder[<span class="number">1</span>:mid_index+<span class="number">1</span>],inorder[:mid_index])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归的处理前序数组的右边部分和中序数组的右边部分</span></span><br><span class="line">        root.right=self.buildTree(preorder[mid_index+<span class="number">1</span>:],inorder[mid_index+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回root节点</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>** leetcoad106-从中序和后序遍历中构造二叉树**（middle）<br>思路和上一题十分的相似：后序遍历数组的最后一个元素即代表根节点，可以利用已知的更节点信息在中序遍历的数组中找到根节点所在的下标，然后根据中序遍历的数组分成左右两部分：左部分是左子树，右部分是右子树，针对每个部分采用同样的方法递归下去构造。<br>迭代法：<br>具体思路见：<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-14/">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-14/</a></p>
<ol>
<li>如果将中序遍历反序，则得到<strong>反向的中序遍历</strong>，即每次遍历右孩子，再遍历根节点，最后遍历左孩子。</li>
<li>如果将后序遍历反序，则得到反向的前序遍历，即每次遍历根节点，再遍历右孩子，最后遍历左孩子。<br>代码后期补上：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">**leetcoad235-二叉搜索树的最近公共祖先(middle)**</span><br><span class="line">leetcoad链接：</span><br><span class="line">&lt;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/&gt;</span><br><span class="line">常规的思路：</span><br><span class="line"><span class="number">1.</span> 先找p的各个祖先的节点</span><br><span class="line"><span class="number">2.</span> 再找q的各个祖先的节点</span><br><span class="line"><span class="number">3.</span> 比较找到的祖先的值，其中的最深的节点就是最近的祖先</span><br><span class="line">参照吴师兄算法的思路：</span><br><span class="line"><span class="number">1.</span> 充分利用了二叉树的性质：左子节点一定小于父节点，右子节点一定大于父节点</span><br><span class="line"><span class="number">2.</span> 根据公共祖先的定义：最小公共祖先将p和q化为两部分，位于二叉树的两侧</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>: </span><br><span class="line">        <span class="comment">#由于所有节点的值都是唯一的，当出现（root.val-p.val)*(root.val-q.val)=0时</span></span><br><span class="line">        <span class="comment">#说明p、q中有一个节点是root节点（p或者q有一个是祖先节点）</span></span><br><span class="line">        <span class="keyword">while</span> (root.val -p.val) * (root.val-q.val)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="comment">#当进入到循环中的时候，说明p、q在root的同侧</span></span><br><span class="line">            <span class="comment">#如果p.val&lt;root.val 也说明q.val &lt;root.val</span></span><br><span class="line">            <span class="keyword">if</span> p.val &lt; root.val:</span><br><span class="line">                <span class="comment">#接下来在左子树中进行查找</span></span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="comment">#如果p.val&gt;root.val 也说明q.val &gt;root.val</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.right</span><br><span class="line">        <span class="comment">#跳出循环，说明（root.val-p.val)*(root.val-q.val)&lt;=0</span></span><br><span class="line">        <span class="comment">#此时root就是p、q的最近的公共祖先</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
同样是利用二叉树的性质：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>: </span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> p.val == root.val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> q.val == root.val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> root.val &gt;p.val <span class="keyword">and</span> root.val &lt;q.val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt;p.val <span class="keyword">and</span> root.val &gt;q.val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt;p.val <span class="keyword">and</span> root.val &lt;q.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.left</span><br></pre></td></tr></table></figure>
简化版本：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>: </span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> p.val == root.val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> q.val == root.val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> (root.val &gt;p.val <span class="keyword">and</span> root.val &lt;q.val) <span class="keyword">or</span> (root.val &lt;p.val <span class="keyword">and</span> root.val &gt;q.val):</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt;p.val <span class="keyword">and</span> root.val &lt;q.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.left</span><br></pre></td></tr></table></figure>
简化：elif (root.val &gt;p.val and root.val &lt;q.val) or (root.val &lt;p.val and root.val &gt;q.val):这一行的代码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>: </span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> p.val == root.val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> q.val == root.val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt;q.val <span class="keyword">or</span> root.val &lt;p.val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt;p.val <span class="keyword">and</span> root.val &lt;q.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.left</span><br></pre></td></tr></table></figure>
将elif做最后的简化，因为有多种情况是返回的root这个结果，将条件进行合并<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>: </span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &lt;p.val <span class="keyword">and</span> root.val &lt;q.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">elif</span> root.val &gt;p.val <span class="keyword">and</span> root.val &gt;q.val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
此处也可将root &#x3D; root.right换一种写法</li>
</ol>
<p><strong>leetcoad236-二叉树的最近公共祖先(middle)</strong><br>这道题是当时吴师兄直播的时候的一道重点的题目，也是很有水平的一道题目</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="comment">#1.如果此时访问的节点root为空，那么直接返回空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment">#2.如果此时访问的节点root为指定节点p，那么返回p这个节点</span></span><br><span class="line">        <span class="keyword">if</span> root == p:</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        <span class="comment">#3.如果此时访问的节点root为指定节点q，那么返回q这个节点</span></span><br><span class="line">        <span class="keyword">if</span> root ==q:</span><br><span class="line">            <span class="keyword">return</span> q</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#4.经过1 2 3的判断，root这个节点必然不是p q None这三种情况的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#5.递归去查root的左子树，判断是否包含p q这两个指定节点</span></span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p,q)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#6.递归去查root的右子树，判断是否包含p q这两个指定节点</span></span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p,q)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#7.判断完root节点，root的左子树以及root的右子树，然后开始向父节点传递信息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#8.如果root节点的左子树left和右子树right都没有找到指定节点，</span></span><br><span class="line">        <span class="comment">#root本身也不是指定节点，</span></span><br><span class="line">        <span class="comment">#那父节点传递的信息就是以root为根节点的那颗二叉树没有指定节点p和q</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="comment">#告诉root的父节点，这里没有找到指定节点 p q</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#9.如果在root节点的左子树left中没有找到指定节点p q</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left:</span><br><span class="line">            <span class="comment">#返回right，告诉root的父节点，能不能找到指定节点p q，完全取决于right</span></span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line">        <span class="comment">#10.如果在root节点的右子树riight中没有找到指定节点p q</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="comment">#11.此时left不为空，right也不为空</span></span><br><span class="line">        <span class="comment">#此时以root节点为根节点的那颗二叉树中找找到了指定节点p ,也找到了指定节点q</span></span><br><span class="line">        <span class="comment">#此时就告诉父节点，root就是p q的最近公共祖先</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p><strong>leetcoad113-路径总和III（middle）</strong><br>leetcoad链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">https://leetcode-cn.com/problems/path-sum-ii/</a><br>视频链接：<a target="_blank" rel="noopener" href="https://www.algomooc.com/811.html">https://www.algomooc.com/811.html</a><br>要点：</p>
<ol>
<li>用一个栈来保存从叶子节点到根节点的路径</li>
<li>设置一个二维数组来保存满足条件的路径</li>
<li>定义一个value值，记录栈中所有节点值的总和（找到的符合条件的那个路径）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment">#构建一个value，用来计算当前路径下节点的总和</span></span><br><span class="line">        value= <span class="number">0</span></span><br><span class="line">        <span class="comment">#构建一个path，用来记录满足条件的路径</span></span><br><span class="line">        path = []</span><br><span class="line">        <span class="comment">#构建一个栈，用来保存当前路径下的节点</span></span><br><span class="line">        stack =[]</span><br><span class="line">        <span class="comment">#从根节点开始搜索所有的节点</span></span><br><span class="line">        self.search(root,value,targetSum,stack,path)</span><br><span class="line">        <span class="comment">#返回满足条件的路径</span></span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line"></span><br><span class="line">    <span class="comment">#node为正在遍历的节点</span></span><br><span class="line">    <span class="comment">#value为栈中各个节点的总和</span></span><br><span class="line">    <span class="comment">#targetSum为目标路径的和</span></span><br><span class="line">    <span class="comment">#stack为存储在该路径上的所有节点</span></span><br><span class="line">    <span class="comment">#path存储满足条件，即路径上各个节点之和为 targetSum的那些路径</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,node:TreeNode,value: <span class="built_in">int</span>,targetSum: <span class="built_in">int</span>,stack:[],path: []</span>):</span><br><span class="line">        <span class="comment">#如果节点为空，那么就不需要再访问下去了</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="comment">#将当前访问节点的值累加到value上去</span></span><br><span class="line">        value += node.val</span><br><span class="line">        <span class="comment">#把当前的节点值添加到栈中，栈中保存的就是从根节点到当前节点的路径</span></span><br><span class="line">        stack.append(node.val)</span><br><span class="line">        <span class="comment">#如果访问的节点是叶子节点（当前节点的左子树和右子树均为空）,并且当前路径下的节点之和value与目标值targetSum相等</span></span><br><span class="line">        <span class="comment">#说明找到了一条符合条件的路径的路</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> value == targetSum:</span><br><span class="line">        <span class="comment">#if node.left==0 and node.right ==0 and value == targetSum:</span></span><br><span class="line">            <span class="comment">#把这条路径添加到path中去</span></span><br><span class="line">            path.append(<span class="built_in">list</span>(stack))</span><br><span class="line">        <span class="comment">#继续递归的搜索当前节点node的左子树</span></span><br><span class="line">        self.search(node.left,value,targetSum,stack,path)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#继续递归的搜索当前节点node的右子树</span></span><br><span class="line">        self.search(node.right,value,targetSum,stack,path)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#搜索完当前节点的左右子树之后，当前节点已经完成了访问，需要返回到它的父节点</span></span><br><span class="line">        <span class="comment">#value值减去当前节点的值</span></span><br><span class="line">        value -=node.val</span><br><span class="line"></span><br><span class="line">        <span class="comment">#栈弹出当前的节点值</span></span><br><span class="line">        stack.pop()</span><br></pre></td></tr></table></figure>
<strong>leetcoad199-二叉树的右视图（middle）</strong><br>课程链接：<a target="_blank" rel="noopener" href="https://www.algomooc.com/817.html">https://www.algomooc.com/817.html</a><br>leetcoad链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">https://leetcode-cn.com/problems/binary-tree-right-side-view/</a><br>设置一个数组用来存储二叉树的右视图<br>借助队列来保存二叉树的每一层节点</li>
<li>第一层的节点是为1</li>
<li>弹出该节点</li>
<li>如果有左右子树，按照左右子树依次加入到队列当中</li>
<li>判断弹出的值是否能加入到结果数组中</li>
<li>队列的队首元素弹出<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]: </span><br><span class="line">        <span class="comment">#设置一个数组用来储存二叉树的右视图结果</span></span><br><span class="line">        arr =[]</span><br><span class="line">        <span class="comment">#设置一个队列，用来保存二叉树每一层的节点</span></span><br><span class="line">        queue=deque()</span><br><span class="line">        <span class="comment">#边界的判断</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        <span class="comment">#首先，把二叉树的根节点加入到队列中</span></span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="comment">#观察队列是否为空</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment">#1、获取队列的长度(代表二叉树中每一层的节点总数)</span></span><br><span class="line">            levelSize = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="comment">#2、通过一个循环，获取队列中每个节点的左右子树，把这些左右子树节点添加到队列中</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(levelSize):</span><br><span class="line">                <span class="comment">#3、弹出队列的队首元素</span></span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="comment">#4、判断弹出的节点是否有左子树</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    <span class="comment">#如果有左子树，把它加入到队列中</span></span><br><span class="line">                    queue.append(node.left)</span><br><span class="line"></span><br><span class="line">                <span class="comment">#5、判断弹出的节点是否有右子树</span></span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    <span class="comment">#如果有右子树，把它加入到队列中</span></span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">#对于每一层的二叉树的节点，我们是从左到右依次添加的，所以末尾的节点顺序是levelSize-1</span></span><br><span class="line">                <span class="comment">#6、这个末尾的节点就是这一层中最右侧的节点</span></span><br><span class="line">                <span class="keyword">if</span> i==levelSize - <span class="number">1</span>:</span><br><span class="line">                    <span class="comment">#把最右侧的节点值加入到结果中</span></span><br><span class="line">                    arr.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad114-二叉树展开为链表"><a href="#leetcoad114-二叉树展开为链表" class="headerlink" title="leetcoad114-二叉树展开为链表"></a>leetcoad114-二叉树展开为链表</h1><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：<br>    * 展开后的单链表应该<strong>同样使用 TreeNode</strong> ，其中 <strong>right 子指针</strong>指向链表中<strong>下一个结点</strong>，而<strong>左子指针</strong>始终为 <strong>null</strong> 。<br>    * <strong>展开后</strong>的单链表应该与二叉树 <strong>先序遍历 顺序相同</strong></p>
<p>自己感受：有点难!!!看看就行了，估计现在也弄不懂，不要浪费太多的时间，里面的思想还是得弄懂的。<br>需要注意的点有以下的几个地方：</p>
<ol>
<li>目的是要展开为<strong>单链表</strong>(仍然是一个<strong>树的结构</strong>，只是<strong>模拟</strong>成了<strong>单链表</strong>的结构)</li>
<li>右子指针指向下一个节点，左子指针指向为空</li>
<li>展开的顺序与<strong>先序遍历</strong>相同（那先序遍历的概念以及代码自然要十分的熟悉）</li>
<li>而且这类的转换应该挺有意义的，可以<strong>深刻的理解链表与二叉树之间的关系</strong>（本来自己之前就有过想一次性弄懂的想法）<br>几个规定：</li>
<li>left 为当前节点 node 的左子树</li>
<li>right 为当前节点 node 的右子树</li>
<li>leftTail 指向当前节点左子树 left <strong>转换为链表之后的尾节点</strong>，一开始默认为 None</li>
<li>rightTail 指向当前节点右子树 right <strong>转换为链表之后的尾节点</strong>，一开始默认为 None</li>
<li>tail 指向以当前节点 node 为根节点<strong>转换为链表之后的尾节点</strong>，一开始默认为 None</li>
</ol>
<p>简单的几个过程：<br><img src="https://runnerxr.github.io/post-images/1653615631632.jpg"></p>
<ol>
<li>首先找到根节点1</li>
<li>找到1的左子树的右节点：4</li>
<li>将5接到4的right节点上</li>
<li>将<strong>1的right指向2</strong></li>
<li>将1的left指向None</li>
<li>遍历节点2重复上面的过程</li>
<li>不停的遍历下去，直到遍历到最后的节点6，便可以拉直二叉树</li>
</ol>
<p> 思考的步骤如下：<br> <img src="https://runnerxr.github.io/post-images/1653616647010.png"><br> 具体的实施步骤有点细致</p>
<ol>
<li>设置几个指针：left、right 、leftTail 、rightTali 、tail，把左子树和右子树都转换为单链表的形式</li>
<li>先将 node 的左子树指针置空</li>
<li>如果当前节点<strong>存在左子树</strong>的时候，那么把<strong>左子树转换为链表</strong>的形式<ol>
<li>通过 backtrack 函数递归的把当前节点的左子树转换为链表</li>
<li>用left.Tail指向左子树的最后一个节点（左子树left转换为链表的形式）</li>
<li>将当前节点的<strong>node的right指针</strong>指向left（完成当前节点和左子树链表的拼接）</li>
<li>Tail指向左子树的最后一个节点（图解的过程就很清晰）</li>
</ol>
</li>
<li>如果当前节点<strong>存在右子树</strong>的时候，那么把<strong>右子树转换为链表</strong>的形式<ol>
<li>通过 backtrack 函数递归的把当前节点的右子树转换为链表</li>
<li>用right.Tail指向右子树的最后一个节点（右子树right转换为链表的形式）</li>
<li>把left链表和right链表串联起来（左子树存在的情况下，连接左右子树的链表）</li>
<li>Tail指向<strong>右子树的最后一个节点</strong></li>
</ol>
</li>
<li><strong>返回链表的尾节点</strong>继续去拼接<strong>其他的递归链表</strong></li>
</ol>
<p>把上面的步骤浓缩一下就是：（是一种原地修改的方式，不断地<strong>按照右子树地顺序</strong>去<strong>遍历</strong>给定的二叉树）</p>
<ol>
<li>将<strong>左</strong>子树<strong>插</strong>到<strong>右</strong>子树的地方（一遇到左子树就插入到节点与右子树之间）</li>
<li>将原来的<strong>右</strong>子树<strong>接</strong>到<strong>左</strong>子树的<strong>最右边节点</strong>(需要找到左子树最右边的节点，方便右子树拼接过来)</li>
<li>考虑<strong>新的右子树的根节点</strong>，一直重复上边的过程，直到新的右子树为None<br>相关代码：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="literal">None</span>: </span><br><span class="line">        self.backtrack(root) </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 传入二叉树的节点，把它转换为链表的形式，返回二叉树的尾节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self, node: TreeNode</span>) -&gt; TreeNode : </span><br><span class="line">        <span class="comment"># 1、如果 node 为空，返回 None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 2、如果 node 为叶子节点，返回 node</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 下面开始设置几个指针</span></span><br><span class="line">        <span class="comment"># 3、left 为当前节点 node 的左子树</span></span><br><span class="line">        left=node.left</span><br><span class="line">        <span class="comment"># 4、right 为当前节点 node 的右子树</span></span><br><span class="line">        right=node.right</span><br><span class="line">        <span class="comment"># 5、leftTail 指向当前节点左子树 left 转换为链表之后的尾节点，一开始默认为 None</span></span><br><span class="line">        leftTail=<span class="literal">None</span></span><br><span class="line">        <span class="comment"># 6、rightTail 指向当前节点右子树 right 转换为链表之后的尾节点，一开始默认为 None</span></span><br><span class="line">        rightTail=<span class="literal">None</span></span><br><span class="line">        <span class="comment"># 7、tail 指向以当前节点 node 为根节点转换为链表之后的尾节点，一开始默认为 None</span></span><br><span class="line">        tail=<span class="literal">None</span></span><br><span class="line">        <span class="comment"># 8、先将 node 的左子树指针置空</span></span><br><span class="line">        <span class="comment"># 将 node 的左子树转换为链表之后，node 的右指针指向那个链表</span></span><br><span class="line">        node.left=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 9、如果当前节点存在左子树的时候，那么把左子树转换为链表的形式</span></span><br><span class="line">        <span class="keyword">if</span> left!=<span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 通过 backtrack 函数递归的把当前节点的左子树转换为链表</span></span><br><span class="line">            <span class="comment"># backtrack 函数指向完之后，left 已经是链表</span></span><br><span class="line">            <span class="comment"># 根据第 5 点的代码，leftTail 指向左子树最后一个节点</span></span><br><span class="line">            leftTail=self.backtrack(left)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 此时，node 的左子树 left 已经是链表的形式</span></span><br><span class="line">            <span class="comment"># 那么将当前节点 node 的 right 指针指向 left，完成了当前节点和左子树链表的拼接</span></span><br><span class="line">            node.right=left</span><br><span class="line">            <span class="comment"># 根据第 7 ，tail 指向左子树最后一个节点</span></span><br><span class="line">            tail=leftTail</span><br><span class="line">        <span class="comment"># 10、如果当前节点存在右子树的时候，那么把右子树转换为链表的形式</span></span><br><span class="line">        <span class="keyword">if</span> right!=<span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 通过 backtrack 函数递归的把当前节点的右子树转换为链表</span></span><br><span class="line">            <span class="comment"># backtrack 函数指向完之后，right 已经是链表</span></span><br><span class="line">            <span class="comment"># 根据第 6 点的代码，rightTail 指向右子树最后一个节点</span></span><br><span class="line">            rightTail=self.backtrack(right) </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 此时，node 的右子树 right 已经是链表的形式</span></span><br><span class="line">            <span class="comment"># 如果当前节点 node 不存在左子树，那么 node.left = None</span></span><br><span class="line">            <span class="comment"># 由于 node 的右指针就是 right，所以不需要执行其它操作</span></span><br><span class="line">            <span class="comment"># 但如果存在左子树，就需要把 left 链表和 right 链表串联起来</span></span><br><span class="line">            <span class="comment"># 也就是把 left 链表的尾节点和 right 的头节点拼接起来</span></span><br><span class="line">            <span class="keyword">if</span> left!=<span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 将 leftTail 和 right 转换成的链表链接起来</span></span><br><span class="line">                leftTail.right=right</span><br><span class="line">            <span class="comment"># 如果存在右子树，那么根据第 7 点的代码，tail 指向右子树最后一个节点</span></span><br><span class="line">            tail=rightTail</span><br><span class="line">        <span class="keyword">return</span> tail</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad538-把二叉搜索树转换为累加树（middle）"><a href="#leetcoad538-把二叉搜索树转换为累加树（middle）" class="headerlink" title="leetcoad538-把二叉搜索树转换为累加树（middle）"></a>leetcoad538-把二叉搜索树转换为累加树（middle）</h1><p>题目描述：<br>给出二叉搜索树的<strong>根节点</strong>，该树的<strong>节点值各不相同</strong>，请你将其转换为<strong>累加树</strong>（Greater Sum Tree），使每个节点 node 的<strong>新值等于</strong>原树中<strong>大于或等于</strong> node.val 的值之和。<br>提醒一下，二叉搜索树满足下列约束条件：<br>    * 节点的<strong>左子树</strong>仅包含键 <strong>小于节点键</strong>的节点。<br>    * 节点的<strong>右子树</strong>仅包含键 <strong>大于节点键</strong>的节点。<br>    * 左右子树也必须是<strong>二叉搜索树</strong>。</p>
<p>题目中需要注意的点：</p>
<ol>
<li>本身是一个二叉搜索树（需要弄懂二叉搜索树的定义:也即题目中关于<strong>二叉搜索树的约束条件</strong>）</li>
<li>转换为累加树（累加树的定义）</li>
<li>有一个不好理解的地方：每个节点node的新值等于原树中大于或等于node.val的值之和(看了一遍题目仍然不能够好好的理解清楚)</li>
</ol>
<h1 id="leetcoad450-删除二叉搜索树中的节点"><a href="#leetcoad450-删除二叉搜索树中的节点" class="headerlink" title="leetcoad450-删除二叉搜索树中的节点"></a>leetcoad450-删除二叉搜索树中的节点</h1><p>给定一个二叉搜索树的<strong>根节点 root</strong> 和一个值 <strong>key</strong>，<strong>删除</strong>二叉搜索树中的** key 对应的节点<strong>，并保证二叉搜索树的</strong>性质不变**。返回二叉搜索树（有可能被更新）的根节点的引用。<br>一般来说，删除节点可分为两个步骤：<br>    * 首先找到需要删除的节点；<br>    * 如果找到了，删除它。</p>
<p>题目中需要注意的点如下：</p>
<ol>
<li>首先还是一个以二叉搜索树为原型的题目</li>
<li>需要从二叉树中删除一个key值并且要保证二叉树的性质不变（首先就得熟悉性质）</li>
<li>熟悉删除节点的步骤（虽然题目给了）</li>
<li>正确的解不止一个</li>
</ol>
<p><img src="https://runnerxr.github.io/post-images/1653580250146.png"><br>如何删除图中的元素2：</p>
<ol>
<li>以该<strong>节点作为根节点</strong>的右子树中最小的那个值<ol>
<li>不断地在右子树中去寻找它地左子树（是一个二叉搜索树，左子树是最小的，越往左的数是越小的，直到找到叶子节点为止）</li>
<li>3为找的，以2为根节点的右子树中最小的那个值</li>
<li>用3把该2覆盖，删除以前的3值</li>
<li>返回二叉搜索树的根节点</li>
</ol>
</li>
</ol>
<p><strong>归纳总结：</strong></p>
<ol>
<li>如果 root 为空，那么直接返回空</li>
<li>如果root 的节点值等于<strong>需要删除的值</strong>，那么需要根据以下几种情况进行处理<ol>
<li>情况一：当前节点的<strong>左子树为空</strong>，那么当前节点 root 由** root 的右子树占位**就行</li>
<li>情况二：当前节点的<strong>右子树为空</strong>，那么当前节点 root 由 <strong>root 的左子树占位</strong>就行</li>
<li>情况 三：被删除节点既有左子树，又有右子树<ol>
<li>需要找到<strong>右子树最小的值</strong>，或者<strong>左子树中最大的值</strong>（任选一种）</li>
<li>删除掉 root 的右子树最小的值</li>
</ol>
</li>
</ol>
</li>
<li>如果root 的节点值小于需要删除的值，那么就在 root 的右子树中去查找（可以采用第二种情况的方式删除）</li>
<li>如果 root 的节点值大于需要删除的值，那么就在 root 的左子树中去查找（可以采用第二种情况的方式删除）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1、如果 root 为空，那么直接返回空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root :</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2、如果 root 的节点值等于需要删除的值，那么需要根据以下几种情况进行处理</span></span><br><span class="line">        <span class="keyword">if</span> root.val == key :</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 情况 1：当前节点的左子树为空，那么当前节点 root 由 root 的右子树占位就行</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left:</span><br><span class="line">               <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="comment"># 情况 2：当前节点的右子树为空，那么当前节点 root 由 root 的左子树占位就行</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.right :</span><br><span class="line">               <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="comment"># 情况 3：被删除节点既有左子树，又有右子树</span></span><br><span class="line">            minNodeOfRight =  self.findMinNode(root.right)</span><br><span class="line">            <span class="comment"># 找到右子树最小的值之后，修改当前节点 root 的值为右子树最小的值</span></span><br><span class="line">            root.val = minNodeOfRight.val</span><br><span class="line">            <span class="comment"># 同时，记得删除掉 root 的右子树最小的值之</span></span><br><span class="line">            <span class="comment"># 删除操作就是以 root 的右子树作为根节点，key 为右子树最小的值进行删除</span></span><br><span class="line">            root.right =  self.deleteNode(root.right,minNodeOfRight.val)</span><br><span class="line"></span><br><span class="line">          <span class="comment"># 3、如果 root 的节点值小于需要删除的值，那么就在 root 的右子树中去查找</span></span><br><span class="line">        <span class="keyword">elif</span> root.val &lt; key :</span><br><span class="line">            <span class="comment"># 在 root 的右子树中去查找并删除 key </span></span><br><span class="line">            root.right =  self.deleteNode(root.right,key)</span><br><span class="line"></span><br><span class="line">          <span class="comment"># 4、如果 root 的节点值大于需要删除的值，那么就在 root 的左子树中去查找</span></span><br><span class="line">        <span class="keyword">elif</span> root.val &gt; key : </span><br><span class="line">            <span class="comment"># 在 root 的左子树中去查找并删除 key </span></span><br><span class="line">            root.left = self.deleteNode(root.left,key)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最后返回需要已经删除了 key 的二叉树的根节点</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过 findMinNode ，可以找到二叉搜索树中最小的元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMinNode</span>(<span class="params">self , node : TreeNode</span>) -&gt; TreeNode : </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 由于二叉搜索树，左子树所有元素的值都小于根节点的值</span></span><br><span class="line">        <span class="comment"># 所以可以不断的查找，直到为叶子节点，那么就找到了</span></span><br><span class="line">        <span class="keyword">while</span> node.left :</span><br><span class="line">            <span class="comment"># 不断的去查找当前节点的左子树</span></span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="comment"># 返回当前二叉搜索树中最小的元素</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad297-二叉树的序列化与反序列化"><a href="#leetcoad297-二叉树的序列化与反序列化" class="headerlink" title="leetcoad297-二叉树的序列化与反序列化"></a>leetcoad297-二叉树的序列化与反序列化</h1><p>暂时不做</p>
<h1 id="leetcoad222-完全二叉树的节点个数"><a href="#leetcoad222-完全二叉树的节点个数" class="headerlink" title="leetcoad222-完全二叉树的节点个数"></a>leetcoad222-完全二叉树的节点个数</h1><p>给你一棵 完全二叉树 的根节点 root ，<strong>求出该树的节点个数</strong>。<br>完全二叉树 的定义如下：在完全二叉树中，<strong>除了最底层节点可能没填满外</strong>，其余每层节点数都达到最大值，并且<strong>最下面一层</strong>的节点都集中在<strong>该层最左边的若干位置</strong>。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%B8%80/" data-id="claqu8zz4001fiwtk87d5hqh4" data-title="二叉树相关题目汇总一" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" rel="tag">算法专栏（用python注写）</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-动态规划算法合集（系列一）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%EF%BC%88%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2022-03-18T01:49:00.000Z" itemprop="datePublished">2022-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%EF%BC%88%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%89/">动态规划算法合集（系列一）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="基础知识铺垫"><a href="#基础知识铺垫" class="headerlink" title="基础知识铺垫"></a>基础知识铺垫</h1><p><strong>重新回顾分治法的主要思想：</strong></p>
<ol>
<li>divide:将大的问题分解为若干较小的问题</li>
<li>conquer:继续分解子问题，直到base case,直接求解</li>
<li>combine：层层合并子问题的解，直到得到原始大问题的解</li>
</ol>
<p><strong>对问题进行分析：</strong></p>
<ol>
<li>当子问题不关联、不重叠的时候，分治是一种较好的求解方法</li>
<li>当子问题重叠的时候，分治会造成计算资源的浪费</li>
<li>动态规划中每个子问题的求解只依赖于更小规模子问题的求解，由底向上</li>
<li>由此引发了最优化的问题：在一定条件下，寻找使得目标最优的解</li>
<li>本质：是一种以空间换时间的方式；递归+重叠子问题+最优子结构&#x3D;动态规划问题</li>
</ol>
<p><strong>卡尔的关于动态规划的讲解步骤：</strong></p>
<ol>
<li>dp数组以及下相应的下标</li>
<li>递推公式</li>
<li>dp数组如何进行初始化（比较讲究）</li>
<li>遍历顺序的重要性（从前到后以及从后到前）</li>
<li>打印dp数组（打印出来看是不是按照上面的逻辑来的）</li>
</ol>
<p><strong>三个主要的特征：</strong></p>
<ol>
<li>重叠子问题（因为核心是穷举，在穷尽的过程中就会出现重叠子问题的情况；用的原因：否则无法避开重复计算来提高计算效率）</li>
<li>最优子结构（一般形式是用来求解最值的问题，局部最优解可以决定或者逼近全局最优解；用的原因：否则无法设计递归求解）</li>
<li>状态转移方程</li>
</ol>
<p><strong>吴师兄+自己总结的思路（联系分治法的思路）：</strong></p>
<ol>
<li>将原问题（一个大的问题）分解为若干规模较小的问题</li>
<li>同时保存子问题的答案，使得每个问题只求解一次</li>
<li>最终获得原问题的答案</li>
</ol>
<p>三个步骤：</p>
<ol>
<li>确定dp数组的含义，dp里面包含了所有的子问题，dp[i]是一个解</li>
<li>寻找dp数组元素之间的联系，推导出dp[i]怎么来</li>
<li>确定dp数组的初始状态</li>
</ol>
<p>这里也给自己自己整理了一个模板出来了：（参考东哥的题解）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化状态</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...]=base <span class="keyword">case</span></span><br><span class="line"><span class="comment"># 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态一  <span class="keyword">in</span> 状态<span class="number">1</span>的所有值</span><br><span class="line">    <span class="keyword">for</span> 状态二  <span class="keyword">in</span> 状态<span class="number">2</span>的所有值</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态一][状态二][...] =求最值(选择<span class="number">1</span>，选择<span class="number">2</span>，选择<span class="number">3</span>)</span><br></pre></td></tr></table></figure>


<p>主要的几种题目类型：</p>
<ol>
<li>背包问题</li>
<li>打家劫舍问题</li>
<li>股票问题</li>
<li>子序列问题</li>
</ol>
<h1 id="背包问题："><a href="#背包问题：" class="headerlink" title="背包问题："></a>背包问题：</h1><p>主要有以下的几个类型：</p>
<ol>
<li>0-1背包问题 （**）</li>
<li>完全背包问题（**）</li>
<li>多重背包问题：每个物品的选择是有限制的</li>
<li>混合背包问题</li>
<li>二维费用的背包问题</li>
<li>分组背包问题</li>
<li>背包问题求方案数</li>
<li>求背包问题的方案</li>
<li>有依赖的背包问题</li>
</ol>
<p>目前自己就是完全掌握这<strong>两种情况</strong>就够了，其他的也没有时间再整理了，主要是要弄懂相应的物理模型。然后不同的题型可以套上去，这两种情况的逻辑要十分清晰，包括边界条件和状态转移方程，自己也要写一篇题解，出来，算是对自己所学的知识的一个巩固，不能流于表面，当成自己的模板来用才是硬道理。0-1背包问题和完全背包问题确实是最常见的背包问题，而且里面的思想本质上也是十分的灵活的，其实是很难掌握的一种类型，可能还是因为题目做的还是不够多的原因，有些题目其实根本看不出来就是背包问题的变形。<br>参考链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1K4411X766">https://www.bilibili.com/video/BV1K4411X766</a></p>
<h2 id="0-1背包问题（最基础的概念要牢牢掌握）"><a href="#0-1背包问题（最基础的概念要牢牢掌握）" class="headerlink" title="0-1背包问题（最基础的概念要牢牢掌握）"></a>0-1背包问题（最基础的概念要牢牢掌握）</h2><p><strong>一件物品要么选要么不选</strong><br>看到B站上有一个讲的虽然简单，但是把底层的一些原理算是讲清楚了。<br><img src="https://runnerxr.github.io/post-images/1651162537918.png"></p>
<ol>
<li>当前物品是否能够装入背包：物品的体积小于等于背包容量才能够装进去</li>
<li><strong>能够装下的情况</strong>：不装当前物品，还有就是装当前物品<ol>
<li>不装的话，就是选前面的物品，<strong>前n个物品的最佳组合和前n-1个物品的最佳组合是一样的</strong></li>
<li>装的话，<strong>在预留装这个物品的空间的情况之下</strong>，前n-1个物品的最佳组合+当前物品的价值就是总的价值</li>
<li>在这两种情况中<strong>选取最大的一种情况</strong>：为当前最佳组合的价值</li>
</ol>
</li>
<li>如果装不下当前的物品：前n个物品的最佳组合和前n-1个物品的最佳组合是一样的</li>
</ol>
<p>问题进阶：在使得背包内总价值最大的情况下，<strong>背包内装了哪些物品</strong>(这里是一个理解的过程：找到到底是装了哪些编号的物品，使得背包的总价值最大！！！)<br><strong>归纳：</strong>从表的右下角开始回溯（从后往前看），如果发现前n个物品最佳组合的价值和前n-1个物品最佳组合的价值是一眼的，说明第n个物品没有被装入，否则，第n个物品被装入。<br>这里举了一个例子，以右下角为例：<br><img src="https://runnerxr.github.io/post-images/1652243232072.png"></p>
<ol>
<li>当前的是前4个物品，所能装的物品的最大价值为10</li>
<li>现在看第4个物品有没有被装入，如果没有被装入的话，那么它应该和前3个物品背包所能装的最大价值一致</li>
<li>但是我们通过表格发现1个是9，一个是10，说明4号物品被装进了背包</li>
<li>既然4号物品被装进了背包，空间由8变为3去装其他物品，现在问题转化为考虑前三个物品且背包容量为3的情况下所能够装的最大价值</li>
<li>3号物品到底有没有被装进去，如果3号没有被装入，也即考虑前3个物品和考虑前2个物品的是一样的，看表发现确实是一样的，说明3号物品确实没有被装入进去。依次类推，2号物品被装入，1号物品没有装入。<br>dp[i][j]:表示前i个物品，背包重量为j的情况下能够装的最大价值，其中并不是表示要将i个物品全部装入，而是i个物品满足装入背包条件下的最大价值。<br>dp[i][j] &#x3D; max(dp[i-1][j] ,dp[i-1][j-w[i]] +v[i])<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 物品的重量</span></span><br><span class="line">W=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 物品的价值</span></span><br><span class="line">V=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment"># 物品编号和背包容量</span></span><br><span class="line">m,n=<span class="number">4</span>,<span class="number">8</span></span><br><span class="line"><span class="comment"># 创建dp数组</span></span><br><span class="line">dp=[[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line"><span class="comment"># 注意边界条件，创建数组的时候处理过了</span></span><br><span class="line"><span class="comment">#print(dp)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 如果发现背包的容量小于当前物品的重量</span></span><br><span class="line">        <span class="comment"># 和放入i-1个物品的情况相同</span></span><br><span class="line">        <span class="keyword">if</span> j &lt;W[i-<span class="number">1</span>]:</span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j]</span><br><span class="line">            <span class="comment">#print(dp[i][j])</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-W[i-<span class="number">1</span>]]+V[i-<span class="number">1</span>])</span><br><span class="line">            <span class="comment">#print(dp[i][j])</span></span><br><span class="line"><span class="comment">#print(dp)</span></span><br><span class="line"><span class="built_in">print</span>(dp[m][n])</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="完全背包问题：每件物品可以选无限次（只要背包容量够）"><a href="#完全背包问题：每件物品可以选无限次（只要背包容量够）" class="headerlink" title="完全背包问题：每件物品可以选无限次（只要背包容量够）"></a>完全背包问题：<strong>每件物品可以选无限次（只要背包容量够）</strong></h2><p>一个容量为m的背包，现在有n种物品，每种物品有无限多件，他们的重量分别为Wi(1&lt;&#x3D;i&lt;&#x3D;n),他们的价值为Vi(1&lt;&#x3D;i&lt;&#x3D;n),求能放入背包的最大价值？<br>最大价值是物品数量i和背包容量j的函数，f[i][j]表示考虑前i件物品放入容量为j的背包下的最大价值，<strong>最终的最大价值就是物品数量i从0<del>n,背包容量j从0</del>m时的f[m][n]</strong><br>当前背包容量为j我们要考虑第i件物品能否放入？是否一定要放入？</p>
<ol>
<li>不能放入:f[i][j]&#x3D;f[i-1][j]</li>
<li>能放入，但是要比较代价<ol>
<li>若第i件不放入背包：f[i][j]&#x3D;f[i-1][j]</li>
<li>第i件物品放入背包：f[i][j]&#x3D;f[i][j-W[i]]+V[i]<br>对于前i件物品，<strong>背包容量为j-W[i]时可能已经放入了第i件物品，容量为j时还可以再放入第i件物品</strong>，用f[i][j-W[i]]更新f[i][j]<br>即要是从上一行同列的单元格直接复制过来的(不放入第件物品)，要么从同行单元格某一列的单元格+W[i]<br><strong>得出相应的状态转移方程：</strong><br>f[i][j] &#x3D; f[i-1][j]  （j&lt;W[i]）<br>f[i][j] &#x3D; max(f[i-1][j] , f[i][j-W[i]]+V[i])  （j&gt;&#x3D;W[i]）<br>同样的例子，这里的完全背包的话：<br><img src="https://runnerxr.github.io/post-images/1652249143427.png"><br>在表中带颜色的区域，表示此时的背包是可以容纳第i件物品，我可以选或者不选第i件物品<br>以前2个物品，容量为5的这个例子来理解，当前是能够被装入的：</li>
</ol>
</li>
<li>如果不让第i个物品装入，那么最大价值就是上面过来的6</li>
<li>如果让第i个物品装入，那么将空间由5–&gt;2此时，此时看前i物品（第i件物品仍然可以再次被选中），在背包容量为2的情况下的最大价值，通过查表我们我们可以看到此时最大价值为3，加上装入的4，总共的最大价值为4+3&#x3D;7<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 附上相应的代码进行理解</span></span><br><span class="line"><span class="comment"># 物品的重量</span></span><br><span class="line">W=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 物品的价值</span></span><br><span class="line">V=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment"># 物品编号和背包容量</span></span><br><span class="line">m,n=<span class="number">4</span>,<span class="number">8</span></span><br><span class="line"><span class="comment"># 创建dp数组</span></span><br><span class="line">dp=[[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line"><span class="comment"># 注意边界条件，创建数组的时候处理过了</span></span><br><span class="line"><span class="comment">#print(dp)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 如果发现背包的容量小于当前物品的重量</span></span><br><span class="line">        <span class="comment"># 和放入i-1个物品的情况相同</span></span><br><span class="line">        <span class="keyword">if</span> j &lt;W[i-<span class="number">1</span>]:</span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j]</span><br><span class="line">            <span class="comment">#print(dp[i][j])</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][j],dp[i][j-W[i-<span class="number">1</span>]]+V[i-<span class="number">1</span>])</span><br><span class="line">            <span class="comment">#print(dp[i][j])</span></span><br><span class="line"><span class="comment"># print(dp)</span></span><br><span class="line"><span class="built_in">print</span>(dp[m][n])</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以下是主要的一些题目：</p>
<ol>
<li>leetcoad509-斐波那契数列</li>
<li>leetcoad322-零钱兑换的问题</li>
<li>leetcoad518-零钱兑换II</li>
<li>leetcoad53-最大子数组和</li>
<li>leetcoad64-最小路径和</li>
<li>leetcoad72-编辑距离</li>
<li>leetcoad494-目标和</li>
<li>买卖股票系类问题（其实这个系列的问题挺难想到的）<ol>
<li>leetcode121-买卖股票的最佳时期</li>
<li>leetcode122-买卖股票的最佳时期II</li>
<li>leetcode123-买卖股票的最佳时期III</li>
<li>leetcode309-最佳买卖股票时机含冷冻期（含有交易冷冻期）</li>
<li>leetcod714-买卖股票的最佳时期含手续费（每次交易含手续费）</li>
</ol>
</li>
</ol>
<h1 id="leetcoad509-斐波那契数列-easy"><a href="#leetcoad509-斐波那契数列-easy" class="headerlink" title="leetcoad509-斐波那契数列(easy)"></a>leetcoad509-斐波那契数列(easy)</h1><p>题目回顾：斐波那契数列的是这样一个数列：1、1、2、3、5、8、13、21、34….，即第一项 f(1) &#x3D; 1,第二项 f(2) &#x3D; 1…..,第 n 项目为 f(n) &#x3D; f(n-1) + f(n-2)。求第 n 项的值是多少？<br>这道题也是非常的经典，有助于自己理解很多的问题，从这道题上面挖掘出一些有用的东西出来才是关键的地方。分采用了三种方法（包含优化的过程）：</p>
<ol>
<li>暴力递归法</li>
<li>带备忘录递归写法</li>
<li>动态规划的迭代写法（存储所有的状态）</li>
<li>优化动态规划的写法（只储存前两个状态进行滚动）<br><strong>暴力递归法</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Fibonacci</span>(<span class="params">self , n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n ==<span class="number">1</span> <span class="keyword">or</span> n ==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 围绕这个数学表达式的形式</span></span><br><span class="line">            <span class="keyword">return</span> self.Fibonacci(n -<span class="number">1</span>) + self.Fibonacci(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
参考链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fibonacci-number/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-labuladong/">https://leetcode-cn.com/problems/fibonacci-number/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-labuladong/</a><br>解法的弊端：<br>时间复杂度：子问题个数x解决子问题需要的时间&#x3D;O(2^n) xO(1) &#x3D;O(2^n)<br>低效的原因：存在太多重复计算的问题</li>
</ol>
<p><strong>采用带备忘录的递归写法（记忆化备忘录）</strong><br>采用带备忘录的递归写法(至顶向下)：<br>每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。<br><img src="https://runnerxr.github.io/post-images/1648520653749.jpg"><br><img src="https://runnerxr.github.io/post-images/1648520677848.jpg"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间复杂度大大降低</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        memo = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> Solution.helper(memo, n) </span><br><span class="line">    <span class="comment"># 进行带备忘录的递归</span></span><br><span class="line">    <span class="comment"># 把一颗存在巨量冗余的递归树通过剪枝，改造成一幅不存在冗余的递归树，极大的减少子问题（递归图中节点）的个数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">memo:<span class="built_in">list</span>, n:<span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n ==<span class="number">1</span> <span class="keyword">or</span> n ==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">        <span class="keyword">if</span> memo[n] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> memo[n]</span><br><span class="line">        memo[n] = Solution.helper(memo, n - <span class="number">1</span>) + Solution.helper(memo, n - <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br></pre></td></tr></table></figure>
<p><strong>dp数组的迭代写法</strong><br>状态转移方程是解决问题的核心，状态转移方程是直接代表着暴力解法的，只要能够写出暴力解法，优化方法就是用备忘录或者DPtable来解决的。<br>把备忘录独立出来一张表<br><img src="https://runnerxr.github.io/post-images/1649599396610.jpg"><br>这个dp表像之前剪枝的结果，但是是反过来的，本质上差不多，所以在效率上也就差不多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp =[<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 这里需要加入if elif语句表明递归的出口</span></span><br><span class="line">        <span class="comment">#if not n:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#第2个判断语句也可以用if来写，只要不与上一个发生冲突就行</span></span><br><span class="line">        <span class="comment"># if n in [1,2]:</span></span><br><span class="line">        <span class="comment">#   return 1</span></span><br><span class="line">        <span class="keyword">elif</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>]=dp[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 围绕这个数学表达式的形式</span></span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<p><strong>优化dp动态规划</strong><br>状态压缩，每次状态转移只需要DP table中的一部分，只记录必要的数据，当前状态只和之前的两个状态有关，不需要dp表来存储所有的状态，想办法只存储之前的两个状态（把DP table的大小从n缩小到2），将空间复杂度从O(N)降低到O(1)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Fibonacci</span>(<span class="params">self , n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n ==<span class="number">1</span> <span class="keyword">or</span> n ==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        prev,curr = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 记录前两个状态的和</span></span><br><span class="line">            <span class="built_in">sum</span> = prev + curr</span><br><span class="line">            <span class="comment">#不断的向前滚动这两个状态</span></span><br><span class="line">            prev = curr</span><br><span class="line">            curr = <span class="built_in">sum</span></span><br><span class="line">        <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure>
<p>附上另一个大佬的版本(运用了python的语法)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Fibonacci</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="comment"># 这里的f就是类似于一个dp表格，用来记录加和的值，值得最后的一个值就是最终的结果</span></span><br><span class="line">        f = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">        i=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=n):</span><br><span class="line">            f.append(f[i-<span class="number">1</span>]+f[i-<span class="number">2</span>])</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure>
<h1 id="leetcoad322-零钱兑换的问题-middle"><a href="#leetcoad322-零钱兑换的问题-middle" class="headerlink" title="leetcoad322-零钱兑换的问题(middle)"></a>leetcoad322-零钱兑换的问题(middle)</h1><p>把题目在好好的梳理一遍：给你一个整数数组coins，<strong>表示不同面额的硬币</strong>，以及一个整数amount,表示总金额，<strong>计算并返回可以凑成总金额所需的最少的硬币的个数</strong>，如果<strong>没有任何一种硬币的组合能组成总金额，返回-1</strong>，你可以认为<strong>每一种硬币的数量是无限的</strong>。</p>
<p>看评论区的方法：方法很多，有背包(动态规划)、深度遍历（dfs）、广度遍历（bfs）、暴力递归的方式<br>这个问题是动态规划问题，因为它具有「最优子结构」的。要符合「最优子结构」，子问题间必须互相独立。<br>思考如何列出正确的状态转移方程：</p>
<ol>
<li>确定base case:</li>
<li>确定状态：原问题和子问题中会变化的变量，只有目标金额会不断的向base靠近，唯一的状态就是目标金额</li>
<li>确定选择：导致状态产生变化的行为，目标金额在变是因为在选择硬币，<strong>每选择一次硬币，就减少了目标金额</strong></li>
<li>明确dp函数&#x2F;数组的定义：<strong>输入一个目标金额n,返回凑出目标金额n的最少硬币数量</strong></li>
</ol>
<p>如果是采用暴力的方式：这种写法是超时的，也是需要消除重叠子问题的问题<br>时间复杂度分析：子问题总数 x每个子问题的时间&#x3D;O(n^k)[递归树的结点总数] xO(k)[每个子问题都含有一个for循环]&#x3D;O(k*n^k)[指数级别的]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="comment"># 确定边界条条件</span></span><br><span class="line">        <span class="comment">#目标金额为0，需要0,目标金额为负的时候，返回-1</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> n &lt; <span class="number">0</span>: </span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="comment"># 求最小值，所以初始化为正无穷</span></span><br><span class="line">            res = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">                subproblem = dp(n - coin)</span><br><span class="line">                <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">                <span class="keyword">if</span> subproblem == -<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                res = <span class="built_in">min</span>(res, <span class="number">1</span> + subproblem)</span><br><span class="line">                <span class="keyword">return</span> res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp(amount)</span><br><span class="line">                <span class="comment">#下面的5行代码可以通过简化的上面的2行代码来写</span></span><br><span class="line">            <span class="comment"># if res != float(&#x27;INF&#x27;) :</span></span><br><span class="line">            <span class="comment">#     return res</span></span><br><span class="line">            <span class="comment"># else:</span></span><br><span class="line">            <span class="comment">#     return -1</span></span><br><span class="line">        <span class="comment"># return dp(amount)</span></span><br></pre></td></tr></table></figure>
<p><strong>带备忘录的递归（至顶向下相除重叠问题）</strong><br>子问题总数：小于n，是O(n)级别的<br>处理一个子问题的时间：O(k)<br>总的时间复杂度：O(nk)<br>现在就要通过备忘录的方式消除一部分重叠子问题（代码不一定是最好的模板，但是分析的思路是很好的，值得学习）：<br><img src="https://runnerxr.github.io/post-images/1649601266089.jpg"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMoney</span>(<span class="params">self , arr: <span class="type">List</span>[<span class="built_in">int</span>], aim: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#备忘录</span></span><br><span class="line">        memo = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">n</span>):</span><br><span class="line">            <span class="comment">#查备忘录避免重复计算</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> memo:</span><br><span class="line">                <span class="keyword">return</span> memo[n]</span><br><span class="line">            <span class="comment"># 确定边界条条件</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> n &lt; <span class="number">0</span>: </span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="comment"># 求最小值，所以初始化为正无穷</span></span><br><span class="line">            res = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> arr:</span><br><span class="line">                subproblem = dp(n - coin)</span><br><span class="line">                <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">                <span class="keyword">if</span> subproblem == -<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                res = <span class="built_in">min</span>(res, <span class="number">1</span> + subproblem)</span><br><span class="line">                </span><br><span class="line">            <span class="comment">#记入备忘录</span></span><br><span class="line">            memo[n] = res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> memo[n]</span><br><span class="line">        <span class="keyword">return</span> dp(aim)</span><br></pre></td></tr></table></figure>
<p><strong>通过dp数组的迭代写法（至底向上相除重叠问题）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略（采用吴师兄的写法比较好理解）</span><br></pre></td></tr></table></figure>
<p>总结：只要通过状态转移方程写出暴力递归写法，剩下的就是优化递归树，消除重叠子问题<br>解决问题：穷举，穷举所有的可能性，算法设计就是先思考“如何穷举”，然后再追求如何聪明的穷举<br>列出动态转移方程就是解决“如何穷举的问题”<br>归纳出相应的状态转移方程：<br><img src="https://runnerxr.github.io/post-images/1649601142486.png"><br>难点：</p>
<ul>
<li>穷举需要递归实现</li>
<li>有的问题本身的解空间复杂，不那么容易穷举完整</li>
<li>备忘录和dp table就是在追求“如何聪明穷举”，用空间换时间的思路，以此来降低时间复杂度</li>
</ul>
<p><strong>采用吴师兄的解法思路如下（保姆式）：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化数组 dp，长度为 amount + 1，因为在 dp 数组中还会存储金额为 0 的情况</span></span><br><span class="line">        <span class="comment"># 首先将数组 dp 里面的值都初始化为 -1（一种做题的方式，比如上面用的是正无穷）</span></span><br><span class="line">        <span class="comment"># -1 表示当前的金额还没有找到需要的最少硬币个数</span></span><br><span class="line">        <span class="comment"># dp[i]的含义：当目标金额为i时，至少需要dp[i]枚硬币凑出</span></span><br><span class="line">        dp = [-<span class="number">1</span>]*(amount +<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 想要凑齐 0 元的最少硬币个数是 0 个</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 依次计算想要凑齐 1 元到 amount 的最少硬币个数是多少</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,amount+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 对于每个金额 i 来说，coins 中的每个面值小于 i 的硬币都可以尝试去拼凑 i</span></span><br><span class="line">            <span class="comment"># 比如 i = 8 ，coins 为 [1,2,5,7,10]</span></span><br><span class="line">            <span class="comment"># 其中 1，2，5，7 都小于 8</span></span><br><span class="line">            <span class="comment"># 1 可以尝试去拼凑 8</span></span><br><span class="line">            <span class="comment"># 2 可以尝试去拼凑 8</span></span><br><span class="line">            <span class="comment"># 5 可以尝试去拼凑 8</span></span><br><span class="line">            <span class="comment"># 7 可以尝试去拼凑 8</span></span><br><span class="line">            <span class="comment"># 所以，设置一个变量 j ，遍历数组 coins</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(coins)):</span><br><span class="line">                <span class="comment"># 1、如果当前的硬币面值 coins[j] 小于了 i，表示这枚硬币有可能可以拼凑到 i</span></span><br><span class="line">                <span class="comment"># 2、那么 i - coins[j] 表示面值 coins[j] 的硬币想要拼凑 i 需要那些面值的硬币金额</span></span><br><span class="line">                <span class="comment"># 3、而 dp[i-coins[j]] 表示想要凑齐 i - coins[j] 元需要的最少硬币个数</span></span><br><span class="line">                <span class="comment"># 4、如果 dp[i-coins[j]] != -1 ，表示想要凑齐 i - coins[j] 元需要的最少硬币个数有结果</span></span><br><span class="line">                <span class="comment">#if dp[i-coins[j]] != -1 and coins[j] &lt;=i:这里的这种写法是存在问题的，只有在coin[j] &lt;=i满足的情况下才会去判断dp[i-coins[j]]!=-1的情况，不能够颠倒</span></span><br><span class="line">                <span class="keyword">if</span> coins[j] &lt;=i <span class="keyword">and</span> dp[i-coins[j]] != -<span class="number">1</span> :  </span><br><span class="line">                    <span class="comment"># 这个时候，对于金额 i 来说</span></span><br><span class="line">                    <span class="comment"># 1、如果它之前还没有找到凑齐 i 元需要的最少硬币个数</span></span><br><span class="line">                    <span class="comment"># 2、如果此时计算的最少硬币个数比之前保存的结果 dp[i] 更小</span></span><br><span class="line">                    <span class="comment"># 那么更新 dp[i]</span></span><br><span class="line">                    <span class="keyword">if</span> dp[i]==-<span class="number">1</span> <span class="keyword">or</span> dp[i] &gt;dp[i-coins[j]] +<span class="number">1</span>:</span><br><span class="line">                        <span class="comment"># 更新 dp[i]</span></span><br><span class="line">                        <span class="comment"># dp[i] 表示想要凑齐 i 元需要的最少硬币个数</span></span><br><span class="line">                        <span class="comment"># 这个时候 dp[i] 为获取面值为 j 的那 1 个硬币</span></span><br><span class="line">                        <span class="comment"># 加上获取面值为 i - coins[j] 最少需要 dp[i - coins[j]] 个硬币</span></span><br><span class="line">                        dp[i] = dp[i-coins[j]] +<span class="number">1</span></span><br><span class="line">        <span class="comment"># dp[amount] 表示想要凑齐 amount 元需要的最少硬币个数</span></span><br><span class="line">        <span class="comment"># 返回这个结果就行</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br></pre></td></tr></table></figure>
<p>精简版(其实最后写出来就只有几行代码，难的是里面的思想)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [-<span class="number">1</span>]*(amount +<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,amount+<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(coins)):</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> coins[j] &lt;=i <span class="keyword">and</span> dp[i-coins[j]] != -<span class="number">1</span> :  </span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> dp[i]==-<span class="number">1</span> <span class="keyword">or</span> dp[i] &gt;dp[i-coins[j]] +<span class="number">1</span>:</span><br><span class="line">                        dp[i] = dp[i-coins[j]] +<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br></pre></td></tr></table></figure>
<p>后面自己又做了一遍，发现这个问题在当时只是熟悉了一下做题的套路，等再次来看这道题的时候，还是很懵，所以<strong>没办法就只能死磕</strong>，把这个问题给整理清楚，发现每次写的还都不一样，也许就是这些题目比较经典的原因，<strong>需要反反复复的去做，才能体会里面的一些精髓所在</strong>:<br>以下为自己后来又实现代码的过程，同时自己也实地的用excel做了一份用于自己的理解的过程：<br><img src="https://runnerxr.github.io/post-images/1652280775207.png"><br>以其中的一个值为例子来理解这个表，dp[1][4]这个位置，表示此时的硬币值为1，金额为4，可以进行找零过程（我用箭头标注的这个过程就是十分标准的完全背包的过程）</p>
<ol>
<li>如果不选第i枚硬币的话，dp[0][4]&#x3D;12，</li>
<li>在选第i枚硬币的情况下dp[1][4]&#x3D;dp[1][4-1]+1&#x3D;dp[1][3]+1&#x3D;4,取两种情况下的最小值4为此时的最小硬币的数量。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n=<span class="built_in">len</span>(coins)</span><br><span class="line">        <span class="comment"># 构建dp数组，dp[i][j]表示选择前i种硬币能凑齐j元需要的最少的硬币的数量</span></span><br><span class="line">        <span class="comment"># 这里一定是有硬币的，所以在构建dp数组的时候需要注意,初始化为一个较大的值+inf或者是amount+1</span></span><br><span class="line">        dp=[[amount+<span class="number">1</span>]*(amount+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 设置初始条件：需要找零的金额为0的时候，所需要的硬币是为0的</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 第一层循环遍历硬币</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 第二层循环遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 采用完全背包的思路</span></span><br><span class="line">                <span class="comment"># 如果当前的硬币面值大于要凑成的金额，没有办法参与找零（容量有限，无法选择第i种硬币），直接copy值下来</span></span><br><span class="line">                <span class="keyword">if</span> j&lt;coins[i-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="comment"># 当当前的硬币值小于要凑成的金额的时候，这个时候才是可以参与找零的过程</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 有两种选择的方案（十分标准的完全背包的套路问题）</span></span><br><span class="line">                    <span class="comment"># 一种是选用该硬币，看看硬币能否凑成amount-nums[i],dp[i][j]=dp[i][j-coins[i-1]]+1</span></span><br><span class="line">                    <span class="comment"># 第二种是，不选用该硬币，直接用前面的硬币来组成：dp[i][j]=p[i-1][j]</span></span><br><span class="line">                    <span class="comment"># 取两种结果的最小值作为</span></span><br><span class="line">                    dp[i][j]=<span class="built_in">min</span>(dp[i-<span class="number">1</span>][j],dp[i][j-coins[i-<span class="number">1</span>]]+<span class="number">1</span>)</span><br><span class="line">        res=dp[n][amount]</span><br><span class="line">        <span class="comment"># 还用进行最后的判断，对于没有任何一种硬币能够组成的情况，直接返回-1，也就是之前自己设置的amount+1的情况</span></span><br><span class="line">        <span class="keyword">if</span> res!=amount+<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad518-零钱兑换II-middle"><a href="#leetcoad518-零钱兑换II-middle" class="headerlink" title="leetcoad518-零钱兑换II(middle)"></a>leetcoad518-零钱兑换II(middle)</h1><p>先对题目进行解析：给一个整数数组coins表示<strong>不同面额的硬币</strong>，另给一个整数<strong>amount表示总金额</strong>，计算并返回<strong>可以凑成总金额的硬币组合数</strong>，如果任何的硬币组合数都无法凑出总金额，<strong>返回0</strong>，<strong>假设每一种面额的硬币有无限个</strong>，数据结果符合32位带符合整数。<br>与上一题的区别：计算凑成总金额的<strong>最小硬币的数量</strong><br>本题：凑成硬币的<strong>组合数的情况</strong><br>对于第0行和第0列的情况来分析，没有硬币的时候无法找零，所以所有的第0行的的组合数为0，第0列表示，在需要找零为0的情况的硬币的组合情况，<strong>如果要用到当前的硬币作为组合的话，它的起始条件就是1</strong>（这有点不是特别的好想），真正难的还是它的状态转移方程，<strong>和纯完全背包又不太一样，强调的是组合数</strong><br>用下面的这张图来辅助理解完全背包的问题，可以说再次回顾的时候还是发现了很多的细节的，也加深对这道题的理解，透过这道题进行相应的发散才是最关键的问题。<br><img src="https://runnerxr.github.io/post-images/1654617289325.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n=<span class="built_in">len</span>(coins)</span><br><span class="line">        <span class="comment"># 构建dp数组并明确dp数组的函数，选用前i个种类的硬币在凑齐金额为j的情况下的组合数</span></span><br><span class="line">        dp=[[<span class="number">0</span>]*(amount+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 把第0列的情况更改为1,表示直接不需要任何面值，可以把情况记录为1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[j][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 采用完全背包的思路来解题</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,amount+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 如果发现当前的硬币值大虚需要找零的金额的时候，无法进行找零，组合数为上一行复制过来的</span></span><br><span class="line">                <span class="keyword">if</span> coins[i-<span class="number">1</span>] &gt;j:</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="comment"># 如果发现能够进行相应的找零，需要分两种情况</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 情况一：不选用第i枚硬币，此时dp[i][j]=dp[i-1][j]</span></span><br><span class="line">                    <span class="comment"># 请款二：选用第i枚硬币的情况,此时dp[i][j]=dp[i][j-coins[i]]</span></span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-coins[i-<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">return</span> dp[n][amount]</span><br></pre></td></tr></table></figure>


<h1 id="leetcoad53-最大子数组和"><a href="#leetcoad53-最大子数组和" class="headerlink" title="leetcoad53-最大子数组和"></a>leetcoad53-最大子数组和</h1><p>弄清楚连续子数组的定义<br>弄清楚dp[i]的含义：表示以第i个元素结尾的最大子数组的和（肯定是以第i个元素进行结尾，但是不一定包括前面所有的数）<br>最后返回dp数组中最大的那个数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 因为后面会使用到 nums 的长度</span></span><br><span class="line">        <span class="comment"># 所以先进行判空操作</span></span><br><span class="line">        <span class="comment"># 如果数组 nums 为空，返回 0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="comment">#if len(nums)==0:</span></span><br><span class="line">        <span class="comment">#if nums is None:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment"># 获取数组的长度</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 设置一个数组 dp，长度和数组 nums 长度一致</span></span><br><span class="line">        <span class="comment"># dp[0] 表示以第 0 个元素结尾的最大子数组的和</span></span><br><span class="line">        <span class="comment"># dp[1] 表示以第 1 个元素结尾的最大子数组的和</span></span><br><span class="line">        <span class="comment"># dp[i] 表示以第 i 个元素结尾的最大子数组的和</span></span><br><span class="line">        dp =[<span class="number">0</span>]*n</span><br><span class="line">        <span class="comment">#dp =[0 for _ in range(n)]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp[0] 表示以第 0 个元素结尾的最大子数组的和</span></span><br><span class="line">        <span class="comment"># 初始化 dp[0]</span></span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 变量 maxNum 表示数组 dp 中最大的那个值</span></span><br><span class="line">        <span class="comment"># 即 maxNum 表示最大的连续字段和</span></span><br><span class="line">        maxNum=dp[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从 1 开始遍历数组 nums</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 在遍历的过程中，去获取以第 i 个元素结尾的最大子数组的和</span></span><br><span class="line">            <span class="comment"># 如果以 nums[i-1]结尾的最大字段和为正数</span></span><br><span class="line">            <span class="comment"># 那么以第 i 个元素结尾的最大子数组的和就是自己本身加上以 nums[i-1]结尾的最大字段和</span></span><br><span class="line">            <span class="keyword">if</span> dp[i-<span class="number">1</span>]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="comment"># dp[i-1] 是正数</span></span><br><span class="line">                <span class="comment"># 所以 dp[i] 的值为 nums[i] 加上 dp[i-1]</span></span><br><span class="line">                <span class="comment"># 因为 正数 + 变量 &gt; 变量</span></span><br><span class="line">                <span class="comment"># dp[i -1] + nums[i] &gt; nums[i]</span></span><br><span class="line">                dp[i]=dp[i-<span class="number">1</span>]+nums[i]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 否则 dp[i-1] 不是正数，为负数或者 0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 那么 dp[i] 的值为 nums[i]</span></span><br><span class="line">                <span class="comment"># 因为 负数 + 变量 &lt; 变量</span></span><br><span class="line">                <span class="comment"># dp[i -1] + nums[i] &lt; nums[i]</span></span><br><span class="line">                dp[i]=nums[i]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 在更新 dp[i] 的过程中，更新 maxNum 的值</span></span><br><span class="line">            <span class="comment"># 如果此时 dp[i] 的值大于了 maxNum</span></span><br><span class="line">            <span class="keyword">if</span> dp[i]&gt;maxNum:</span><br><span class="line">                <span class="comment"># 那么 maxNum 更新为 dp[i]</span></span><br><span class="line">                maxNum=dp[i]</span><br><span class="line">        <span class="comment"># 最后返回 maxNum</span></span><br><span class="line">        <span class="keyword">return</span> maxNum</span><br></pre></td></tr></table></figure>
<h1 id="leetcoad64-最小路径和-middle"><a href="#leetcoad64-最小路径和-middle" class="headerlink" title="leetcoad64-最小路径和(middle)"></a>leetcoad64-最小路径和(middle)</h1><p>解题的关键：<br>对于不在第一行和第一列的元素，可以从其上方相邻元素向下移动一步到达，或者从其左方相邻元素向右移动一步到达，元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。由于每个元素对应的最小路径和与其相邻元素对应的最小路径和有关，因此可以使用动态规划求解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minPathSum</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># m 表示有多少行</span></span><br><span class="line">        m= <span class="built_in">len</span>(grid)</span><br><span class="line">        <span class="comment"># n 表示有多少列</span></span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp=[[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="comment">#dp=[[0 for _ in range(n)] for _ in range(m)]</span></span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># i 从 1 遍历到 n - 1 </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i-<span class="number">1</span>]+grid[<span class="number">0</span>][i]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># j 从 1 遍历到 m - 1 </span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m):</span><br><span class="line">            dp[j][<span class="number">0</span>]=dp[j-<span class="number">1</span>][<span class="number">0</span>] +grid[j][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接下来从第 1 行到第 m - 1 行</span></span><br><span class="line">        <span class="comment"># 从第 1 列到底 n - 1 列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]) +grid[i][j]</span><br><span class="line">        <span class="comment"># dp[m-1][n-1] 表示第 m - 1 行第 n - 1 列的最优解</span></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h1 id="leetcoad72-编辑距离"><a href="#leetcoad72-编辑距离" class="headerlink" title="leetcoad72-编辑距离"></a>leetcoad72-编辑距离</h1><p>刚拿到这个题目的时候肯定是特别的难想的：尽管题目也已经说了一些相应的操作，但是代码如何实现确实是一个问题（可以说是根本想不到的方式），而且代码的逻辑根本也不是像题目中描述的那样的，所以第一次做的时候肯定也是一头雾水。需要想到动态规划的思路，这才是问题的本源<br>还有如果一旦遇到一个新的题目，如何从一个一维dp切换到一个二维的dp也是问题的关键（<strong>这里就是一个很关键的思考流程在里面</strong>）<br>这道题总的来说还是比较难的，这里应该要花一点时间好好整理一下，而且最好方法尽量的多元化一点</p>
<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>在看labuladong的时候一些比较好的地方<br><img src="https://runnerxr.github.io/post-images/1654498134520.gif"><br>这张动图很好的展示了这样的一个过程，关键在于如何正确做出选择，根据这张动图就可以配合后面的代码来加深对递归代码的理解。<br>这里用两个指针分别指向字符串的最后，然后一步步的往前走，缩小问题的规模，根据上面的步骤，出现了四种操作：</p>
<ol>
<li>遍历到的时候，两者本来就是相等的，不对其进行操作，直接往前移动i,j就行了</li>
<li>j走完了s2的时候，结果i没有走完s1，<strong>用删除的操作，将s1缩短为s2就可以</strong></li>
<li>i走完了s1的时候，结果j没有走完s2，<strong>用插入操作把s2剩下的字符全部插入s1中</strong></li>
<li>然后就是不好处理的递归的代码部分</li>
</ol>
<p>递归的出口：上面已经写清楚了<br>递归的代码部分：<br>理解函数的部分：dp(i,j) :该函数的返回值就是s1[0…i]和s1[0…j]的最小编辑距离</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 定义dp函数(只是一个代号)</span></span><br><span class="line">        <span class="comment"># dp(i,j) :该函数的返回值就是s1[0...i]和s1[0...j]的最小编辑距离</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">i,j</span>):</span><br><span class="line">            <span class="comment"># 定义递归的出口</span></span><br><span class="line">            <span class="comment"># 当s1或s2走完了，直接返回另一个字符串剩下的长度</span></span><br><span class="line">            <span class="keyword">if</span> i==-<span class="number">1</span>: <span class="keyword">return</span> j+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j==-<span class="number">1</span>: <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> s1[i]==s2[j]:</span><br><span class="line">                <span class="comment"># 什么都可以不用做</span></span><br><span class="line">                <span class="comment"># s1[0..i]和s2[0...j]的编辑距离与s1[0..i-1]和s2[0...j-1]的编辑距离相同</span></span><br><span class="line">                <span class="keyword">return</span> dp(i,j)=dp(i-<span class="number">1</span>,j-<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># s1[i]!=s2[j]的情况的时候</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 返回的分别是替换  删除与插入的操作</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(dp(i-<span class="number">1</span>,j-<span class="number">1</span>),dp(i-<span class="number">1</span>,j),dp(i,j-<span class="number">1</span>))+<span class="number">1</span></span><br><span class="line">        <span class="comment"># i,j初始化指向最后一个索引</span></span><br><span class="line">        <span class="keyword">return</span> dp(<span class="built_in">len</span>(s1)-<span class="number">1</span>,<span class="built_in">len</span>(s2)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="动态规划的解法"><a href="#动态规划的解法" class="headerlink" title="动态规划的解法"></a>动态规划的解法</h2><p>其实也是对暴力的解法做了一定的优化<br>参考吴师兄的解题思路，做了如下的一些整理的过程<br>总共有三种方案：<br><img src="https://runnerxr.github.io/post-images/1649082291844.png"><br><img src="https://runnerxr.github.io/post-images/1649082703864.png"><br><img src="https://runnerxr.github.io/post-images/1649082753823.png"></p>
<ol>
<li>将word1中前L1-1个数字改为word2中的前L2-1个数字，再把a—-&gt;b</li>
<li>将word1中的前L1-1个数字改为word2，再删除a</li>
<li>将word1中的前L1个字符修改为word2前L2-1个字符，再向word1中插入一个字符b</li>
<li>选出其中的较小值，再判断是否需要执行一次插入操作、或者一次删除操作、或者一次替换操作</li>
</ol>
<p>为了进一步更好的弄清楚相应的解题过程，这里自己用表格来详细的模拟了这样的一个过程</p>
<ol>
<li>初始化表格，行数为s1中的长度，列数为s2中的长度，同时对于0的时候，预定的是空字符串的时候（对于索引为0的时候这里理解为空字符串确实是有点费解）</li>
<li>在对边界条件的处理上后面的代码中都会有详细的注释，特别是对于dp[0][j]和dp[i][0]的填充，本质上也是一种很好的初始化的过程，只有在脑海里面已经有了一个很明晰的二维表格的时候才能算是真正的看懂了<br><img src="https://runnerxr.github.io/post-images/1654504193955.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 获取两个字符串的长度</span></span><br><span class="line">        L1,L2=<span class="built_in">len</span>(word1),<span class="built_in">len</span>(word2)</span><br><span class="line">        <span class="comment"># 二维数组dp[i][j]表示word1的前i个字符转化为word2中的前j个字符所需要的最少的操作</span></span><br><span class="line">        <span class="comment"># dp[0][0]:word1的前0个字符转化为word2的前0个字符需要的最少操作（说人话就是空字符串变成空字符串需要的最少的一个操作）</span></span><br><span class="line">        <span class="comment"># dp[L1][L2]表示word1中的前L1个字符转化为word2中的前L2个字符所需要的最少的操作</span></span><br><span class="line">        dp=[[<span class="number">0</span>]*(L2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L1+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="comment"># dp[i][0]表示:把word1中的前i个字符转化为word2中的前0个字符需要的最少的操作(也即把word1中的前i个字符全部都删除,变成空字符串需要的操作数)</span></span><br><span class="line">        <span class="comment"># 只需要每次对word1中的字符执行删除操作,就可以将word1中的字符全部删除</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L1+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>]=i</span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp[0][j]表示:将word1中的前0个字符转化为word2中的前j个字符所需要的最少的操作次数(空字符串经过多少次变化变成word2中的前j个字符)</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(L2+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j]=j</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="comment"># 通过两个for循环来设置二维数组中所有元素的值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,L1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,L2+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 如果发现word1[i-1]==word2[j-1] 即当word1中的前i-1个字符成功转化为word2中的前j-1个字符后</span></span><br><span class="line">                <span class="comment"># 自然而然word1中的前i个字符也成功的转化为word2中的前j个字符(因为两个字符串下一个字符是相等的不需要转换操作)</span></span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>]==word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 当当前遍历的元素不相等的时候,意味着在dp[i-1][j-1]的基础上上还要转换当前的元素</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 此时的dp[i][j]可以从三种状态中转换过来</span></span><br><span class="line">                    <span class="comment"># 状态一:dp[i-1][j-1]---&gt;dp[i][j]  当前遍历的字符.两个都不相等(a---&gt;b)</span></span><br><span class="line">                    <span class="comment"># 状态二:dp[i-1][j]---&gt;dp[i][j],word1中的前i-1个字符已经转换成为了word2中的前j个字符(直接删除word1中当前遍历的元素)</span></span><br><span class="line">                    <span class="comment"># 状态三:dp[i][j-1]---&gt;dp[i][j],word1中当前的前i个字符已经转换了word2中的前j-1个字符(在word1中插入word2中当前遍历的字符)</span></span><br><span class="line">                    <span class="comment"># 取三者状态中最小值,作为最终的dp[i][j]的值</span></span><br><span class="line">                    dp[i][j]=<span class="built_in">min</span>(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+<span class="number">1</span></span><br><span class="line">        <span class="comment"># 将最后的结果返回</span></span><br><span class="line">        <span class="keyword">return</span> dp[L1][L2]</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad494-目标和"><a href="#leetcoad494-目标和" class="headerlink" title="leetcoad494-目标和"></a>leetcoad494-目标和</h1><p>做题分析：<br>要与分割等和子集的题目进行比较分析：那一题只是要返回是否可以进行进行相应的分割，我们在定义dp数组的时候的需要记录到底是True还是False目标和这道题：不仅要找出能够满足目标和要求的，还要求返回返回方法数，<strong>dp数组中需要记录的就是具体的方法数</strong><br>如何把该问题合理的转化为0-1背包问题才是问题的关键和要点</p>
<p>定义状态：根据背包问题的经验，将dp[i][j]定义为<strong>从数组nums中0~i的元素进行加减可以得到j的方法的数量</strong>或者换一种解释的方式：<strong>我们要做的就是从数组nums中选出若干数字（每个元素最多选择一次），使其和刚好等于target,并计算有多少种不同的选择方式。</strong><br>这里再重新回顾一下0-1背包问题的原型：有w个物品，有容量N的背包，其中每件物品都有一定的容量以及相应的价值，问背包中能够装入的最大的价值<br>难点：根据状态去考虑如何利用子问题的转移从而得到整体的解，<strong>问题的关键不是nums[i]的选与不选，而是nums[i]是+还是-，这就导致状态方程会有一定的变化</strong><br><code>dp[i][j]=dp[i-1][j-nums[i]]+dp[i-1][j+nums[i]]</code><br>其中nums[i]这个元素可以执行＋，也可以执行-，那么dp[i][j]的结果值就是+&#x2F;-之后对应位置的和<br>以下的代码实际上参考了东哥的解法，本质上还是对该问题做了一个转化，转化成为了0-1背包问题，其实边界问题一直是细节。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 参照东哥的解法</span></span><br><span class="line">        <span class="comment"># 先求nums数组中的和</span></span><br><span class="line">        <span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="built_in">sum</span>+=c</span><br><span class="line">        <span class="comment"># print(sum)</span></span><br><span class="line">        <span class="comment"># 当nums中所有非负的和都不能等于target或者sum+target是奇数的话也不可能找到对应的数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span> &lt;<span class="built_in">abs</span>(target) <span class="keyword">or</span> (<span class="built_in">sum</span>+target)%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 以下写一个函数，转化为0~1背包的问题，其中背包的容量为(sum+target)//2</span></span><br><span class="line">        <span class="comment"># 注意这个问题已经被转化了，所以就不要盯着之前的问题来看</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">nums,s</span>):</span><br><span class="line">            <span class="comment"># 以下就是0-1背包问题的模板了</span></span><br><span class="line">            n=<span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="comment"># 构建dp[i][j]:表示在前i件物品中选择，能够正好凑齐s的一些选择</span></span><br><span class="line">            dp=[[<span class="number">0</span>]*(s+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">            <span class="comment"># 当背包的容量的0的时候，此时需要把dp[i][j]的值全部置为1，表示：什么都不装也h是一种解法</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n+<span class="number">1</span>):</span><br><span class="line">                dp[i][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">            <span class="comment"># print(dp)</span></span><br><span class="line">            <span class="comment"># n/c  0  1  2  3  4 </span></span><br><span class="line">            <span class="comment"># 0    1  0  0  0  0</span></span><br><span class="line">            <span class="comment"># 1    1</span></span><br><span class="line">            <span class="comment"># 1    1</span></span><br><span class="line">            <span class="comment"># 1    1   </span></span><br><span class="line">            <span class="comment"># 1    1</span></span><br><span class="line">            <span class="comment"># 1    1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 初始化dp数组，因为要能够刚好凑齐</span></span><br><span class="line">            <span class="comment"># 当s=0的时候，对应的值为0</span></span><br><span class="line">            <span class="comment"># 选择i件物品放入背包和不选择第i件物品放入背包这个两种</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,s+<span class="number">1</span>):</span><br><span class="line">                    <span class="comment"># 当当前的背包容量小于此时的数值的时候，此时放入的物品由上一个状态决定</span></span><br><span class="line">                    <span class="keyword">if</span> nums[i-<span class="number">1</span>]&gt;j:</span><br><span class="line">                        dp[i][j]=dp[i-<span class="number">1</span>][j]</span><br><span class="line">                    <span class="comment"># 当前的背包容量大于当前的数值的时候就有两种选择</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]]</span><br><span class="line">            <span class="keyword">return</span> dp[n][s]</span><br><span class="line">        <span class="comment"># 实际上就是用这个函数来求对应的返回的符合条件的数目</span></span><br><span class="line">        <span class="keyword">return</span> subsets(nums,(<span class="built_in">sum</span>+target)//<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>这题做完之后，把该题与分割等和子集的问题拆分起来一起看，有相通的地方，也有不同的地方。同原版的0-1背包问题对比也有一些差异。以下也是做一些相应的总结“</p>
<ol>
<li>首先问题的转化就是一个难点：存在一定的公式推导，转化为装满容量为s的背包有几种方法：</li>
<li>特例的判断:如果目标值的绝对值大于s，是不存在方案的，如果是target&gt;s还是-target&gt;s，根据数学知识的一些常识吧。</li>
<li>为什么是0-1背包问题？nums中的数只用一次，但是又和0-1背包问题存在区别：之前的是容量为j的背包，最多能装多少，<strong>本题是装满有几种方法，是一个组合的问题</strong></li>
</ol>
<h1 id="买卖股票系类问题"><a href="#买卖股票系类问题" class="headerlink" title="买卖股票系类问题"></a>买卖股票系类问题</h1><p><img src="https://runnerxr.github.io/post-images/1649316265786.png"><br>这一系列问题是值得自己去好好的吸收与整理，<strong>形成自己的知识系统</strong>，<strong>收纳不同的方法体系</strong>。<br>哪些因素决定了可以获得的最大收益</p>
<ol>
<li>在<strong>哪些天</strong>进行了交易</li>
<li>进行了<strong>多少次</strong>交易</li>
<li>每天结束时<strong>持有的股票数</strong>（这个点容易忽略）<br><strong>吴师兄总结的一套模板的解题方法</strong><br>定义状态：</li>
<li>i表示天数</li>
<li><strong>K表示交易次数</strong>，每次交易包含<strong>买入</strong>和<strong>卖出</strong>（当成一个闭区间），这里只在买入的时候将k -1（关键点）</li>
<li>0表示当前持有0份股票</li>
<li>1表示当前持有1份股票</li>
<li><strong>dp i k 0&#x2F;1</strong> :第i天结束后，手上持有0&#x2F;1份股票，此时最多进行了k次交易的情况下可以获得的最大收益<br>动态规划的步骤：</li>
<li>置底向上，从前向后遍历，实现一个萝卜一个坑</li>
<li>对于每个坑（第i天）来说都有两种状态（这里的理解非常重要）：<ol>
<li><strong>今天不持有股票</strong><ul>
<li>状态一：第i-1天持有股票，第i天卖出，即昨天持有股票，今天卖出【卖出】</li>
<li>状态二：第i-1天不持有股票，第i天不操作，即昨天不持有股票，今天不操作【休息】</li>
</ul>
</li>
<li><strong>今天持有股票</strong><ul>
<li>状态一：第i-1天持有股票，第i天不操作，即昨天持有股票，今天不操作【休息】</li>
<li>状态二：第i-1天不持有股票，第i天买入，即昨天不持有股票，今天买入【买入】</li>
</ul>
</li>
</ol>
</li>
</ol>
<p><strong>leetcode121-买卖股票的最佳时期(easy)（限定交易次数k&#x3D;1）</strong><br>题目描述：给定一个<strong>数组 prices</strong> ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 <strong>某一天 <strong>买入这只股票，并选择在 <strong>未来的某一个</strong>不同的日子 卖出该股票。</strong>设计一个算法来计算你所能获取的最大利润</strong>。<br>返回你<strong>可以从这笔交易中获取的最大利润</strong>。如果你<strong>不能获取</strong>任何利润，<strong>返回 0</strong> 。<br>示例1：<br>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。<br>示例2：<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单单论这道题，如果是用这样的一种方法，可能用时比较的长，但是也是有助于理解的。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">      <span class="comment"># 先获取数组的长度</span></span><br><span class="line">      n = <span class="built_in">len</span>(prices)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 设置一个三维数组 dp</span></span><br><span class="line">      <span class="comment"># dp[i][k][b]</span></span><br><span class="line">      <span class="comment"># i 表示天数，dp[i] 表示第 i 天的最大利润</span></span><br><span class="line">      <span class="comment"># k 表示最多交易次数，每次交易包含买入和卖出，这里只在买入的时候将 k - 1</span></span><br><span class="line">      <span class="comment"># 注意：【 k 表示最多交易次数，而不是实际交易次数，比如最多交易两次可能实际只交易一次】</span></span><br><span class="line">      <span class="comment"># b 表示当前是否持有股票，取值为 0 和 1</span></span><br><span class="line">      <span class="comment"># 其中 0 表示当前持有 0 份股票，即【不持有】股票</span></span><br><span class="line">      <span class="comment"># 而 1 表示当前持有 1 份股票，即【持有】股票</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 在本题中，k 的值为 1，i 的取值范围为数组 prices 的长度，从 0 开始</span></span><br><span class="line">      <span class="comment"># 越在前面的维度，总体上是越出现在后面</span></span><br><span class="line">      <span class="comment"># dp =[[[0]*2]*2]*n</span></span><br><span class="line">      dp = [[[<span class="number">0</span>] *<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">      <span class="comment"># dp[0][0][0] 表示在第 0 天结束时，即收盘后，手上持有 0 份股票，且此时最多进行了 0 次交易的情况下可以获得的最大收益</span></span><br><span class="line">      <span class="comment"># 此时，就是什么都没做，利润为 0</span></span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">      <span class="comment"># dp[0][1][0] 表示在第 0 天结束时，即收盘后，手上持有 0 份股票，且此时最多进行了 1 次交易的情况下可以获得的最大收益</span></span><br><span class="line">      <span class="comment"># 此时，就是什么都没做，利润为 0</span></span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">      <span class="comment"># dp[0][1][1] 表示在第 0 天结束时，即收盘后，手上持有 1 份股票，且此时最多进行了 1 次交易的情况下可以获得的最大收益</span></span><br><span class="line">      <span class="comment"># 手上持有了 1 份股票，那肯定是执行了买入操作，然后又还没有卖出，那么钱都投入了股票中，利润就是负的，即为 -prices[0]</span></span><br><span class="line">      <span class="comment"># 相当于是贷款的形式</span></span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>]</span><br><span class="line">      <span class="comment"># 动态规划：自底向上，即从前向后遍历，实现一个萝卜一个坑</span></span><br><span class="line">      <span class="comment"># 这里i的范围是从1开始的，因为i=0的时候是没有前一个和状态的说法的，由后面的两种状态需要的值发现，需要三个初始值</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">          <span class="comment"># 对于每个坑来说，都有两种状态</span></span><br><span class="line">          <span class="comment"># 今天也就是第 i 天</span></span><br><span class="line"></span><br><span class="line">          <span class="comment"># 1、今天【不持有】股票</span></span><br><span class="line">          <span class="comment"># 第 i - 1 天【持有】股票，第 i 天卖出</span></span><br><span class="line">          <span class="comment"># 昨天【持有】股票，今天卖出</span></span><br><span class="line">          <span class="comment"># vs</span></span><br><span class="line">          <span class="comment"># 第 i - 1 天【不持有】股票，第 i 天不操作</span></span><br><span class="line">          <span class="comment"># 昨天【不持有】股票，今天不操作</span></span><br><span class="line">          <span class="comment"># dp[i][k][0]=max(dp[i-1][k][1]+prices[i],dp[i-1][k][0])</span></span><br><span class="line">          dp[i][<span class="number">1</span>][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment"># 2、今天【持有】股票</span></span><br><span class="line">          <span class="comment"># 第 i - 1 天【持有】股票，第 i 天不操作</span></span><br><span class="line">          <span class="comment"># 昨天【持有】股票，今天不操作</span></span><br><span class="line">          <span class="comment"># vs</span></span><br><span class="line">          <span class="comment"># 第 i - 1 天【不持有】股票，第 i 天买入</span></span><br><span class="line">          <span class="comment"># 昨天【不持有】股票，今天买入</span></span><br><span class="line">          <span class="comment"># dp[i][k][1]=max(dp[i-1][k][1],dp[i-1][k-1][0]-prices[i])</span></span><br><span class="line">          dp[i][<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line"></span><br><span class="line">      <span class="comment"># for 循环结束后，dp 数组填充完毕</span></span><br><span class="line">      <span class="comment"># dp[length - 1][1][0]</span></span><br><span class="line">      <span class="comment"># 表示第 length - 1 天结束时，即收盘后，手上持有 0 份股票，且此时最多进行了 1 次交易的情况下可以获得的最大收益</span></span><br><span class="line">      <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br>尝试采用其他的方法：在做剑指offer的时候的一些解法（）<br>剑指offer和这题的区别的地方：这题的数组可以为空，offer上的那道题的数组一定是有值的，所以不能完全把代码直接复制过去<br><strong>状态定义</strong>：设置动态dp，dp[i]表示代表以price[i]为结尾的子数组的最大利润（前i日的而最大利润）<br><strong>转移方程</strong>：前i日的最大利润&#x3D;前i-1的最大利润<strong>dp[i-1]<strong>和</strong>第i日卖出的最大利润</strong>中最大值<br>用方程来表示的话：dp[i]&#x3D;max(dp[i−1],prices[i]−min(prices[0:i]))<br><strong>初始状态</strong>：p[0]&#x3D;0 ，即首日利润为 0<br><strong>返回值</strong>：dp[n−1] ，其中 n 为 dp 列表长度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这种写法相对来说非常的慢</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n=<span class="built_in">len</span>(prices)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp=[<span class="number">0</span>]*n</span><br><span class="line">        <span class="comment"># 初始状态</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>],prices[i]-<span class="built_in">min</span>(prices[:i]))</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>看了K神优化后的代码，这里也放在这里学习一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n=<span class="built_in">len</span>(prices)</span><br><span class="line">        <span class="comment"># 将成本预先定义成无穷大</span></span><br><span class="line">        <span class="comment"># 用profit变量代替了状态变量</span></span><br><span class="line">        cost, profit = <span class="built_in">float</span>(<span class="string">&quot;+inf&quot;</span>), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="comment"># cost总是存储之前cost和目前遍历的价格的最小值</span></span><br><span class="line">            cost = <span class="built_in">min</span>(cost, price)</span><br><span class="line">            profit = <span class="built_in">max</span>(profit, price - cost)</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>

<p>采用贪心算法的思路：</p>
<p><strong>leetcode122-买卖股票的最佳时期II(middle)（限定交易次数k无限大）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        <span class="comment">#设置二维的dp数组</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment">#dp[0][1]表示：在第0天结束的时候，手上持有1份股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#dp[0][0]表示：在第0天结束的时候，手上持有0份股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="comment">#今天不持有股票的情况</span></span><br><span class="line">            <span class="comment"># 第一种状态：第i-1天持有股票，在第i天卖出：dp[i][0]=dp[i-1][1]+prices[i]</span></span><br><span class="line">            <span class="comment"># 第二种状态：第i-1天不持有股票，第i天休息:dp[i][0]= dp[i-1][0]</span></span><br><span class="line">            dp[i][<span class="number">0</span>]= <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment">#今天持有股票的情况</span></span><br><span class="line">            <span class="comment"># 第一种状态：第i-1天持有股票，第i天不操作:dp[i][1]=dp[i-1][1]</span></span><br><span class="line">            <span class="comment"># 第二种状态：第i-1天不持有股票，第i天进行买入操作:dp[i][1]=dp[i-1][0]-prices[i]</span></span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>尝试采用其他的解法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>相较于上一题，这里的k值为正无穷<br><strong>leetcode123-买卖股票的最佳时期III(hard)（限定交易次数k&#x3D;2）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先获取数组的长度</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        <span class="comment"># 设置一个三维数组 dp</span></span><br><span class="line">        <span class="comment"># dp[i][k][b]</span></span><br><span class="line">        dp = [[[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment">#设置几种初始状态</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 动态规划：自底向上，即从前向后遍历，实现一个萝卜一个坑</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="comment"># 对于每个坑来说，都有两种状态</span></span><br><span class="line">            <span class="comment"># 今天也就是第 i 天</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 1、今天【不持有】股票，且此时最多进行了 2 次</span></span><br><span class="line">            <span class="comment"># 第 i - 1 天【持有】股票，第 i 天卖出:dp[i][2][0]=dp[i-1][2][1]+prices[i]</span></span><br><span class="line">            <span class="comment"># 第 i - 1 天【不持有】股票，第 i 天不操作:dp[i][2][0]= dp[i-1][2][0]</span></span><br><span class="line">            dp[i][<span class="number">2</span>][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 2、今天【持有】股票，且此时最多进行了 2 次</span></span><br><span class="line">            <span class="comment"># 第 i - 1 天【持有】股票，第 i 天不操作：dp[i][2][1]=dp[i-1][2][1]</span></span><br><span class="line">            <span class="comment"># 第 i - 1 天【不持有】股票，第 i 天买入：dp[i][2][1]=dp[i-1][1][0]-prices[i]</span></span><br><span class="line">            dp[i][<span class="number">2</span>][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">             </span><br><span class="line">            <span class="comment"># 3、今天【不持有】股票，且此时最多进行了 1 次</span></span><br><span class="line">            <span class="comment"># 第 i - 1 天【持有】股票，第 i 天卖出:dp[i][1][0]=dp[i-1][1][1]+prices[i]</span></span><br><span class="line">            <span class="comment"># 第 i - 1 天【不持有】股票，第 i 天不操作:dp[i][1][0]=dp[i-1][1][0]</span></span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 4、今天【持有】股票，且此时最多进行了 1 次</span></span><br><span class="line">            <span class="comment"># 第 i - 1 天【持有】股票，第 i 天不操作:dp[i][1][1]=dp[i-1][1][1]</span></span><br><span class="line">            <span class="comment"># 第 i - 1 天【不持有】股票，第 i 天买入:dp[i][1][1]=dp[i-1][0][0]-prices[i]</span></span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p><strong>leetcode188-买卖股票的最佳时期IV(hard)（限定交易次数最多为k）</strong><br>这种情况相当于是股票问题的一个通用的版本（重点理解）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, k: <span class="built_in">int</span>, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#题目这里有一个陷阱：prices[i]的长度是有可能为0,此时数组为空，需要加一个判断语句</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 先获取数组的长度</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        <span class="comment"># 设置一个三维数组 dp</span></span><br><span class="line">        <span class="comment"># dp[i][k][b]</span></span><br><span class="line">        dp = [[[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment">#用一个for循环来遍历可能的交易的次数</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">            <span class="comment">#设置几种初始状态</span></span><br><span class="line">            dp[<span class="number">0</span>][j][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">            dp[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[<span class="number">0</span>][j-<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment"># 动态规划：自底向上，即从前向后遍历，实现一个萝卜一个坑</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">                <span class="comment"># 对于每个坑来说，都有两种状态</span></span><br><span class="line">                <span class="comment"># 今天也就是第 i 天</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 1、今天【不持有】股票，且此时最多进行了 j 次</span></span><br><span class="line">                <span class="comment"># 第 i - 1 天【持有】股票，第 i 天卖出:dp[i][j][0]=dp[i-1][j][1]+prices[i]</span></span><br><span class="line">                <span class="comment"># 第 i - 1 天【不持有】股票，第 i 天不操作:dp[i][j][0]= dp[i-1][j][0]</span></span><br><span class="line">                dp[i][j][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][j][<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][j][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 2、今天【持有】股票，且此时最多进行了 j 次</span></span><br><span class="line">                <span class="comment"># 第 i - 1 天【持有】股票，第 i 天不操作：dp[i][j][1]=dp[i-1][j][1]</span></span><br><span class="line">                <span class="comment"># 第 i - 1 天【不持有】股票，第 i 天买入：dp[i][j][1]=dp[i-1][j-1][0]-prices[i]</span></span><br><span class="line">                dp[i][j][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][j][<span class="number">1</span>],dp[i-<span class="number">1</span>][j-<span class="number">1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][k][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p><strong>leetcode309-最佳买卖股票时机含冷冻期（含有交易冷冻期）</strong><br>注意点：</p>
<ol>
<li>在卖出股票后，无法在第二天买入股票</li>
<li>不能同时参与多笔交易（在再次购买前出售掉之前的股票）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            dp[i][<span class="number">0</span>]= <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">            <span class="comment">#和122个问题的逻辑点是相同的，唯一的区别就是这一行代码的差别，加入了一个if else的判断语句。</span></span><br><span class="line">            dp[i][<span class="number">1</span>]= <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>],  (dp[i-<span class="number">2</span>][<span class="number">0</span>] <span class="keyword">if</span> i &gt;=<span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span>)-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<strong>leetcod714-买卖股票的最佳时期含手续费（每次交易含手续费）</strong><br>加入了交易的手续费，k也是一个无限的交易次数，每笔都需要进行手续费<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>], fee: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="comment">#和122问题唯一的区别是这里减去了一个交易的费用问题</span></span><br><span class="line">            dp[i][<span class="number">0</span>]= <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]-fee,dp[i-<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%EF%BC%88%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%89/" data-id="claqu8zzh0026iwtk6kblf0l9" data-title="动态规划算法合集（系列一）" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-动态规划合集（系列二）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%90%88%E9%9B%86%EF%BC%88%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2022-03-18T01:29:02.000Z" itemprop="datePublished">2022-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%90%88%E9%9B%86%EF%BC%88%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%89/">动态规划合集（系列二）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>几个资料链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chengwei920412/article/details/44097347?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_aa&amp;utm_relevant_index=1">https://blog.csdn.net/chengwei920412/article/details/44097347?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_aa&amp;utm_relevant_index=1</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyzn1425077119/article/details/52858439?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5.pc_relevant_paycolumn_v3&amp;utm_relevant_index=10">https://blog.csdn.net/zyzn1425077119/article/details/52858439?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5.pc_relevant_paycolumn_v3&amp;utm_relevant_index=10</a></p>
<p>主要有以下地一些题目：</p>
<ol>
<li>完全平方数</li>
<li>leetcoad120-三角形最小路径和</li>
<li>leetcoad62-不同路径</li>
<li>不同路径II</li>
<li>leetcoad343-整数拆分</li>
<li>leetcoad416-分割等和子集（**这是一个重点地题型，采用了完全背包地思路，并且是一种转换地类型）</li>
<li>leetcoad198-打家劫舍</li>
<li>leetcoad213-打家劫舍II</li>
<li>子串和子序列地动态规划合集（很经典呀，有很多地类型，关键是里面地一些思路蕴含在里面了）<ol>
<li>最长公共子序列</li>
<li>最长公共子串</li>
<li>最长递增子序列</li>
<li>最长连续递增序列</li>
<li>最长回文子串</li>
<li>最长回文子序列</li>
</ol>
</li>
</ol>
<h1 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h1><p>按照找零钱的思路（按照吴师兄的解题步骤：两个题目相互结合起来一起掌握）</p>
<ol>
<li>设置一个数组，用来储存小于n的那些完全平方数</li>
<li>用dp[i]表示数字i需要完全平方数的最小数量（最开始初始化为-1，表示还没有计量）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 设置一个数组，用来存储小于 n 的那些完全平方数</span></span><br><span class="line">        square=[]</span><br><span class="line">        idx= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> idx * idx &lt;=n:</span><br><span class="line">            square.append(idx * idx)</span><br><span class="line">            idx +=<span class="number">1</span></span><br><span class="line">        <span class="comment"># dp[i] 表示数字 i  需要完全平方数的最少数量</span></span><br><span class="line">        <span class="comment"># 先让 dp 初始化为 -1，代表 dp[i] 还没有计算，有n+1个初始值，用于储存0~n的所有情况</span></span><br><span class="line">        dp=[-<span class="number">1</span>]*(n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp[0] 表示数字 0 需要完全平方数的最少数量</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 开始填充 dp[]</span></span><br><span class="line">        <span class="comment">#注意这里i的范围，因为题目给定的n是一个大于等于1的数，所以从1开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 在每次填充的过程中，都去遍历 square 数组</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(square)):</span><br><span class="line">                <span class="comment"># 如果发现此时 square 的元素值大于了 i</span></span><br><span class="line">                <span class="comment"># 那么 square 后面的那些元素没有必要参与进来计算 i 了</span></span><br><span class="line">                <span class="comment"># 直接退出当前的 j 的循环判断，让 i++</span></span><br><span class="line">                <span class="keyword">if</span> square[j] &gt;i:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 否则，如果 dp[i] 还没有找到数字 i 需要完全平方数的最少数量</span></span><br><span class="line">                <span class="comment"># 或者此时计算的新值更小，那么更新 dp[i]</span></span><br><span class="line">                <span class="keyword">if</span> dp[i]==-<span class="number">1</span> <span class="keyword">or</span> dp[i] &gt; dp[i-square[j]]+<span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 更新 dp[i]</span></span><br><span class="line">                    <span class="comment"># dp[i] 表示数字 i  需要完全平方数的最少数量</span></span><br><span class="line">                    <span class="comment"># 这个时候 dp[i] 为获取数字为 square.get(j) 的那 1 个完全平方数</span></span><br><span class="line">                    <span class="comment"># 加上获取数字为 i-square.get(j) 最少需要 dp[i-square.get(j)] 个数</span></span><br><span class="line">                    dp[i]=dp[i-square[j]]+<span class="number">1</span></span><br><span class="line">        <span class="comment"># dp[n] 表示数字 n 需要完全平方数的最少数量</span></span><br><span class="line">        <span class="comment"># 返回这个结果就行</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
尝试采用其他的方式来求解(后面补充进来)：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment"># leetcoad120-三角形最小路径和(middle)</span></span><br><span class="line">充分的理解题意:寻找每一层数据的条件的限制</span><br><span class="line">按照动态规划的思路来讲这道题并不是很好理解清楚，用下面的图片来进行辅助的理解。，对于第i层来说，第i+<span class="number">1</span>层的数据比这一层要多一个，并且理解当前层的每一个数与i+<span class="number">1</span>层的数的数学关系，确定好数学关系后（如果正位于当前行的下标i，下一步可以移动到下一行的下标i或i+<span class="number">1</span>），就需要再考虑如何进行更新的问题，是一个至底向上的问题</span><br><span class="line">采用递归的方式：既然dp[i][j]只与与该点相邻两点到底边的最小路径和中的较小值有关，结合这道题目采用递归的解法进行相应的尝试,至上而下，存在重复子问题的计算，时间复杂度O(<span class="number">2</span>^n)</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumTotal</span>(<span class="params">self, triangle: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#本质是一个dfs算法（递归的思路），对每个顶点查找其相邻点的过程</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i,j,triangle</span>):</span><br><span class="line">            <span class="comment"># 如果此时的数据正好位于三角形的最底层，没有对应的相邻值，相当于找到递归的出口，直接返回对应的二维数组的值，也就是需要注意的边界问题</span></span><br><span class="line">            <span class="keyword">if</span> i== <span class="built_in">len</span>(triangle)-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> triangle[i][j]</span><br><span class="line">            <span class="keyword">return</span> triangle[i][j]+<span class="built_in">min</span>(dfs(i+<span class="number">1</span>,j,triangle),dfs(i+<span class="number">1</span>,j+<span class="number">1</span>,triangle))</span><br><span class="line">        <span class="comment"># dfs(0,0,triangle)就是要求的最小路径和</span></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,triangle)</span><br></pre></td></tr></table></figure>
最后一行换一个位置：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumTotal</span>(<span class="params">self, triangle: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,triangle)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i,j,triangle</span>):</span><br><span class="line">    <span class="keyword">if</span> i== <span class="built_in">len</span>(triangle)-<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> triangle[i][j]</span><br><span class="line">    <span class="keyword">return</span> triangle[i][j]+<span class="built_in">min</span>(dfs(i+<span class="number">1</span>,j,triangle),dfs(i+<span class="number">1</span>,j+<span class="number">1</span>,triangle))</span><br></pre></td></tr></table></figure>
<strong>递归+记忆化（至底向上）</strong><br>定义一个二维数组进行记忆化（以下的两种写法本质上是一样的，只不过一种写的是对原数组进行修改，一种是定义一个dp数组来储存，只不过是以两种方式记录了每次递归的结果）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumTotal</span>(<span class="params">self, triangle: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(triangle):</span><br><span class="line">        <span class="comment"># 行至下而上</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 列至右向左</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,length+<span class="number">1</span>):</span><br><span class="line">                <span class="comment">#理解为不断对原list进行修改的一个过程，相较下面的不需要额外的O(n)空间</span></span><br><span class="line">                triangle[length-i][length-j] = triangle[length-i][length-j] + </span><br><span class="line">                <span class="built_in">min</span>(triangle[length-i+<span class="number">1</span>][length-j],triangle[length-i+<span class="number">1</span>][length-j+<span class="number">1</span>])</span><br><span class="line">    <span class="comment">#最后返回顶部的值</span></span><br><span class="line">    <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumTotal</span>(<span class="params">self, triangle: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># triangle 是个二维数组</span></span><br><span class="line">        <span class="comment"># 先获取 triangle 的层数，即一维数组的个数</span></span><br><span class="line">        n = <span class="built_in">len</span>(triangle)</span><br><span class="line">        dp[i][j]表示从点(i,j)到底边的最小路径和</span><br><span class="line">        dp=[<span class="number">0</span>]*(n+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 从最后一层开始计算节点的最短路径，直到顶层 0 层为止，索引从n-1~0,其中step=-1，应为0的上一个下一个状态时-1，所以for i in range(n-1,-1,-1),也算一种小的细节方面吧。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># dp 中存储的是前 i 个位置存储的是到达第 i 层各个节点的最小路径和</span></span><br><span class="line">            <span class="comment"># 从每一层的第 0 个位置开始，对于第i层的数据来说，有i列数据，本来j的索引从0~i-1,但是因为相邻元素的原因有j+1的情况，为了避免越界的判断，申请i+1列数据，所以range(i+1)</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># dp[j] 表示第 i 层中第 j 个节点的最小路径和</span></span><br><span class="line">                dp[i[j]=triangle[i][j] +<span class="built_in">min</span>(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
** 尝试对空间进行优化**<br> 解题步骤：</li>
<li>需要先获取三角形的层数</li>
<li>创建dp[i]存储的是到i+1层节点的最小路径和，其中前i个位置存储的是到达第i层各个节点的最小路径和（理解二维数组压缩为一维数组的思想：详见注释）</li>
<li>通过for循环更新dp数组<br><img src="https://runnerxr.github.io/post-images/1649255599114.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对二维的动态规划问题进行空间优化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumTotal</span>(<span class="params">self, triangle: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># triangle 是个二维数组</span></span><br><span class="line">        <span class="comment"># 先获取 triangle 的层数，即一维数组的个数</span></span><br><span class="line">        n = <span class="built_in">len</span>(triangle)</span><br><span class="line">        <span class="comment"># 设置一个一维数组，动态的更新每一层中当前节点对应的最短路径</span></span><br><span class="line">        <span class="comment"># 在上面的代码中，我们虽然定义了NXN的dp数组，但是递归的时候只用到了下一行的dp[i+1][j]和dp[i+1][j+1],因此dp数组不需要定义n行，定义一行就行了，将O(N^2)的复杂度优化为O(N)</span></span><br><span class="line">        <span class="comment"># 这里由后面的分析可知，对于存储j的值，因为最底层有一个j+1的缘故，所以数组的长度为n+1</span></span><br><span class="line">        dp=[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 从最后一层开始计算节点的最短路径，直到顶层 0 层为止,避免了从顶至底边界判断的问题</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># dp 中存储的是前 i 个位置存储的是到达第 i 层各个节点的最小路径和</span></span><br><span class="line">            <span class="comment"># 从每一层的第 0 个位置开始</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># dp[j] 表示第 i 层中第 j 个节点的最小路径和</span></span><br><span class="line">                dp[j]=triangle[i][j] +<span class="built_in">min</span>(dp[j],dp[j+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad62-不同路径-middle"><a href="#leetcoad62-不同路径-middle" class="headerlink" title="leetcoad62-不同路径(middle)"></a>leetcoad62-不同路径(middle)</h1><p>获取数组的行和列<br>设置dp[i][j]表示从第0行第0列到达i行j列时不同的路径的数量<br>同时要注意边界：这里自己再写的时候要注意</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应该是最好理解和简单的版本了</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#创建dp数组，并用0进行填充</span></span><br><span class="line">        dp=[[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="comment"># 设置初始条件，从左上角走到左上角的位置</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">        <span class="comment">#当机器人只在第0列移动的时候</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">        <span class="comment">#当机器人只在第0行移动的时候</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[<span class="number">0</span>][j]=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">                <span class="comment">#dp[i][j]数组的含义：机器人走到第i行第j列的所有路径之和</span></span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>上面的代码做一点精简化的处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">      <span class="comment">#创建dp数组，并用0和1进行填充,其中对于第0行和第0列的数据填1</span></span><br><span class="line">      dp=[ [<span class="number">1</span>]*n] + [ [<span class="number">1</span>] + [<span class="number">0</span>]*(n-<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m):</span><br><span class="line">          <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">              dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>]</span><br><span class="line">      <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>优化为一维动态规划</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有空再补充</span><br></pre></td></tr></table></figure>
<h1 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h1><p>注意两个特殊的情况，设置两个初始化的情况（一旦发现障碍物就直接退出循环的，不用再往下进行遍历）<br>其他不是第0行或者是第0列的时候（一旦发现障碍物就退出当前的执行，直接到一个循环中去）<br>再设置dp数组的时候，观察是否发现障碍物</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 设置二维数组 dp 用来储存到达每个位置时不同路径的数量</span></span><br><span class="line">        m = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">        n = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 用0来填充mxn行的二维数组</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># i 从 0 遍历到 m - 1 </span></span><br><span class="line">        <span class="comment"># 获取从第 0 行第 0 列到达第 j 行第 0 列时不同路径的数量</span></span><br><span class="line">        <span class="comment"># 由于每次只能向下或者向右移动一步，此时只能向下移动一步</span></span><br><span class="line">        <span class="comment"># 所以，只能一直向下走，只有这一条路径</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="comment"># 一旦出现了障碍，那么后面所有的位置都是到达不了的，都是默认的 0</span></span><br><span class="line">            <span class="comment"># 循环就像跑圈，当你跑到中途时，遇到了break，就退场，再也不跑了。当你跑到中途时，遇到了continue，就返回起点，开始跑下一圈</span></span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 仅此一条，别无分路</span></span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">        <span class="comment"># j 从 0 遍历到 n - 1 </span></span><br><span class="line">        <span class="comment"># 获取从第 0 行第 0 列到达第 0 行第 i 列时不同路径的数量</span></span><br><span class="line">        <span class="comment"># 由于每次只能向下或者向右移动一步，此时只能向右移动一步</span></span><br><span class="line">        <span class="comment"># 所以，只能一直向右走，只有这一条路径</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n):</span><br><span class="line">            <span class="comment"># 一旦出现了障碍，那么后面所有的位置都是到达不了的，都是默认的 0</span></span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][j]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 仅此一条，别无分路</span></span><br><span class="line">            dp[<span class="number">0</span>][j]=<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 接下来从第 1 行到第 m - 1 行</span></span><br><span class="line">        <span class="comment"># 从第 1 列到 n - 1 列</span></span><br><span class="line">        <span class="comment"># 填充二维数组 dp 里面的值</span></span><br><span class="line">        <span class="comment"># dp[i][j] 表示从第 0 行第 0 列到达第 i 行第 j 列时不同路径的数量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">                <span class="comment"># 由于每次只能向下或者向右移动一步</span></span><br><span class="line">                <span class="comment"># 如果此时出现了障碍，那么由于无法到达这个位置，因此不用处理</span></span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j]==<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 位置 (i,j) 的不同路径的数量是由</span></span><br><span class="line">                <span class="comment"># 1、上边位置 dp[ i - 1 ][j] 的不同路径的数量</span></span><br><span class="line">                <span class="comment"># 2、左边位置 dp[i][ j - 1 ] 的不同路径的数量</span></span><br><span class="line">                <span class="comment"># 两者之和获取到的</span></span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># dp[ m - 1][ n - 1 ] 表示从第 0 行第 0 列到达第 m - 1 行第 n - 1 列时不同路径的数量</span></span><br><span class="line">        <span class="comment"># 即到达终点的数量</span></span><br><span class="line">        <span class="comment"># 返回这个结果即可</span></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h1 id="leetcoad343-整数拆分（middle）"><a href="#leetcoad343-整数拆分（middle）" class="headerlink" title="leetcoad343-整数拆分（middle）"></a>leetcoad343-整数拆分（middle）</h1><p>dp[i]表示正整数i拆分之后结果的最大乘积<br>dp[i-j]表示正整数i-j拆分之后结果的最大乘积<br>对于i有两种拆法：</p>
<ol>
<li>j * (i-j) 表示把i拆分为j和i-j这两个数</li>
<li>j * dp[i - j] 表示把i拆分为j和dp[i-j]这两个数</li>
</ol>
<p>这个过程其实是需要证明的<br> j * dp[i - j]   &gt;dp[j]  * dp[i-j]<br> dp[j]  * dp[i-j]肯定在之前的dp[j-k]*dp[k]*dp[i-j]中已经计算过了<br> 比如拆分10 为4和6<br> dp[4]<em>dp[6]已经在2</em>dp[8]这种情况中得到了相应的回答了<br>同样也要注意拆分从你那个3数字开始，dp[2]就是一个边界条件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">integerBreak</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dp[2] 表示正整数 2 拆分之后结果的最大乘积</span></span><br><span class="line">        <span class="comment"># dp[3] 表示正整数 3 拆分之后结果的最大乘积</span></span><br><span class="line">        <span class="comment"># dp[i] 表示正整数 i 拆分之后结果的最大乘积</span></span><br><span class="line">        dp = [ <span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>( n + <span class="number">1</span> )]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 你可以假设 n 不小于 2 且不大于 58</span></span><br><span class="line">        <span class="comment"># 初始化 dp[2]</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 填充数组 dp 里面的值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">3</span> , n + <span class="number">1</span> ) : </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span> ( <span class="number">1</span> , i - <span class="number">1</span> ): </span><br><span class="line">                <span class="comment"># 并且，并不是说拆分之后乘积就必然大于 i，比如 i = 2，拆分之后的乘积为 1</span></span><br><span class="line">                <span class="comment"># 因此，需要比较这三者，取较大值</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(j * ( i - j ), j * dp[ i - j ]))</span><br><span class="line">        <span class="comment"># 返回这个结果即可</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="地下城游戏"><a href="#地下城游戏" class="headerlink" title="地下城游戏"></a>地下城游戏</h1><p>dp[i][j]表示骑士来到第i行第j列时必须拥有的最小生命值<br>应该是从右下角开始填充的，从后往前，所以此时的初始状态是反的 </p>
<h1 id="leetcoad416-分割等和子集"><a href="#leetcoad416-分割等和子集" class="headerlink" title="leetcoad416-分割等和子集"></a>leetcoad416-分割等和子集</h1><p>这道题要十分深刻的掌握！！！（也是今天的死任务，在代码和思维层面都不能有思维的漏洞。）<br>题目的意思要深刻解析：给你一个只包含整数的非空数组nums，请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<br>等价转换：<strong>是否可以从输入的数组中挑出一些正整数，使得这些数的和等于整个数组元素和的一半。</strong>（数组的和一定得是偶数,并且这里的思维转化才是最妙的，如果背包问题没有十分清晰和深刻的认识很难想到用这个方法，也是题目的一大思路点！！！！！！）<br>与0-1背包的区别：</p>
<ol>
<li>0-1 背包问题选取的物品的容积总量 不能超过 规定的总量；</li>
<li>本题选取的数字之和需要 恰好等于 规定的和的一半。</li>
</ol>
<p>状态转移方程：<br>状态的定义：<br>dp[i][j] 表示 nums 的前 i 个元素（从数组[0,i]这个子区间挑选一些整数，<strong>每次只能用一次</strong>）能否可以组成和为 j 的结果（<strong>使得这些数的结果恰好等于j</strong>）<br>状态转移方程：<strong>对于0-1背包问题就是考虑当前的数字选与不选的问题</strong></p>
<ol>
<li>不选nums[i]，<strong>如果在[0,i-1]的范围内已经有一部分元素，使得他们的和为j</strong>，那么dp[i][j]&#x3D;True</li>
<li>如果选择的话，**如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i]**。（这里的思路实在是太妙了！！！！！，一下子就找到了思路的源泉，很开心！！！！）dp[i][j]&#x3D;dp[i-1][j] or dp[i-1][j-nums[i]]</li>
</ol>
<p>考虑相应的初始条件</p>
<ol>
<li>j-nums[j]作为数组的下标，一定要保证大于等于0，也即j&gt;&#x3D;nums[i]  （也可以从另外的一个角度来理解：只有目标数与当前数的差值大于0才有可能在除开这个数的前面去寻找）</li>
<li>j恰好等于nums[i]的情况，j&#x3D;&#x3D;nms[i]（这里是非常特殊的情况：既然容量和给的值正好相等自然是没有问题的）</li>
</ol>
<p>初始化：dp[0][0]&#x3D;False：<strong>待选的nums[0]是整数，凑不出和为0的情况</strong>（这种思维太细了，联想0-1背包问题就是：有物品，但是么有背包容量，此时的背包啥也装不下，这里也是一样的，一个正整数无法凑出一个为0的值。）<br>下面的这张表是为了让自己有更加深入的了解。<br><img src="https://runnerxr.github.io/post-images/1652253592980.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下为python代码的实现过程，仿照了0-1背包的思路</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 将问题转化为为0-1背包问题的形式</span></span><br><span class="line">        <span class="comment"># 判读数组的和是否是偶数，如果是奇数就直接pass</span></span><br><span class="line">        temp=<span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> temp %<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 构建总的背包容量</span></span><br><span class="line">        target=temp//<span class="number">2</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 构建dp数组，其中行数为数组的长度，列数为target+1</span></span><br><span class="line">        <span class="comment"># 构建dp数组,默认里面是填充的False,和0-1背包问题默认填0是一个道理</span></span><br><span class="line">        dp=[[<span class="literal">False</span>]*(target+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment">#print(dp)</span></span><br><span class="line">        <span class="comment"># 设置初始状态,也就是当为nums[0]的时候，由于nums[0]是一个正整数，所以无法凑出0出来。</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">False</span></span><br><span class="line">        <span class="comment"># dp[i][j]的含义:在前i个数字中能否找到和为j的数字，如果能的话就是True，如果不能的话就是False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 想想0-1背包的问题</span></span><br><span class="line">                <span class="comment"># 首先判断当前值是否是比j要大的，如果是大的话肯定是不能够凑出来的</span></span><br><span class="line">                <span class="comment"># 就需要看前面的数能否凑出j来，也即此时的状态是依赖于上一行的状态</span></span><br><span class="line">                <span class="keyword">if</span> j&lt;nums[i]:</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="comment"># 如果当前的值正好是等于j值，这个时候也是可以凑出来的。</span></span><br><span class="line">                <span class="keyword">elif</span> j==nums[i]:</span><br><span class="line">                    dp[i][j]=<span class="literal">True</span></span><br><span class="line">                <span class="comment"># 最后一种情况j&gt;nums[i]</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 这里的情况又要分两种情况</span></span><br><span class="line">                    <span class="comment"># 选择把把当前元素作为备选的情况，在剩下的元素中找是否有值等于j-nums[i]</span></span><br><span class="line">                    <span class="comment"># 以及直接不选nums[i],看之前的数里面能否找到，这两种情况只要有一种是可以的就行</span></span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-nums[i]] <span class="keyword">or</span> dp[i-<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][target]</span><br></pre></td></tr></table></figure>


<h1 id="leetcoad198-打家劫舍"><a href="#leetcoad198-打家劫舍" class="headerlink" title="leetcoad198-打家劫舍"></a>leetcoad198-打家劫舍</h1><p>定义子问题：从k个房间中能够偷到的最大金额<br>1.方案一：只偷前k-1个房间，最后一间不偷</p>
<ol>
<li>方案二：偷前k-2个房间，再偷最后一间<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先获取全部房间的总数</span></span><br><span class="line">        n= <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        value=[<span class="number">0</span>]*n</span><br><span class="line">        value[<span class="number">0</span>]=nums[<span class="number">0</span>]</span><br><span class="line">        value[<span class="number">1</span>]=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># value[1] 表示前 1 个房间可以偷取的最大金额</span></span><br><span class="line">        <span class="comment"># 只有 1 个房间，那么只能偷这个房间的东西，所以存放结果为这个房间的金额</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从 i = 2 直到 i = n，value 中存放的结果由前 i - 2 和 i - 1 共同决定</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 转移方程：value[i] 等于 value[ i - 1 ]  和 value[ i - 2 ] + num[ i - 1] 中的较大值</span></span><br><span class="line">            value[i]=<span class="built_in">max</span>(value[i-<span class="number">1</span>],value[i-<span class="number">2</span>]+nums[i])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最后返回 value 的最后一个值</span></span><br><span class="line">        <span class="keyword">return</span> value[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad213-打家劫舍II"><a href="#leetcoad213-打家劫舍II" class="headerlink" title="leetcoad213-打家劫舍II"></a>leetcoad213-打家劫舍II</h1><p><strong>定义子问题：</strong><br>从k个房间中能够偷到的最大金额（与上一题相同）<br>1.方案一：只偷前k-1个房间，最后一间不偷（第一家<del>倒数第二家）：nums[1:],有一个最大的金额<br>2. 方案二：偷前k-2个房间，再偷最后一间（第二家</del>倒数第一家）：nums[:n-1],有一个最大金额<br><strong>处理房间环的问题</strong>：<br>变化点：房间是一个首位相连的，把一个环的头去掉，就变成打家劫舍的问题（此题的难点和精髓所在）<br>把环状排列房间问题简化为两个单排列的房间问题，分而治之，把一个问题分成多个规模更小的子问题<br>房间环状排列 意味着第一间和最后一间不能同时选择，因此我们可以分成两种情况来讨论：（装换成两个打家劫舍的问题，然后再求较大值）</p>
<ol>
<li>不偷窃最后一间房间，那么问题转化为偷窃1号到i - 1号房间所能获得的最高金额。</li>
<li>不偷窃第一间房间，那么问题转化为偷窃2号到i号房间所能获得的最高金额。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不写函数，直接分类讨论两种情况</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先获取全部房间的总数</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 初始状态</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 方案一：nums[:-1],最后一间不偷的情况</span></span><br><span class="line">        <span class="comment"># 1号~i-1号房间所能获得的最高金额</span></span><br><span class="line">        value = [ <span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 只偷窃1号房间所能获得的最高金额nums[0]</span></span><br><span class="line">        value[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 从2号遍历到n-1号房间</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">2</span> , n ) : </span><br><span class="line">            value[i] = <span class="built_in">max</span>(value[i - <span class="number">1</span>] ,value[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 方案二：nums[:n-1]偷前面的n-2个房间，最后一间可以选择偷或者不偷都行</span></span><br><span class="line">        <span class="comment"># 2~i号房间所能获得的最高金额，把第二间房当成单排排列的起点</span></span><br><span class="line">        dp = [ <span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 只偷窃2号房间所能获得的最高金额</span></span><br><span class="line">        dp[<span class="number">2</span>] = nums[<span class="number">1</span>]</span><br><span class="line">        <span class="comment">#  从3号遍历到n号房间</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">3</span> , n+<span class="number">1</span>) : </span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j - <span class="number">1</span>] ,dp[j -<span class="number">2</span>] + nums[j - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回值的时候也要注意：需要返回两种请款的较大值，同时要注意下标 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(value[n-<span class="number">1</span>],dp[n])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用函数进行封装，这种方式从大局到细节都要掌握</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先获取全部房间的总数</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment">#边界条件</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> :  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> :  </span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#返回的是只偷前k-1个房间 以及不偷第一家这两种情况的一个最大值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.myRob(nums[:-<span class="number">1</span>]),self.myRob(nums[<span class="number">1</span>:]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 写了一个myRob函数，求这两种情况的一个最大值的问题</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myRob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 多创建了一个数组</span></span><br><span class="line">        value = [ <span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>( n + <span class="number">1</span>)]</span><br><span class="line">        value[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        value[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 从 i = 2 直到 i = n，value 中存放的结果由前 i - 2 和 i - 1 共同决定</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">2</span> , n + <span class="number">1</span> ) : </span><br><span class="line">            <span class="comment"># 转移方程：value[i] 等于 value[ i - 1 ]  和 value[ i - 2 ] + num[ i - 1] 中的较大值</span></span><br><span class="line">            value[i] = <span class="built_in">max</span>(value[i - <span class="number">1</span>] ,value[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> value[n]</span><br></pre></td></tr></table></figure>



<h1 id="打家劫舍III-仅学习，是一种树形dp"><a href="#打家劫舍III-仅学习，是一种树形dp" class="headerlink" title="打家劫舍III(仅学习，是一种树形dp)"></a>打家劫舍III(仅学习，是一种树形dp)</h1><h1 id="关于子串和子序列动态规划合集"><a href="#关于子串和子序列动态规划合集" class="headerlink" title="关于子串和子序列动态规划合集"></a>关于子串和子序列动态规划合集</h1><p>这里发现有很多关于子序列与子串的动态规划的问题，这类问题现在这里做一个统一的整理，务必要弄懂和明白，不能有知识的漏洞：<br>子序列：由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串<br>回文子串：正读和反读都一样的字符串<br>回文子序列：它逆序输出和输出之前的序列是一样的<br><strong>常见的几种类型：</strong></p>
<ol>
<li>求两个数组或两个字符串的最长子序列的问题肯定是需要用动态规划的思想的</li>
<li>单个数组或者字符串用一维的dp[i] nums[0:i]中想求的结果</li>
<li>当有两个数组或者字符串的时候用到二维的dp[i][j],含义为在A[0:I]和B[0:j]之间匹配想要的结果</li>
<li>输出的结果也可能是多样的：<ol>
<li>输出最长的子序列&#x2F;子串&#x2F;回文子序列&#x2F;回文子串的长度</li>
<li>不仅要输出长度，还有输出相应的字符串的具体的值（<strong>考验输出的能力的</strong>）</li>
</ol>
</li>
</ol>
<p><strong>以下为几种具体的题目：</strong></p>
<ol>
<li>最长公共子序列</li>
<li>最长公共子串</li>
<li>最长递增子序列</li>
<li>最长连续递增序列</li>
<li>最长回文子串</li>
<li>最长回文子序列</li>
</ol>
<p>简要分析（提纲性质的）：</p>
<ol>
<li>其中最长公共子串和最长公共子序列在弄懂概念和区别之后就一定不会弄混的，他们的实现是十分相似的，需要比对清楚。</li>
<li>最长递增子序列主要是思想（不一定是连续的或者唯一的）</li>
<li>最长连续递增子序列（对最长子序列的一个变式，但是要简单一点，是一个一维的dp问题）</li>
<li>最长回文子串和子序列也有相似之处（回文子串只能在原字符串截取，但是回文子序列可以删除原序列的字符来组成）</li>
</ol>
<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p>牛客网上做这道题哈还是翻车了，根本没有思路，无法下手<br>而且在东哥的算法小抄中也是一道重点的题型，经过几次的回顾之后，发现这道题出现的频率还是比较的高，值得自己把它搞懂，搞透，并且要把这一类的问题触类旁通，也是典型的二维dp的问题，并且是两个字符串之间的。遇到子序列的问题就要想到动态规划的思路。子序列的问题用穷举是很难写出来的，动态规划的思想就是<strong>穷举+剪枝</strong>，是一种很好的匹配的方式。<br><img src="https://runnerxr.github.io/post-images/1652152922115.png"><br>重点是这里的思路！！！！！！！! ! ! (必须弄懂)<br>dp[i][j]表示text1前i个字符和text2中前j个字符的最长公共子序列<br>当前这两个最后的元素是否相同，往前推<br>实际上是分了三种情况进行考虑的<br><strong>当最后的一个字符相同的时候：</strong><br>dp[i-1][j-1]表示text1前i-1个字符和text2中前j-1个字符的最长公共子序列的长度是多少的问题<br>由于当前两个序列最后的一个元素是相同的，所以dp[i][j]&#x3D;dp[i-1][j-1]+1<br><strong>当最后的一个字符不相同的时候：</strong><br>无法在之前的基础上多得到延申，要么在text1中得到延申，要么在text2中得到延申，现在就是要去找延申哪个字符的问题（为什么要这样想的思路要十分的清晰，这里就有了很明显的动态规划的思想了）<br>dp[i][j-1]表示text1前i个字符和text2中前j-1个字符的最长公共子序列的长度<br><img src="https://runnerxr.github.io/post-images/1652153564707.png">：把text1进行延申<br>dp[i-1][j]表示text1前i-1个字符和text2中前j个字符的最长公共子序列的长度<br><img src="https://runnerxr.github.io/post-images/1652153661113.png"><br>两者的较大值就是dp[i][j]的值<br><img src="https://runnerxr.github.io/post-images/1652158223941.png"><br>这里的注意点：需要创建m+1行以及n+1列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m,n=<span class="built_in">len</span>(text1),<span class="built_in">len</span>(text2)</span><br><span class="line">        dp=[[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="comment"># 对text1和text2进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 如果当前两个字符串最后一个字符相等的话</span></span><br><span class="line">                <span class="keyword">if</span> text1[i-<span class="number">1</span>]==text2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j])</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>

<h1 id="leetcoad300-最长递增子序列"><a href="#leetcoad300-最长递增子序列" class="headerlink" title="leetcoad300-最长递增子序列"></a>leetcoad300-最长递增子序列</h1><p>这里地关键点是：最长子序列结尾地元素可能是以nums中任意元素结尾(理解的关键点)<br>同样通过动画自己也是基本已经理解了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 设置一个dp数组，并将其中的值初始化为1</span></span><br><span class="line">        <span class="comment"># dp[i]表示以nums[i]结尾的最长递增子序列的长度</span></span><br><span class="line">        dp=[<span class="number">1</span>]*n</span><br><span class="line">        <span class="comment"># 设置一个数组来记录初始的长度</span></span><br><span class="line">        maxlength=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 对dp数组进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 对原数组进行遍历，其中在遍历的时候不能超过dp中对应的位置</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="comment"># 如果发现nums[i] &gt; nums[j] 并且当前的dp+1要比dp[i]的值要大，说明以最后的一个元素结尾组成的子序列要大一些</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt;nums[j] <span class="keyword">and</span> dp[i] &lt;dp[j] +<span class="number">1</span>:</span><br><span class="line">                    dp[i] = dp[j]+<span class="number">1</span></span><br><span class="line">            <span class="comment"># 在每次遍历完内层循环之后(更新dp[i]的过程中)，都需要比较一下此时dp[i]的值与初始化的1哪个更大</span></span><br><span class="line">            <span class="keyword">if</span> maxlength &lt; dp[i]:</span><br><span class="line">                <span class="comment"># 把更长的子序列的长度赋予给maxlength</span></span><br><span class="line">                maxlength=dp[i]</span><br><span class="line">        <span class="keyword">return</span> maxlength</span><br></pre></td></tr></table></figure>

<h1 id="leetcoad674-最长连续递增序列（easy）"><a href="#leetcoad674-最长连续递增序列（easy）" class="headerlink" title="leetcoad674-最长连续递增序列（easy）"></a>leetcoad674-最长连续递增序列（easy）</h1><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。<br>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果<strong>对于每个 l &lt;&#x3D; i &lt; r，都有 nums[i] &lt; nums[i + 1]</strong> ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。<br>分析：</p>
<ol>
<li>连续递增的子序列，大于它左侧的元素，小于它右侧的元素</li>
<li>如果用动态规划的思路的话：dp[i]的含义：<strong>以nums[i]结尾的最长连续递增序列的长度</strong><br>将每一个位置都填充为1（理解）</li>
<li>要找到最长的，需要定义一个最长的长度</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLengthOfLCIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 采用动态规划的思路来解题</span></span><br><span class="line">        <span class="comment"># 定义一个变量来定义最长的序列长度，初始值为1，表示只要有元素，最小值肯定是1</span></span><br><span class="line">        maxlengh=<span class="number">1</span></span><br><span class="line">        <span class="comment"># dp[i]表示以nums[i]结尾的最长连续递增子序列的长度</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        dp=[<span class="number">1</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="comment"># 如果发现后面的数大于前面的数</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]&gt;nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 更新dp[i]</span></span><br><span class="line">                dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="comment"># 每次判断之后就将dp[i]与maxlength进行比较，maxlength只存储最大的值</span></span><br><span class="line">            <span class="keyword">if</span> dp[i]&gt;maxlengh:</span><br><span class="line">                maxlengh=dp[i]</span><br><span class="line">        <span class="keyword">return</span> maxlengh</span><br></pre></td></tr></table></figure>
<p>运用滑动窗口的思想：<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1h54y1n7yf?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1h54y1n7yf?spm_id_from=333.337.search-card.all.click</a></p>
<h1 id="leetcoad5-最长回文子串"><a href="#leetcoad5-最长回文子串" class="headerlink" title="leetcoad5-最长回文子串"></a>leetcoad5-最长回文子串</h1><p>再次回顾这一题的时候希望有不同的感受<br>题目描述：给你一个字符串 s，找到 s 中最长的回文子串。<br>示例 1：<br>输入：s &#x3D; “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。<br>示例 2：</p>
<p>输入：s &#x3D; “cbbd”<br>输出：”bb”</p>
<h2 id="方法一：采用暴力的方法解题"><a href="#方法一：采用暴力的方法解题" class="headerlink" title="方法一：采用暴力的方法解题"></a>方法一：采用暴力的方法解题</h2><p>要截取字符串的所有子串，然后再判断这些子串中哪些是回文的，最后返回回文子串中最长的即可<br>这里我们可以使用两个变量，一个记录最长回文子串开始的位置，一个记录最长回文子串的长度，最后再截取<br>为了加快访问的速度，我们从最长的字符串开始缩短，这样第一个满足回文子串要求的就是最长的，也即满足题目要求的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        n=<span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 从最大的长度开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> length <span class="keyword">in</span> <span class="built_in">range</span>(n,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 开始位置</span></span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n-length+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 截下来的字符串</span></span><br><span class="line">                sub_string=s[index:length+index]</span><br><span class="line">                <span class="comment"># 将截下来的字符串倒序</span></span><br><span class="line">                temp=sub_string[::-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> sub_string==temp:</span><br><span class="line">                    <span class="comment"># 返回匹配的结果</span></span><br><span class="line">                    <span class="keyword">return</span> sub_string</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s=<span class="string">&quot;cbbd&quot;</span></span><br><span class="line">    res=Solution().longestPalindrome(s) </span><br><span class="line">    <span class="built_in">print</span>(res)   </span><br></pre></td></tr></table></figure>

<h2 id="联系最长公共子串的方法"><a href="#联系最长公共子串的方法" class="headerlink" title="联系最长公共子串的方法"></a>联系最长公共子串的方法</h2><p>根据回文串的定义：正着读和反着读是一样的，我们可以<strong>把原来的字符串倒置，然后找到最长的公共子串就可以了</strong>。求最长公共子串的方法有很多，下面也会整理关于最长公共子串的解法。</p>
<h2 id="方法二：采用中心扩散的方法"><a href="#方法二：采用中心扩散的方法" class="headerlink" title="方法二：采用中心扩散的方法"></a>方法二：采用中心扩散的方法</h2><p>枚举了所有可能的回文子串的中心的位置<br>中心位置可能是一个字符，有可能是有两个相邻的字符<br>记录最长回文子串的相关变量<br><img src="https://runnerxr.github.io/post-images/1654012765422.png"><br>具体的代码如下：</p>
<ol>
<li>做一个特殊情况的判断</li>
<li>枚举回文中心的位置，最后一个位置不需要枚举，不可能再向右边扩散<ol>
<li>以下标i座作为奇数回文子串的在中心，向两边扩散得到的最长回文子串</li>
<li>以下标i作为偶数回文子串的的中心，向两边扩撒得到的最长回文子串</li>
</ol>
</li>
<li>左边界向左，有边界向右，直到不能够匹配为止</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码略，后续感兴趣的时候再做更加深入的了解。</span><br></pre></td></tr></table></figure>
<h2 id="方法三采用动态规划的思路"><a href="#方法三采用动态规划的思路" class="headerlink" title="方法三采用动态规划的思路"></a>方法三采用动态规划的思路</h2><p>回文串具有天然的状态转移性质的<br><img src="https://runnerxr.github.io/post-images/1654091179443.png"><br><img src="https://runnerxr.github.io/post-images/1654091187242.png"><br><img src="https://runnerxr.github.io/post-images/1654091251312.png"><br><img src="https://runnerxr.github.io/post-images/1654091687251.png"><br>思路来源：例如对于字符串 “ababa”，如果我们已经知道 “bab” 是回文串，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是 “a”。（反过来也是的：<strong>一个回文去掉两头之后，剩下的部分依然是回文</strong>）<br>根据这个思路：<br>在<strong>两头字符相等</strong>的情况下，<strong>整体是否是回文</strong>由<strong>中间是否是回文</strong>来决定<br>dp[i][j]的含义：<strong>字符串s第i个字符和第j个字符之间的子串是否是回文子串</strong>（状态转移方程写出来也不容易，还有就是dp数组中存放的是布尔值）<br>只有[i+1，j-1]是回文子串，并且s的第i个元素和第j个字母相同的时候，s[i:j]才会是回文串<br>并且在处理的时候，只需要处理i在j左侧的情况，所以也就对应了下面对i和j遍历时候的取值<br>考虑<strong>边界情况</strong>：</p>
<ol>
<li>如果数组中只有一个元素，一定是回文子串</li>
<li>如果只有两个元素，但是两个元素的值是相同的，那么也是回文子串<br>最终的答案：<br>所有dp[i][j]&#x3D;True中 j-i+1的最大值（从长度较短的字符串向长度较长的字符串进行转移，要注意动态规划的循环顺序）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLongestPalindrome</span>(<span class="params">self , A: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 首先回顾回文子串的定义</span></span><br><span class="line">        <span class="comment"># 构建dp数组，其中dp[i]表示以当前的元素结尾的回文子串的长度，默认回文子串的长度均为1</span></span><br><span class="line">        <span class="comment"># dp[i][j]的含义：**字符串s第i个字符和第j个字符之间的子串是否是回文子串**</span></span><br><span class="line">        n=<span class="built_in">len</span>(A)</span><br><span class="line">        dp=[[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># 构建判断条件，此元素的对称位置元素相同，这样在这个区间内就构成了一个回文子串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[i][i]=<span class="literal">True</span></span><br><span class="line">        <span class="comment"># 记录最长回文子串的长度</span></span><br><span class="line">        max_len=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 设置变量记录最长的回文子串的开始位置</span></span><br><span class="line">        <span class="comment"># 从后向前寻找</span></span><br><span class="line">        begin=n-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 不断地逼近二维数组最右上角地位置，求dp[0][n-1]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line">                <span class="comment"># 如果发现首尾相等</span></span><br><span class="line">                <span class="keyword">if</span> A[i]==A[j]:</span><br><span class="line">                    <span class="comment"># 如果[i,j]这个区间只有两个字符，并且两个字符还是一样，则必然是回文子串</span></span><br><span class="line">                    <span class="keyword">if</span> (j-i+<span class="number">1</span>)==<span class="number">2</span>:</span><br><span class="line">                        dp[i][j]=<span class="literal">True</span></span><br><span class="line">                    <span class="comment"># 否则，当前这个区间是否是回文子串取决于[i+1，j-1]是不是回文子串</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 如果首尾不相等地话就必然不是回文子串</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=<span class="literal">False</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 更新回文子串地长度</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> j-i+<span class="number">1</span>&gt;max_len:</span><br><span class="line">                    <span class="comment"># 更新最长回文子串地长度</span></span><br><span class="line">                    max_len=j-i+<span class="number">1</span></span><br><span class="line">                    <span class="comment"># 更新最长回文子串开始的位置</span></span><br><span class="line">                    begin=i</span><br><span class="line">        <span class="comment"># 通过截取的方式返回最长回文子串</span></span><br><span class="line">        <span class="comment"># return A[begin:begin+max_len]</span></span><br><span class="line">        <span class="keyword">return</span> max_len              </span><br></pre></td></tr></table></figure>
写完动态规划的解法之后，有几点重要的位置仍然需要自己好好的琢磨一下，用云线在图中标识出来了<br><img src="https://runnerxr.github.io/post-images/1654095768350.png"></li>
</ol>
<h1 id="leetcoad516-最长回文子序列"><a href="#leetcoad516-最长回文子序列" class="headerlink" title="leetcoad516-最长回文子序列"></a>leetcoad516-最长回文子序列</h1><p>题目描述：<br>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。<br>理解回文子序列的定义：<br>子序列：不改变剩余顺序的情况下，删除某些字符或者不删除任何字符形成的序列<br>子数组：必须连续的<br><img src="https://runnerxr.github.io/post-images/1652194185867.png">用这张图片来帮助自己去理解<br>在找到一个回文子序列的基础上继续进行查找，找到一个更长的回文子序列：在已有的回文子序列左右两端加入新的元素组成新的区间，并判断左右两端加入后的长度是否大于之前的回文子序列的长度，如果是就更新最长回文子序列，继续进行查找</p>
<ol>
<li>当左右两边加入的值不相等的时候，需要进行分类讨论</li>
<li>只在左边进行加入，能否将之前的回文子序列加长</li>
<li>只在右边进行加入，能否将之前的回文子序列加长</li>
<li>进行一个对比，把最大的赋值给当前的区间</li>
</ol>
<p>代码实现：</p>
<ol>
<li><strong>dp[i][j]表示字符串s第i个字符和第j个字符之间的最长的回文子序列的长度s[i….j]</strong></li>
<li>对于i和j相同的情况，就是单独的一个数，是回文子序列</li>
<li>j始终在i的右侧</li>
<li>i从最右边开始，然后往左边移动，j在i的右边，向右边移动（无法直接找到中间两个点然后向两边进行相应的延申）</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 采用动态规划的思路</span></span><br><span class="line">        <span class="comment"># dp[i][j]表示字符串s[i...j]之间的最长回文子序列的长度</span></span><br><span class="line">        <span class="comment"># 这里的遍历方式要结合相应的动画来分析：i从后向前遍历，j从i的右边开始从左向右开始遍历</span></span><br><span class="line">        n=<span class="built_in">len</span>(s)</span><br><span class="line">        dp=[[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[i][i]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line">                <span class="comment"># 当发现s[i]==s[j]的时候，可以让dp[i-1][j-1]上进行相应的扩充，长度+1</span></span><br><span class="line">                <span class="keyword">if</span> s[i]==s[j]:</span><br><span class="line">                    dp[i][j]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">2</span></span><br><span class="line">                <span class="comment"># 当s[i]!=s[j]的时候，这个时候体现了动态规划的思路。将左边的字符串加入和将右边的字符串加入dp[i-][j-1]构成：dp[i][j-1]和dp[i+1][j]</span></span><br><span class="line">                <span class="comment"># 比较两者的最大值作为dp[i][j]的值</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i][j-<span class="number">1</span>],dp[i+<span class="number">1</span>][j])</span><br><span class="line">        <span class="comment"># 循环结束，返回最后的值</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="BM65-最长公共子序列"><a href="#BM65-最长公共子序列" class="headerlink" title="BM65-最长公共子序列"></a>BM65-最长公共子序列</h1><p>题目的主要信息：</p>
<ol>
<li>找到两个字符串的最长公共子序列</li>
<li>仅存在一个最长的公共子序列，不需要去重</li>
<li>没有找到的时候，返回-1，需要变换（这里是一个隐藏的坑）</li>
</ol>
<p>思路：先得到最长公共子序列的长度（获取长度的思路已经知晓），然后根据这个长度来获取这个子序列（这里才是本道题有一个重点的部分，用到了栈的弹出的小知识，也是一个很关键的点，如果不是做题的话估计自己也很难想到这样的方法。需要对栈进行活学活用，而且要能够快速的反应过来，确实很考验代码和逻辑的思维能力！！！！！！）<br>在构造表的同时，用一个二维矩阵记录上面状态转移时选择的方向，用1表示来自左上方，用2表示来至左边，用3表示来自上边。<br>获取这个序列的时候，根据从最后一位开始，根据记录方向，不断地递归往前组装字符，只有来自左上的时候才添加本级字符（<strong>这种情况是动态规划中两个字符相等的情况，字符相等的时候才可以用</strong>）<br>这里看得到一个非常好的练习的线上的表格，帮自己完完全全的梳理了一下这个过程，一下子茅塞顿开。<br>链接如下：<a target="_blank" rel="noopener" href="https://alchemist-al.com/algorithms/longest-common-subsequence">https://alchemist-al.com/algorithms/longest-common-subsequence</a><br><img src="https://runnerxr.github.io/post-images/1652192059144.png"><br>自己也用excel手动做了一个表格的演示过程<br>这是一张动态规划的过程图：我用箭头表示的方向就是表的数值不断形成的方向（当遍历的时候最后两个字符不等，来自左边和上边相同的时候，我人为优先来自左边，实际计算机会判断，两个一样大的时候任取一个就行）<br><img src="https://runnerxr.github.io/post-images/1652234949755.png"><br>下面两张是回溯的过程，目的是为了找到最长的公共子序列到底是哪几个的问题？以下的两种方法都能够找到最长的公共子序列’bcba’,这也是写代码的核心基础部分，这个过程至少是要十分熟悉的。<br>一开始选择来自上方的情况，就是红色的这个路径：<br><img src="https://runnerxr.github.io/post-images/1652235526690.png"><br>一开始选择来自左方的情况，就是绿色的这个路径：<br><img src="https://runnerxr.github.io/post-images/1652234928403.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LCS</span>(<span class="params">self , s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 首先采用二维dp来解题</span></span><br><span class="line">        <span class="comment"># dp[i][j]表示s1中前i个字符和s2中前j个字符的最长公公共子序列</span></span><br><span class="line">        <span class="comment"># 当两个字符串最后一个字符是相同的时候</span></span><br><span class="line">        <span class="comment"># dp[i][j]=dp[i-1][j-1]+1</span></span><br><span class="line">        <span class="comment"># 当两个字符串最后一个字符不是相同的时候，看到底是由s1延申过来，还是由s2延申过程</span></span><br><span class="line">        <span class="comment"># dp[i][j-1]:表示s1中前i个字符与s2中前j-1个字符的最长公共给子序列</span></span><br><span class="line">        <span class="comment"># dp[i-1][j]表示s1中的前i-1个字符与s2中前j个字符的最长公共子序列</span></span><br><span class="line">        m,n=<span class="built_in">len</span>(s1),<span class="built_in">len</span>(s2)</span><br><span class="line">        dp=[[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 初始条件</span></span><br><span class="line">        <span class="comment"># 当s1或者s2为空字符串的时候,最长公共子串均为0</span></span><br><span class="line">        <span class="keyword">if</span> m==<span class="number">0</span> <span class="keyword">or</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;-1&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 判断当前遍历的最后一个字符是否相</span></span><br><span class="line">                <span class="keyword">if</span> s1[i-<span class="number">1</span>]==s2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                <span class="comment"># 当最后一个字符不相等的时候</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j])</span><br><span class="line">        <span class="comment"># 找到最大长度之后，还要把对应的值给输出来</span></span><br><span class="line">        <span class="comment"># return dp[m][n]</span></span><br><span class="line">        <span class="comment">#print(dp)</span></span><br><span class="line">        <span class="comment"># # 从动态规划数组的末尾开始</span></span><br><span class="line">        i,j=m,n</span><br><span class="line">        <span class="comment"># 构建一个临时的栈，用来从后向前储存相同的字符</span></span><br><span class="line">        temp=[]</span><br><span class="line">        <span class="keyword">while</span> dp[i][j] !=<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 来自左方向</span></span><br><span class="line">            <span class="keyword">if</span> dp[i][j]==dp[i-<span class="number">1</span>][j]:</span><br><span class="line">                i=i-<span class="number">1</span></span><br><span class="line">            <span class="comment"># 来自上方向</span></span><br><span class="line">            <span class="keyword">elif</span> dp[i][j]==dp[i][j-<span class="number">1</span>]:</span><br><span class="line">                j= j-<span class="number">1</span></span><br><span class="line">            <span class="comment"># 来自左上方</span></span><br><span class="line">            <span class="keyword">elif</span> dp[i][j]&gt;dp[i-<span class="number">1</span>][j-<span class="number">1</span>]:</span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 只有左上方才是字符相等的情况，入栈，逆序使用</span></span><br><span class="line">                temp.append(s1[i])</span><br><span class="line">        <span class="comment"># 循环结束之后，进行子序列的拼接</span></span><br><span class="line">        <span class="comment"># print(temp)</span></span><br><span class="line">        res=<span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(temp)!=<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 将temp中的元素不断地弹出并加入到res字符串中</span></span><br><span class="line">            res+=temp.pop()</span><br><span class="line">        <span class="comment">#如果两个完全不同，返回字符串为空，需要改为-1</span></span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> res==<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;-1&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="BM66-最长公共子串"><a href="#BM66-最长公共子串" class="headerlink" title="BM66- 最长公共子串"></a>BM66- 最长公共子串</h1><p>注意审题：<strong>最长的公共子串</strong>，不是最长的公共子序列，<strong>子序列可以不是连续的</strong>，但是<strong>子串一定是连续的</strong>。（这里的理解对于做题来说是十分的关键的，一道题能够读懂也十分重要的）<br>看到题解的时候有<strong>一个枚举的思路</strong>，对于自己的思维锻炼很有帮助，而且动态规划就是<strong>从枚举的思路上发展而来的</strong>，需要考验的是自己的能够<strong>有枚举的思路</strong>，而且还能<strong>由枚举来想到用动态规划的思路</strong>。（枚举是思维的核心所在！！！！）<br>参考链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/f33f5adc55f444baa0e0ca87ad8a6aac?tpId=295&amp;tqId=991150&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=/exam/oj">https://www.nowcoder.com/practice/f33f5adc55f444baa0e0ca87ad8a6aac?tpId=295&amp;tqId=991150&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj</a><br>枚举所有的子串进行比较，不用完全枚举的形式，尝试做一点改良</p>
<ol>
<li>遍历两个字符串的所有字符串作为起始(实际上遍历小的就可以了，所以最开始有一个<strong>比较大小</strong>并互换的过程)</li>
<li>同时开始检查字符是否相等，相等的话就不断地后移，增加子串地长度，<strong>如果不说明以这两个为起点地子串截至了，不会再有了</strong>。(这里也是同动态规划地思想一致的)</li>
<li>后续比较长度维护最大值即可。<br><img src="https://runnerxr.github.io/post-images/1652175614590.png"><br>下面的这种代码的思路上面写的是有点区别的，主要是这行代码：<code>if str1[i - max_len : i + 1] in str2: </code>，可能也是python比较巧妙地一个地方所在。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写代码的核心思维思维</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LCS</span>(<span class="params">self , str1: <span class="built_in">str</span>, str2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment">#让str1为较长的字符串</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(str1) &lt; <span class="built_in">len</span>(str2): </span><br><span class="line">            str1, str2 = str2, str1</span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="comment">#遍历str1的长度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str1)): </span><br><span class="line">            <span class="comment">#查找是否存在</span></span><br><span class="line">            <span class="keyword">if</span> str1[i - max_len : i + <span class="number">1</span>] <span class="keyword">in</span> str2: </span><br><span class="line">                res = str1[i - max_len : i + <span class="number">1</span>]</span><br><span class="line">                max_len += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<strong>采用动态规划的思路来解题：</strong><br>这题和最长的公共子序列也有一定的联系：比如构建dp数组的含义，dp数组的长度以及大小（这种题型要形成自己的思考定式下次碰到的时候就可以直接写了）<br>定义dp[i][j]表示字符串<strong>str1中第i个字符</strong>和<strong>str2种第j个字符</strong>为<strong>最后一个元素</strong>所构成的最长公共子串。如果要求dp[i][j]，也就是str1的第i个字符和str2的第j个字符为最后一个元素所构成的最长公共子串，我们<strong>首先需要判断这两个字符是否相等</strong>。(相当于是递推公式)</li>
<li>如果不相等，那么他们就不能构成公共子串，也就是dp[i][j]&#x3D;0</li>
<li>如果相等的话，我们还需要计算前面相等字符的个数：即dp[i-1][j-1]<br><img src="https://runnerxr.github.io/post-images/1652191419226.png"><br>自己用表格罗列了这样的一个过程，帮助自己去理解。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#很遗憾，采用动态规划的思路，用例并不能全盘的通过</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LCS</span>(<span class="params">self , str1: <span class="built_in">str</span>, str2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 设置二维dp数组,dp[i][j]表示在str1的前i个字符，str2的前j个字符中最长公共子串的个数</span></span><br><span class="line">        <span class="comment"># 当其中某个字符串长度为0的时候一定是空串</span></span><br><span class="line">        m,n=<span class="built_in">len</span>(str1),<span class="built_in">len</span>(str2)</span><br><span class="line">        maxlengh=<span class="number">0</span></span><br><span class="line">        dp=[[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 分别在两个字符串中进行遍历</span></span><br><span class="line">        <span class="comment"># 目的是为了找到最长公共子串的长度</span></span><br><span class="line">        <span class="comment"># 其中公共子串是需要连续的</span></span><br><span class="line">        <span class="comment"># i在第一个字符串中进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># j在第二个字符串中进行遍历</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 如果两个字符串当前遍历的最后一个字符相等,就增加公共子串的长度</span></span><br><span class="line">                <span class="keyword">if</span> str1[i-<span class="number">1</span>]==str2[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 更新，找到它斜上角的值+1</span></span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果不相等的话，需要将dp[i][j]置为0，一旦不等的时候就会断开</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=<span class="number">0</span></span><br><span class="line">                <span class="comment"># 判断结束之后，用一个数组来接受最大的长度</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j]&gt;maxlengh:</span><br><span class="line">                    <span class="comment"># 更新最大值</span></span><br><span class="line">                    maxlengh=dp[i][j]</span><br><span class="line">                    <span class="comment"># 此时pos记录的就是正常字符串的下标（从0开始的）</span></span><br><span class="line">                    pos=i-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 最后通过对任意一个字符串进行切分来返回最长的公共子串</span></span><br><span class="line">        <span class="keyword">return</span> str1[pos-maxlengh+<span class="number">1</span>:pos+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
再次回顾的时候，发现还是做不出来！！！大哭大哭</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%90%88%E9%9B%86%EF%BC%88%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%89/" data-id="claqu8zze0023iwtkh1rj1iuk" data-title="动态规划合集（系列二）" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-贪心算法合集" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/17/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/" class="article-date">
  <time class="dt-published" datetime="2022-03-17T13:50:14.000Z" itemprop="datePublished">2022-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/17/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/">贪心算法合集</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>贪心算法的几道经典的题目，体会里面的思想和精髓<br>贪心可以看做是特殊的动态规划问题，可以进一步的降低动态规划的时间复杂度，利用贪心原则从内向外依次的求出当前子问题的最优解，不会从整体考虑问题，而是想要达到局部最优，只有内部的子问题求得最优解，才能继续解决包含子问题的下一个子问题，<strong>前一个子问题的最优解会是下一个子问题最优解的一部分</strong>。贪心算法解决相应问题时会比较简单和高效，省去了寻找全局最优解很多不必要的穷举操作，由于贪心算法问题并没有固定的贪心策略，所以唯一的难点就是找到带求解问题的贪心策略，但毕竟熟能生巧嘛，算法的基本思想总是固定不变的。<br><img src="https://runnerxr.github.io/post-images/1653186458626.png"><br>基本步骤如下：</p>
<ol>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ol>
<p>还可以解决哪些问题：<br><strong>区间的调度问题：</strong>(InTERVAL Scheduling)<br>给很多的[start,end]区间是，设计一个算法，算出这些区间中<strong>最多有多少个互不相交的区间</strong><br>实际的一些应用（预定会议）：今天有好几个活动，每个活动都可以用区间[start,end]来表示开始和结束时间，请问最<strong>多能够参加几个活动的问题</strong>，这个问题就是在求这些<strong>时间区间的最大不相交子集的问题</strong><br>采用贪心的思路，正确的步骤如下：</p>
<ol>
<li>从区间集合intvs中选择一个区间x，这个x是在<strong>当前所有区间中结束最早的</strong>（end最小）：可以把每个区间的<strong>end按升值排序</strong></li>
<li>把所有与x区间相交的区间从区间集合intvs中删除</li>
<li>重复1和2的步骤，<strong>直到intvs为空</strong>为止，之前选出的那些x就是最大不相交子集</li>
</ol>
<p>下面的这张图用于辅助理解：<br><img src="https://runnerxr.github.io/post-images/1653225148591.gif"><br><img src="https://runnerxr.github.io/post-images/1653225273943.jpg"><br>相关实现的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">intervalSchedule</span><span class="params">(<span class="type">int</span>[] [] intvs)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intvs.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 按end升序排序</span></span><br><span class="line">    Arrays.sort(intvs,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;()&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//至少有一个区间不相交</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">//排序后，第一个区间就是x</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x_end</span> <span class="operator">=</span> intvs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] interval:intvs) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> interval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= x_end) &#123;</span><br><span class="line">            <span class="comment">// 找到下一个选择的区间了</span></span><br><span class="line">            count++;</span><br><span class="line">            x_end = interval[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里理解清楚了就可以看看无重叠区间这一道题目</p>
<p>主要的几道题目：（有几道暂时没有整理，有空或者后面的时候再做）</p>
<ol>
<li>leetcoad455-分发饼干</li>
<li>leetcoad376-摆动序列</li>
<li>leetcoad134-加油站</li>
<li>leetcoad860-柠檬水找零</li>
<li>LeetCode 55跳跃游戏</li>
<li>leetcoad322-零钱兑换</li>
<li>leetcoad11-盛最多水的游戏</li>
<li>LeetCode 452-用最少数量的箭引爆气球</li>
<li>leetcoad435.无重叠区间</li>
<li>LeetCode 402移掉 K 位数字</li>
<li>LeetCode 763划分字母区间</li>
<li>LeetCode 56合并区间</li>
</ol>
<p>本质上是先用暴力解法，然后在优化的基础上想出贪心的解法</p>
<h1 id="leetcoad455-分发饼干（easy）"><a href="#leetcoad455-分发饼干（easy）" class="headerlink" title="leetcoad455-分发饼干（easy）"></a>leetcoad455-分发饼干（easy）</h1><p>leetcoad链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/assign-cookies/">https://leetcode-cn.com/problems/assign-cookies/</a><br>这道题之前自己也做过，所以也是需要自己来认真进行整理的一部分，比较典型的一题<br>解题思路如下：</p>
<ol>
<li>将孩子们的胃口值小到大的排列<ul>
<li>先优先满足胃口小的孩子</li>
</ul>
</li>
<li>将饼干按照从小到大的顺序排列<ul>
<li>child 代表 g 的下标，即表示有多少孩子的胃口得到满足（思想）</li>
<li>cookie 代表 s 的下标，即表示目前有多少饼干被使用了</li>
</ul>
</li>
<li>遍历所有饼干，遍历过后，饼干只有两种状态（要么有了归属，要么被丢弃）<ul>
<li>要么找到了需要这个饼干的孩子</li>
<li>要么剩下的孩子中，胃口值最低的孩子都大于这个饼干的值，那么这个饼干没有人要<ul>
<li>比如一块饼干在当前不能满足孩子的需求，那么这块饼干在剩下的饼干中就更不能满足相应的需求，这块饼干就失去了分发的意义了</li>
<li>查看下一个饼干能否找到需要的孩子（查看下一个饼干的状态）</li>
</ul>
</li>
</ul>
</li>
<li>返回孩子的数量<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findContentChildren</span>(<span class="params">self, g: <span class="type">List</span>[<span class="built_in">int</span>], s: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        g.sort()     <span class="comment">#对g进行排序</span></span><br><span class="line">        s.sort()     <span class="comment">#对s进行排序</span></span><br><span class="line">        n, m = <span class="built_in">len</span>(g), <span class="built_in">len</span>(s)   <span class="comment">#记录g 和 s的数组长度</span></span><br><span class="line">        i = j = count = <span class="number">0</span>       <span class="comment">#设定变量的下标的初始条件为0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:</span><br><span class="line">            <span class="keyword">while</span> j &lt; m <span class="keyword">and</span> g[i] &gt; s[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; m:</span><br><span class="line">                count += <span class="number">1</span>    <span class="comment">#cout = count + 1</span></span><br><span class="line">            i += <span class="number">1</span>            <span class="comment">#i = i +1</span></span><br><span class="line">            j += <span class="number">1</span>            <span class="comment">#j = j +1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">a = Solution()</span><br></pre></td></tr></table></figure>
采用吴师兄的思路来解答：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findContentChildren</span>(<span class="params">self, g: <span class="type">List</span>[<span class="built_in">int</span>], s: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 1、将孩子们的胃口值按照从小到大的顺序排列</span></span><br><span class="line">        <span class="comment"># 优先满足胃口小的孩子</span></span><br><span class="line">        g.sort()</span><br><span class="line">        <span class="comment"># 2、将饼干按照从小到大的顺序排列</span></span><br><span class="line">        s.sort()</span><br><span class="line">        <span class="comment"># child 代表 g 的下标，即表示有多少孩子的胃口得到满足</span></span><br><span class="line">        child = <span class="number">0</span></span><br><span class="line">        <span class="comment"># cookie 代表 s 的下标，即表示目前有多少饼干被使用了</span></span><br><span class="line">        cookie = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历所有的饼干</span></span><br><span class="line">        <span class="comment"># 遍历过后，饼干只有两种状态</span></span><br><span class="line">        <span class="comment"># 1、要么找到了需要这个饼干的孩子</span></span><br><span class="line">        <span class="comment"># 2、要么剩下的孩子中，胃口值最低的孩子都大于这个饼干的值，那么这个饼干没人要</span></span><br><span class="line">        <span class="keyword">while</span> cookie &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> child &lt; <span class="built_in">len</span>(g):</span><br><span class="line">            <span class="comment"># 孩子的胃口得到了满足</span></span><br><span class="line">            <span class="keyword">if</span> s[cookie] &gt;= g[child]:</span><br><span class="line">                <span class="comment"># 得到满足的孩子数量加 1</span></span><br><span class="line">                child += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 查看下一个饼干能否找到需要的孩子</span></span><br><span class="line">            cookie +=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 最后返回孩子数量</span></span><br><span class="line">        <span class="keyword">return</span> child</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad376-摆动序列-middle"><a href="#leetcoad376-摆动序列-middle" class="headerlink" title="leetcoad376-摆动序列(middle)"></a>leetcoad376-摆动序列(middle)</h1><p>leetcoad链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/wiggle-subsequence/">https://leetcode-cn.com/problems/wiggle-subsequence/</a><br>视频链接：<a target="_blank" rel="noopener" href="https://www.algomooc.com/1341.html">https://www.algomooc.com/1341.html</a><br>题目描述：<br>如果<strong>连续数字之间的差</strong>严格地在<strong>正数和负数之间交替</strong>，则数字序列称为 <strong>摆动序列</strong> 。第一个差（如果存在的话）可能是正数或负数。<strong>仅有一个元素****或者</strong>含<strong>两个不等元素的序列</strong>也视作摆动序列。<br>    1. 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。<br>    2. 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。<br><strong>子序列</strong> 可以通过从<strong>原始序列</strong>中<strong>删除</strong>一些（也可以不删除）元素来获得，<strong>剩下的</strong>元素保持其<strong>原始顺序</strong>。<br>给你一个整数数组 nums ，返回 nums 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。<br>实例一：<br>输入：nums &#x3D; [1,7,4,9,2,5]<br>输出：6<br>解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。</p>
<p>实例二：<br>输入：nums &#x3D; [1,17,5,10,13,15,10,5,16,8]<br>输出：7<br>解释：这个序列包含几个长度为 7 摆动序列。<br>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。</p>
<p>首先就是需要理解题意：<br>这里有几个关键词：<strong>子序列</strong>，<strong>摆动序列</strong>（两数之差交替摆动：有上升摆动序列、下降摆动序列），可以删除，最长<br>解题步骤如下：</p>
<ol>
<li>在原数组中挑选出一些元素组成子序列，维持一个摆动序列的状态</li>
<li>对于每一个元素都会处理三种状态<ol>
<li>当前元素没有加入摆动序列</li>
<li>当前元素处理上升状态</li>
<li>当前元素处于下降状态</li>
</ol>
</li>
<li>遍历元素，选出三种状态构成摆动序列<br>以下用几组图片辅助理解：<br><img src="https://runnerxr.github.io/post-images/1653237487907.png"><br><img src="https://runnerxr.github.io/post-images/1653237506021.png"><br><img src="https://runnerxr.github.io/post-images/1653237526029.png"><br><img src="https://runnerxr.github.io/post-images/1653237543722.png"><br>这题按照思路还是用的贪心的思想，只有<strong>真正的V型</strong>（波峰或者波谷位置）<strong>翻转</strong>才会增加摆动序列的长度。。但是很显然也是可以用动态规划的思路来解题的，不过这里由于时间原因，也只能先搞懂其中的一种方法（把其中的一种方式弄懂已经很花费精力了，太难了）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wiggleMaxLength</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 定义三种状态：0，1 ，2分别表示初始，上升以及下降状态</span></span><br><span class="line">        beginState,upState,downState=<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果数组的长度只有1，直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        length=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从初始状态开始</span></span><br><span class="line">        state=beginState</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 1. 位于初始状态</span></span><br><span class="line">            <span class="keyword">if</span> state ==beginState:</span><br><span class="line">                <span class="comment"># 如果此时nums[i] &gt; nums[i-1],代表着现在处于上升过程</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[i-<span class="number">1</span>]:</span><br><span class="line">                    state=upState</span><br><span class="line">                    length+=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果nums[i] &lt;nums[i-1],代表着现在处于下降过程</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i]&lt;nums[i-<span class="number">1</span>]:</span><br><span class="line">                    state=downState</span><br><span class="line">                    length+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 2. 位于上升状态</span></span><br><span class="line">            <span class="keyword">elif</span> state==upState:</span><br><span class="line">                <span class="comment"># 只有nums[i]&lt;nums[i-1]时，此时nums[i-2] ,nums[i-1],nums[i]这三者形成了一个波峰</span></span><br><span class="line">                <span class="comment"># 状态开始翻转，由之前的上升状态变为下降状态，同时摆动序列的长度+1</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt; nums[i-<span class="number">1</span>]:</span><br><span class="line">                    state=downState</span><br><span class="line">                    length+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 3. 位于下降状态</span></span><br><span class="line">            <span class="keyword">elif</span> state==downState:</span><br><span class="line">                <span class="comment"># 只有nums[i]&gt;nums[i-1]时，此时nums[i-2] ,nums[i-1],nums[i]这三者形成了一个波谷</span></span><br><span class="line">                <span class="comment"># 状态开始翻转，由之前的下降状态变为上升状态，同时摆动序列的长度+1</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[i-<span class="number">1</span>]:</span><br><span class="line">                    state=upState</span><br><span class="line">                    length+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums = [<span class="number">1</span>,<span class="number">17</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">16</span>,<span class="number">8</span>]</span><br><span class="line">    res=Solution().wiggleMaxLength(nums)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
这里还有一篇参考资料值得借鉴，主要是写的十分的详细<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-subsequence/solution/python3-yi-tu-sheng-qian-yan-by-v12de-ao-72b1/">https://leetcode.cn/problems/wiggle-subsequence/solution/python3-yi-tu-sheng-qian-yan-by-v12de-ao-72b1/</a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wiggleMaxLength</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 用trend表示摆动序列最后的趋势：0代表未知（即初始状态），-1代表下降，1代表上升</span></span><br><span class="line">        res,trend=<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 如果发现当前的数比之前的数大，并且当前是初始状态或下降状态</span></span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;nums[i-<span class="number">1</span>] <span class="keyword">and</span> trend&lt;=<span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 长度+1，同时状态转变为上升状态</span></span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">                trend=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果发现当前的数比之前的数小，并且当前要么是初始或上升状态</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i]&lt;nums[i-<span class="number">1</span>] <span class="keyword">and</span> trend&gt;=<span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 长度+1，同时状态转变为下降状态</span></span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">                trend=-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums = [<span class="number">1</span>,<span class="number">17</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">16</span>,<span class="number">8</span>]</span><br><span class="line">    res=Solution().wiggleMaxLength(nums)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad134-加油站-middle"><a href="#leetcoad134-加油站-middle" class="headerlink" title="leetcoad134-加油站(middle)"></a>leetcoad134-加油站(middle)</h1><p>leetcoad链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gas-station/">https://leetcode-cn.com/problems/gas-station/</a><br>视频链接：<a target="_blank" rel="noopener" href="https://www.algomooc.com/1737.html">https://www.algomooc.com/1737.html</a><br>比较有循序渐进的解题思路，值得借鉴：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gas-station/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--30/">https://leetcode-cn.com/problems/gas-station/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--30/</a><br>题目解读：每个节点表示添加的油量，每条边表示消耗的油量，题目的意思是问问我们从哪个节点出发还可以回到该节点，只能用顺时针的方式。<br>后面可以尝试运用多种解法来解题，开阔自己的思路，必须要从暴力解法开始，一步步的进行相应的优化过程才是一个良性的过程<br><strong>解法一：暴力解法</strong><br>考虑从第 0 个点出发，能否回到第 0 个点。<br>考虑从第 1 个点出发，能否回到第 1 个点。<br>…<br>考虑从第 n 个点出发，能否回到第 n 个点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#此种解法超时，不能通过</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canCompleteCircuit</span>(<span class="params">self, gas: <span class="type">List</span>[<span class="built_in">int</span>], cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#获取加油站的数量</span></span><br><span class="line">        n = <span class="built_in">len</span>(gas)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment">#初始化：最开始剩余的油量就第一个点的油量</span></span><br><span class="line">            remainGas = gas[i]</span><br><span class="line">            <span class="comment">#当前剩余的油能否达到下一个点</span></span><br><span class="line">            <span class="keyword">while</span> (remainGas-cost[j]) &gt;=<span class="number">0</span>:</span><br><span class="line">                remainGas =remainGas - cost[j] +gas[(j +<span class="number">1</span>)%n]</span><br><span class="line">                j = (j +<span class="number">1</span>)%n</span><br><span class="line">                <span class="comment">#判断j是否回到了i</span></span><br><span class="line">                <span class="keyword">if</span> j==i:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>解法二：贪心算法</strong><br>此道题的要点如下：<br>step1:统计所有加油站汽油的总量能否支持汽车跑完全部的路程,，如果不能则无论从哪里出发都不可能绕环路行驶一周<br>step2：一开始默认的出发点的储油量0，默认出发位置的索引在0 ，依次遍历每个加油站，在遍历的过程中执行跳跃操作（这里要理解这里的重复计算的操作，这里是隐含着一定的证明的）<br>    - 如果发现邮箱里面是非负数就可以直接的往前面开<br>    - 如果发现是负数，就直接从新的j号节点开始出发就行<br>时间复杂度：O(n):两次循环都是单层的<br>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canCompleteCircuit</span>(<span class="params">self, gas: <span class="type">List</span>[<span class="built_in">int</span>], cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#获取加油站的数量</span></span><br><span class="line">        n = <span class="built_in">len</span>(gas)</span><br><span class="line">        <span class="comment">#初始默认汽车的储备量为0</span></span><br><span class="line">        remainGas = <span class="number">0</span></span><br><span class="line">        <span class="comment">#统计所有加油站汽油的总量能否支持汽车跑完全部的路程</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n):</span><br><span class="line">            remainGas +=gas[i] - cost[i]</span><br><span class="line">        <span class="comment">#如果发现加油站汽油的总量小于所有的路程所要消耗的汽油的总量</span></span><br><span class="line">        <span class="comment">#汽车最终邮箱的汽油为负，无论选择在哪里出发，都不可能绕行环路行驶一周</span></span><br><span class="line">        <span class="keyword">if</span> remainGas &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment">#一开始默认汽车此时储备的汽车油量为 0</span></span><br><span class="line">        currentGas = <span class="number">0</span></span><br><span class="line">        <span class="comment">#一开始默认汽车出发位置的索引在0的位置</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="comment">#index表示最终选择的出发点，默认为0</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="comment">#依次遍历每个加油站，在遍历的过程中，执行相应的跳跃操作</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="comment">#汽车在i号加油站加了gas[i]</span></span><br><span class="line">            <span class="comment">#汽车开到i+1号加油站消耗了cost[i]的汽油</span></span><br><span class="line">            currentGas +=gas[i] - cost[i]</span><br><span class="line">            <span class="keyword">if</span> currentGas &gt;=<span class="number">0</span>:</span><br><span class="line">                i +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#如果发现油箱里面的汽油是负数</span></span><br><span class="line">            <span class="comment">#即汽车可以开到 j号加油站，j &gt;= i + 1,那么让汽车继续的往前开</span></span><br><span class="line">            <span class="comment">#否则就直接尝试让汽车从j号加油站重新出发</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#重新初始化汽车邮箱的油量</span></span><br><span class="line">                currentGas = <span class="number">0</span></span><br><span class="line">                <span class="comment">#最终选择的出发点为j号加油站</span></span><br><span class="line">                index = i+<span class="number">1</span></span><br><span class="line">                <span class="comment">#重新开始出发</span></span><br><span class="line">                i +=<span class="number">1</span></span><br><span class="line">        <span class="comment">#最终找到了合适的出发点</span></span><br><span class="line">        <span class="keyword">return</span> index</span><br></pre></td></tr></table></figure>
<h1 id="leetcoad860-柠檬水找零（easy）"><a href="#leetcoad860-柠檬水找零（easy）" class="headerlink" title="leetcoad860-柠檬水找零（easy）"></a>leetcoad860-柠檬水找零（easy）</h1><p>leetcoad链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lemonade-change/solution/">https://leetcode-cn.com/problems/lemonade-change/solution/</a><br>视频链接:<a target="_blank" rel="noopener" href="https://www.algomooc.com/935.html">https://www.algomooc.com/935.html</a><br>主要用到的贪心算法的思路<br>由于顾客只可能给你三个面值的钞票，而且我们一开始没有任何钞票，因此我们拥有的钞票面值只可能是 5美元，10 美元和 20美元三种。基于此，我们可以进行如下的分类讨论。</p>
<ol>
<li>5美元：直接收钱，不需要找零</li>
<li>10美元：如果有5块，直接找零，如果没有找零失败</li>
<li>20美元：我们需要找回 15 美元<ul>
<li>如果手中有 10 元 和 5 元钞票，则找零 1 张 10 元和 1 张 5 元的钞票</li>
<li>如果手中只有 5 元的，<ul>
<li>数量超过或者等于 3 张，那么找零 3 张 5 元的钞票</li>
<li>没有则找零失败<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lemonadeChange</span>(<span class="params">self, bills: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">#用来记录5元钞票的数量</span></span><br><span class="line">        five,ten = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(bills)</span><br><span class="line">        <span class="comment">#顾客开始按顺序购买并找零</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n):</span><br><span class="line">            <span class="comment">#如果发现是5元面额</span></span><br><span class="line">            <span class="keyword">if</span> bills[i] ==<span class="number">5</span>:</span><br><span class="line">                five +=<span class="number">1</span></span><br><span class="line">            <span class="comment">#如果发现是10元的面额</span></span><br><span class="line">            <span class="comment">#如果手中有5元的钞票，则找零5元</span></span><br><span class="line">            <span class="keyword">elif</span> bills[i] ==<span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span>  five &gt;<span class="number">0</span>:</span><br><span class="line">                    five -=<span class="number">1</span></span><br><span class="line">                    ten +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment">#如果发现给的是20元的钞票</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#如果手中有10元和5元的钞票，找零一张10元和一张5元</span></span><br><span class="line">                <span class="keyword">if</span> ten &gt;<span class="number">0</span> <span class="keyword">and</span> five &gt;<span class="number">0</span>:</span><br><span class="line">                    ten -=<span class="number">1</span></span><br><span class="line">                    five -=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#如果手中只有5元的，并且数量&gt;=3张，那么就找零三张5元的钞票</span></span><br><span class="line">                    <span class="keyword">if</span> five &gt;=<span class="number">3</span>:</span><br><span class="line">                        five -=<span class="number">3</span></span><br><span class="line">                    <span class="comment">#说明此时手上没有可供找零的方式，返回false</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="LeetCode-55跳跃游戏"><a href="#LeetCode-55跳跃游戏" class="headerlink" title="LeetCode 55跳跃游戏"></a>LeetCode 55跳跃游戏</h1><p>略，在另一篇文章里面有单独写这个。</p>
<h1 id="leetcoad435-无重叠区间"><a href="#leetcoad435-无重叠区间" class="headerlink" title="leetcoad435.无重叠区间"></a>leetcoad435.无重叠区间</h1><p>题目描述：给定一个<strong>区间的集合</strong> intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回** 需要移除区间的最小数量<strong>，使剩余区间</strong>互不重叠** 。<br>示例 1:<br>输入: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]<br>输出: 1<br>解释: 移除 [1,3] 后，剩下的区间没有重叠。</p>
<p>示例 2:<br>输入: intervals &#x3D; [ [1,2], [1,2], [1,2] ]<br>输出: 2<br>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</p>
<p>示例 3:<br>输入: intervals &#x3D; [ [1,2], [2,3] ]<br>输出: 0<br>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。<br>结合开头区间调度的思维，这里用会议预定的思路，将区间（会议）按照右端点进行排序，<strong>一定可以找到一个最先结束的会议</strong>，这个会议我们首先要加入到最终结果的首个会议（这个会议最先结束就可以给后面争取到更多的时间了，蕴含了贪心的思想），用预定会议的思路只是为了好理解。<br>自己在写的时候要<strong>注意排序算法的注写</strong>，如果是自己写的话很可能会超时</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eraseOverlapIntervals</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 将intervals区间按照end的升序排列</span></span><br><span class="line">        n=<span class="built_in">len</span>(intervals)</span><br><span class="line">        <span class="comment"># for i in range(n):</span></span><br><span class="line">        <span class="comment">#     for j in range(i+1,n):</span></span><br><span class="line">        <span class="comment">#         if intervals[i][1]&gt;=intervals[j][1]:</span></span><br><span class="line">        <span class="comment">#             intervals[i],intervals[j]=intervals[j],intervals[i]</span></span><br><span class="line">        <span class="comment"># 表示要将interval按照end值进行升序排列</span></span><br><span class="line">        <span class="comment"># 此处也采用了匿名函数的形式，这种写法要值得注意</span></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">        <span class="built_in">print</span>(intervals)</span><br><span class="line">        <span class="comment"># 至少有一个区间不相交</span></span><br><span class="line">        count=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 排序后，第一个区间就是x</span></span><br><span class="line">        <span class="comment"># x_end表示第一个区间的结尾值</span></span><br><span class="line">        x_end=intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="comment"># start为从第一个元素开始，区间的开头元素</span></span><br><span class="line">            start=intervals[i][<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># 如果一个区间不想与x的end相交。它的start必须要大于等于x的end（可以区间边界包含）</span></span><br><span class="line">            <span class="keyword">if</span> start &gt;= x_end:</span><br><span class="line">                <span class="comment"># 找到下一个选择的区间了</span></span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 同时将当前找到的这个区间赋值给x_end</span></span><br><span class="line">                x_end=intervals[i][<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 返回最终的结果</span></span><br><span class="line">        <span class="keyword">return</span> n-count</span><br></pre></td></tr></table></figure>
<h1 id="leetcoad452-用最少数量的箭引爆气球"><a href="#leetcoad452-用最少数量的箭引爆气球" class="headerlink" title="leetcoad452-用最少数量的箭引爆气球"></a>leetcoad452-用最少数量的箭引爆气球</h1><p>题目描述：<br>有一些球形气球贴在一堵用** XY 平面表示的墙面上<strong>。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示</strong>水平直径在 xstart 和 xend之间的气球**。你不知道气球的确切 y 坐标。<br>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。<br>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。<br>题目分析：<br>也是采用区间调度的方法，不过还是有一点区别的，需要改一点边界条件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMinArrowShots</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 对points数组按照end值进行升序排列</span></span><br><span class="line">        n=<span class="built_in">len</span>(points)</span><br><span class="line">        points.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># print(points)</span></span><br><span class="line">        <span class="comment"># 至少有一个区间不相交</span></span><br><span class="line">        count=<span class="number">1</span></span><br><span class="line">        <span class="comment"># x_end表示第一个区间的结尾值</span></span><br><span class="line">        x_end=points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 除开第一数开始往后遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="comment"># 如果发现后面的数的开头元素是大于前一个数的结尾元素的</span></span><br><span class="line">            <span class="comment"># start表示下一个的左端元素</span></span><br><span class="line">            start=points[i][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> start &gt; x_end:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                x_end=points[i][<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 循环结束后返回</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>



<h1 id="leetcoad402-移掉k位数字"><a href="#leetcoad402-移掉k位数字" class="headerlink" title="leetcoad402-移掉k位数字"></a>leetcoad402-移掉k位数字</h1><p>题目描述：<br>给你一个以<strong>字符串</strong>表示的非负整数 num 和一个整数 k ，<strong>移除</strong>这个数中的** k 位数字<strong>，使得</strong>剩下的数字最小<strong>。请你以</strong>字符串形式返回这个最小的数字**。<br>实例一：<br>输入：num &#x3D; “1432219”, k &#x3D; 3<br>输出：”1219”<br>解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。</p>
<p>实例二：<br>输入：num &#x3D; “10200”, k &#x3D; 1<br>输出：”200”<br>解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</p>
<p>思路：（这里地思路很巧妙）</p>
<ol>
<li>从左到右遍历所有的数字，判断是否需要保留</li>
<li>用栈保留需要遍历的所有的数字</li>
<li>不断地去比较当前遍历元素与栈顶元素比较</li>
<li>移除k位之后，将栈顶地元素挨个弹出，然后进行反转就得到最终的结果</li>
</ol>
<p>这里面用到了单调栈和贪心的思想（也就只有做题才能体会出来）<br>问题的关键：我们怎么知道，一个元素是应该保留还是应该丢弃？<br>前置的数学知识：<strong>两相同位数的数字的大小关系取决于第一个不同数的大小</strong><br>很可能会遗漏的一个点：第一个元素为0的情况（前提是这个数字不全是0）</p>
<p>另一种分析思路：</p>
<ol>
<li>每次丢弃一次，k-1，当k减到0，我们可以提前终止遍历</li>
<li>当遍历完成，如果k仍大于0（假设最终还剩下x个需要丢弃），我们需要选择删除末尾x个元素（<strong>这里判定的思路太重要了</strong>）</li>
</ol>
<p>在上面的思路上来一个逆向的思考的过程：</p>
<ol>
<li>上面的一直是丢弃，逆向思维就是保留n-k个元素（我们只需要按照上面的方法遍历完成，<strong>再截取前n-k个元素</strong>）</li>
<li>通过思路的分析来选择数据结构：我们需要保留和丢弃相邻的元素，可以使用栈这种再一端进行添加和删除的数据结构<br><img src="https://runnerxr.github.io/post-images/1653237607408.png"><br>这里附上代码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeKdigits</span>(<span class="params">self, num: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 初始化栈，用来存储需要保存的数字</span></span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="comment"># 从左到右遍历字符串 num</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> num:</span><br><span class="line">            <span class="comment"># 如果此时</span></span><br><span class="line">            <span class="comment"># 1、栈不为空</span></span><br><span class="line">            <span class="comment"># 2、栈顶元素大于此时遍历的字符</span></span><br><span class="line">            <span class="comment"># 3、还没有删除足够多的数字，即 k &gt; 0</span></span><br><span class="line">            <span class="comment"># 那么这个时候需要把栈顶元素弹出</span></span><br><span class="line">            <span class="comment"># 这里在移除元素的时候就用到了贪心的思想</span></span><br><span class="line">            <span class="keyword">while</span> k <span class="keyword">and</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] &gt;c:</span><br><span class="line">                stack.pop()</span><br><span class="line">                k-=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 把符合要求的字符放入到栈中</span></span><br><span class="line">            stack.append(c)</span><br><span class="line">            <span class="comment"># print(stack)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack[:<span class="built_in">len</span>(stack) - k]).lstrip(<span class="string">&#x27;0&#x27;</span>) <span class="keyword">or</span> <span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure>
这里有几行重要的代码，值得自己思考：<br><strong>这里要补充单调栈的知识点</strong>：<br>在栈的基础上，从栈顶到栈底的元素是严格的递增或递减的<br>具体的进栈过程：</li>
<li>对于单调递增栈，若当前进栈元素为 e，从栈顶开始遍历元素，<strong>把小于 e 或者等于 e 的元素</strong>弹出栈，直接遇到<strong>一个大于 e 的元素</strong>或者<strong>栈为空</strong>为止，然后再把 e 压入栈中。</li>
<li>对于<strong>单调递减栈</strong>，则每次弹出的是<strong>大于 e 或者等于 e</strong> 的元素。</li>
</ol>
<p>举例子说明：3，4，2，6，4，5，2，3（按照单调递增栈的思路）<br><img src="https://runnerxr.github.io/post-images/1653316796206.png"></p>
<p>还有最后的一行代码<br>这里举两个调试的例子：num&#x3D;’9’  ,k&#x3D;1,按道理应该要返回’0’，因为移除之后，数字就为空了<br>num&#x3D;’10’,k&#x3D;1,按道理要返回’0’，如果你不是按上面写的，而是在上面写上一个判断条件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> k&gt;=<span class="built_in">len</span>(num):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure>
<p>虽然考虑到了将全部元素移除后为空的情况，但是却不能考虑到有些’0’是因为去移除一部分本身还剩下的是元素0（不是空，但是元素是’0’）,所有返回的结果也是有问题<br>综上所述，最后一个返回的条件要兼顾以下的几种情况：</p>
<ol>
<li>移除一些元素之后，前导为0的，去除前导之后能够返回</li>
<li>移除元素之后，本身已经为空了，需要返回’0’</li>
<li>移除元素之后，还剩的元素本身为’0’,也要返回’0’</li>
</ol>
<p>当把这个题目做完了之后，再反思看其他人的一些优秀题解，也有新的启发（按说这些解法都是相通的，所以还是要动脑筋才能看懂，要花费很多的精力呀，能看懂是一方面，会写又是另一个方面，这里面的门道还真多）：<br>比如这里的一篇题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-k-digits/solution/wei-tu-jie-dan-diao-zhan-dai-ma-jing-jian-402-yi-d/">https://leetcode.cn/problems/remove-k-digits/solution/wei-tu-jie-dan-diao-zhan-dai-ma-jing-jian-402-yi-d/</a></p>
<ol>
<li>从左至右扫描，当前扫描的数还<strong>不确定要不要删除</strong>，<strong>入栈缓存</strong></li>
<li>123531这样高位递增的数，肯定是想着尽量删除低位的部分，保留高位的部分</li>
<li>432135这种高位递减的数，会想到让高位变小</li>
<li>如果当前遍历的数比栈顶大，符合递增，是满意的，让它入栈。</li>
<li>如果当前遍历的数比栈顶小，栈顶立刻出栈，不管后面有没有更大的，为什么？</li>
</ol>
<p>这样做的原因：栈顶数属于高位，删掉它，小的顶上，高位变小好于低位变小<br>但是对于特殊的情况的处理，比如0432219，0一开始就被遇到，<strong>它是最小的，最后肯定会被留在里面</strong><br>这里的处理方式有两种：<br>事先处理：加入一个判断，当c&#x3D;&#x3D;0的时候，由于我们写的是入栈的条件，所以就被改写成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c!=<span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(stack)!=<span class="number">0</span>:</span><br><span class="line">    stack.append(c)</span><br></pre></td></tr></table></figure>
<p>事后处理：就是题目中的写法，用strip()函数来去除字符串前面的0<br>还有一种情况也需要处理：遍历结束时，有可能没有删除够k个字符，继续循环出栈，删除低位<br>如果删除够了：</p>
<ol>
<li>栈变空：什么也不剩了，直接返回”0”</li>
<li>栈中还有元素，将栈中剩下的字符，转成字符串返回</li>
</ol>
<p><strong>什么时候用单调栈？</strong>：需要给当前的元素，找右边&#x2F;左边第一个比他大&#x2F;小的位置<br><strong>总结：</strong></p>
<ol>
<li>单调递增栈，利用<strong>波谷</strong>剔除栈中的波峰，<strong>留下波谷</strong>；</li>
<li>单调递减栈，利用<strong>波峰</strong>剔除栈中的波谷，<strong>留下波峰</strong>。</li>
</ol>
<p>这个时候再次回到本题中：<br>本题就是维护了一个单调递增栈，找右边第一个比它小的数（右侧的第一个波谷）<br>遇到波谷，就<strong>剔除单调栈中的波峰</strong>，<strong>维持单增</strong>（留下了波谷就是保持了单增，剔除的栈中的字符就是删除的字符）<br><img src="https://runnerxr.github.io/post-images/1653300109217.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeKdigits</span>(<span class="params">self, num: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(num)==k:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="comment"># 遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> num:</span><br><span class="line">            <span class="comment"># 只要k&gt;0并且当前的c比栈顶的小，则栈顶出栈，k值-1</span></span><br><span class="line">            <span class="keyword">while</span> k &gt;<span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(stack)&gt;<span class="number">0</span> <span class="keyword">and</span> stack[-<span class="number">1</span>] &gt;c:</span><br><span class="line">                stack.pop()</span><br><span class="line">                k-=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果当前的字符不是0，或栈非空（避免0入空栈），入栈</span></span><br><span class="line">            <span class="keyword">if</span> c!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> <span class="built_in">len</span>(stack)!=<span class="number">0</span>:</span><br><span class="line">                stack.append(c)</span><br><span class="line">        <span class="comment"># 如果还没有删除够，要从stack继续删除，直到k=0</span></span><br><span class="line">        <span class="keyword">while</span> k&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(stack)!=<span class="number">0</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">            k-=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果栈空了，返回&#x27;0&#x27;,如果栈非空，转成字符串返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack[:<span class="built_in">len</span>(stack)])</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/17/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/" data-id="claqu9000002ziwtkfv2yhoaf" data-title="贪心算法合集" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gridea/" rel="tag">Gridea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" rel="tag">python知识小记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99%E7%9A%84%E5%B0%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/" rel="tag">工作之余的小的编程小知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" rel="tag">算法专栏（用python注写）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0/" rel="tag">读书摘记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Gridea/" style="font-size: 10px;">Gridea</a> <a href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" style="font-size: 13.33px;">python知识小记</a> <a href="/tags/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99%E7%9A%84%E5%B0%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/" style="font-size: 16.67px;">工作之余的小的编程小知识</a> <a href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" style="font-size: 20px;">算法专栏（用python注写）</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0/" style="font-size: 10px;">读书摘记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/21/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2022/11/12/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%BA%94%E7%9A%84%E5%90%8C%E6%AD%A5/">搭建自己的博客并进行相应的同步</a>
          </li>
        
          <li>
            <a href="/2022/10/03/vs%20code%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%B7%A5%E5%85%B7%E5%8C%85/">关于vs code导入本地工具包和消除&#39;import [module] could not be resolved in pylance&#39;</a>
          </li>
        
          <li>
            <a href="/2022/09/25/%E5%85%B3%E4%BA%8Ematalab%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">关于matalab的数据分析</a>
          </li>
        
          <li>
            <a href="/2022/07/30/%E5%85%B3%E4%BA%8Epython%E7%88%AC%E8%99%AB%E4%B8%80%E7%82%B9%E5%B0%8F%E7%9A%84%E6%95%B4%E7%90%86/">关于python爬虫一点小的整理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>