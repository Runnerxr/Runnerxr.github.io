<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>
        bear的生活随笔
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico" />
    <link rel="stylesheet" href="/css/style/github.min.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <div class="container">
        <div class="header">
    <!-- <div class="logo">
        <a href="/">bear的生活随笔</a>
    </div> -->
    <div class="logo">
        <img src="/images/logo.png" alt="Logo">
    </div>
    <div class="nav">
        <ul class="menu">
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">
                        Home
                    </a>
                </li>
            
                <li class="menu-item">
                    <a target="_blank" rel="noopener" href="https://github.com/loveminimal" class="menu-item-link">
                        Github
                    </a>
                </li>
                
        </ul>
    </div>
</div>
        <div class="main">
    <!-- <div class="posts">
        
        <div class="post">
            <div class="post-title">
                <a href="/2022/03/25/%E5%88%86%E6%B2%BB%E6%B3%95%E7%9A%84%E6%80%9D%E6%83%B3%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98%EF%BC%88Divide%20and%20conquer%EF%BC%89/" class="post-title-link">
                    分治法的思想及相关例题（Divide and conquer）
                </a>
            </div>
            <div class="post-content">
                
            </div>
            <div class="post-more">
                <a href="/2022/03/25/%E5%88%86%E6%B2%BB%E6%B3%95%E7%9A%84%E6%80%9D%E6%83%B3%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98%EF%BC%88Divide%20and%20conquer%EF%BC%89/" class="post-title-link">
                    Read More
                </a>
            </div>
            <div class="post-meta">
                <div class="post-date">
                    22-03-25
                </div>
            </div>
        </div>
        
        <div class="post">
            <div class="post-title">
                <a href="/2022/03/25/%E6%97%B6%E5%88%BB%E7%89%A2%E8%AE%B0%E5%9C%A8%E5%BF%83%E5%8D%B4%E4%B8%8D%E5%BF%85%E6%8A%8A%E8%BF%99%E4%BB%B6%E4%BA%8B%E6%8C%82%E5%9C%A8%E5%98%B4%E8%BE%B9/" class="post-title-link">
                    时刻牢记在心却不必把这件事挂在嘴边
                </a>
            </div>
            <div class="post-content">
                
            </div>
            <div class="post-more">
                <a href="/2022/03/25/%E6%97%B6%E5%88%BB%E7%89%A2%E8%AE%B0%E5%9C%A8%E5%BF%83%E5%8D%B4%E4%B8%8D%E5%BF%85%E6%8A%8A%E8%BF%99%E4%BB%B6%E4%BA%8B%E6%8C%82%E5%9C%A8%E5%98%B4%E8%BE%B9/" class="post-title-link">
                    Read More
                </a>
            </div>
            <div class="post-meta">
                <div class="post-date">
                    22-03-25
                </div>
            </div>
        </div>
        
        <div class="post">
            <div class="post-title">
                <a href="/2022/03/23/%E7%B3%BB%E7%BB%9F%E8%AF%A6%E7%BB%86%E7%9A%84%E6%95%B4%E7%90%86%E5%85%B3%E4%BA%8Epython%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" class="post-title-link">
                    系统详细的整理关于python中的面向对象编程/面对对象高级编程
                </a>
            </div>
            <div class="post-content">
                
            </div>
            <div class="post-more">
                <a href="/2022/03/23/%E7%B3%BB%E7%BB%9F%E8%AF%A6%E7%BB%86%E7%9A%84%E6%95%B4%E7%90%86%E5%85%B3%E4%BA%8Epython%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" class="post-title-link">
                    Read More
                </a>
            </div>
            <div class="post-meta">
                <div class="post-date">
                    22-03-23
                </div>
            </div>
        </div>
        
        <div class="post">
            <div class="post-title">
                <a href="/2022/03/21/%E5%93%88%E5%B8%8C%E8%A1%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%EF%BC%89/" class="post-title-link">
                    哈希表问题汇总（散列函数）
                </a>
            </div>
            <div class="post-content">
                <ul>
<li>1 Two Sum (Easy)</li>
<li>217 Contains Duplicate (Easy)</li>
<li>594 Longest Harmonious Subsequence (Easy)</li>
<li>128 Longest Consecutive Sequence (Hard)</li>
<li>349 两个数组的交集（easy）</li>
<li>350 两个数组的交集 II（easy）</li>
<li>242 有效的字母异位词（easy）</li>
<li>202 快乐数（easy）</li>
<li>205 同构字符串（easy）</li>
<li>451 根据字符出现频率排序（medium）</li>
<li>15 三数之和（medium）</li>
<li>18 四数之和（medium）</li>
<li>454 四数相加 II（medium）</li>
<li>49 字母异位词分组（medium）</li>
<li>447 回旋镖的数量（easy）</li>
<li>149 直线上最多的点数（hard）</li>
<li>219 存在重复元素 II（easy）</li>
<li>220 存在重复元素 III（medium）</li>
</ul>
<p><strong>哈希表的基础知识：</strong><br>散列表是一种数据结构，其中数据元素的地址或索引值是由散列函数生成的。这使得访问数据的速度更快，因为索引值是数据值的关键字。换句话说，哈希表存储键值对，但密钥是通过哈希函数生成的。<br>因此，数据元素的搜索和插入函数变得更快，因为键值本身成为存储数据的数组的索引。<br>在Python中，Dictionary数据类型表示哈希表的实现。以下为根据廖雪峰的资料做的整理：<br><strong>dic:</strong></p>
<ol>
<li>内置字典：dic的支持，在其他语言中称map，使用键-值（key-value）存储，具有极快的查找度</li>
<li>实现方法：给定一个名字，dic在内部就直接计算出名字对应的存放成绩的内存地址，直接取出来</li>
<li>存储条件：key-value存储方式：必须根据key算出value的存放位置，取出才能根据key直接拿到Value,可以通过 key放入来把数据放入dict中</li>
<li>一个key对应一个value，多次对一个key放入value，后面的值会把前面的值冲掉</li>
<li><strong>避免key不存在的错误的两种方法</strong><ol>
<li>通过in判断key是否存在：</li>
<li><strong>通过dict提供的get()方法</strong>，如果不存在的话，可以返回None，或者自己指定的value</li>
</ol>
</li>
<li>要删除一个key，用pop(key)方法，对应的value也会从dict中删除</li>
<li>dict内部存放的顺序和key放入的顺序是没有关系的</li>
</ol>
<p>哈希函数（Hash Function）：将哈希表中元素的关键键值映射为元素存储位置的函数<br>哈希冲突（Hash Collision）：将不同的关键字通过一个哈希函数可能得到同一个哈希地址<br>哈希表的核心问题：哈希函数的构建和哈希冲突的解决办法</p>
<p><strong>dict.get() 与 dict[‘key’] 的区别</strong><br>1.dict[‘key’]只能获取存在的值，如果不存在则触发KeyError<br>2.dict.get(key, default&#x3D;None)则如果不存在则返回一个默认值，如果设置了则是设置的，否则就是None</p>
<p><strong>和list比较后，dict的几个特点：</strong></p>
<ol>
<li>查找和插入的速度极快，不会随着key的增加而变慢，但是list相反，时间随元素的增加而增加</li>
<li>需要占用大量的内存，内存浪费多，但是list相反，占用空间小，浪费内存很小</li>
<li>在需要高速查找的地方无处不在，关键点：dict的key必须是不可变对象：通过key计算位置的算法为哈希算法，要保证算法的正确性，作为key的对象就不能变[字符串–整数等都是不可变的]（hash）,list是可变的，不能作为key</li>
</ol>
<pre><code class="python"># 附上代码加强理解
# 新建一个字典，存入&#39;名字-成绩&#39;的对照表（无论表多大，查找的速度都不会慢）
d = &#123; &#39;Michael&#39;: 95, &#39;Bob&#39;: 75,&#39;Tracy&#39;: 85&#125;

print(&#39;d[\&#39;Michael\&#39;] =&#39;, d[&#39;Michael&#39;])
print(&#39;d[\&#39;Bob\&#39;] =&#39;, d[&#39;Bob&#39;])
print(&#39;d[\&#39;Tracy\&#39;] =&#39;, d[&#39;Tracy&#39;])
# 通过dict提供的get()方法，如果key不存在，返回自己指定的&#39;-1&#39;,这里是查看Thomas的成绩是否存在，如果不存在就返回-1
print(&#39;d.get(\&#39;Thomas\&#39;, -1) =&#39;, d.get(&#39;Thomas&#39;, -1))
# 打印输出结果
# d[&#39;Michael&#39;] = 95       
# d[&#39;Bob&#39;] = 75
# d[&#39;Tracy&#39;] = 85
# d.get(&#39;Thomas&#39;, -1) = -1
</code></pre>
<p><strong>set:需要好好的理解，并且要运用好</strong></p>
<ol>
<li><strong>与dict比较的类似</strong>，一组key的集合，但不存储value，在set中没有重复的key</li>
<li>要创建一个set，需要提供一个list作为输入集合</li>
<li>重复元素在set中自动被过滤：</li>
<li>通过add(key)方法可以添加元素到set中，可以重复添加，但是没有效果</li>
<li>通过remove（key）方法可以删除元素</li>
<li><strong>set可以看成数学意义上的无序和无重复元素的集合</strong>，两个set可以做数学意义上的交集、并集等操作。</li>
<li><strong>和dic的唯一区别：没有存储对应的value值</strong></li>
</ol>
<pre><code class="python"># 附上代码，加强对set的理解
s1 = set([1, 1, 2, 2, 3, 3])

# 重复元素在set中自动被过滤
print(s1)
s2 = set([2, 3, 4])

# 打印s1和s2的交集
print(s1 &amp; s2)

#打印s1和s2的并集
print(s1 | s2)

# 通过add(key)的方法添加4到set中
s1.add(4)
print(s1)

# 通过remove(key)的方法删除s2中的元素
s2.remove(2)
print(s2)
# 输出结果如下：
# &#123;1, 2, 3&#125;
# &#123;2, 3&#125;
# &#123;1, 2, 3, 4&#125;
# &#123;1, 2, 3, 4&#125;
# &#123;3, 4&#125;
</code></pre>
<h1 id="通俗理解set和dict背后的哈希表"><a href="#通俗理解set和dict背后的哈希表" class="headerlink" title="通俗理解set和dict背后的哈希表"></a>通俗理解set和dict背后的哈希表</h1><p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39657125/article/details/111293311">https://blog.csdn.net/weixin_39657125/article/details/111293311</a><br>set,dict都是基于哈希表的数据结构<br>哈希表的实现基于数组和链表<br>哈希表是重要的数据结构；Python使用它们来实现两种重要的内置数据类型，dict和set（哈希表不是字典，字典和集合这两种数据类型是由哈希表来实现的）<br>字典是将键映射到值的一般概念。实现这种映射有很多方法，红黑树也可以实现字典</p>
<h1 id="关于python中字典的一些操作"><a href="#关于python中字典的一些操作" class="headerlink" title="关于python中字典的一些操作"></a>关于python中字典的一些操作</h1><p>参考链接：<br><a target="_blank" rel="noopener" href="https://www.cjavapy.com/article/934/">https://www.cjavapy.com/article/934/</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/guifei010/article/details/79165785?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.pc_relevant_default&amp;utm_relevant_index=1">https://blog.csdn.net/guifei010/article/details/79165785?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.pc_relevant_default&amp;utm_relevant_index=1</a><br>因为字典相对运用的也不少，所以要做一个比较全面的总结，方便后续代码的撰写<br><strong>创建字典：</strong></p>
<ol>
<li>d &#x3D; {}</li>
<li>d &#x3D; dict()</li>
<li>导入pytho内置的模块：<br><strong>访问字典里面的值</strong></li>
<li>通过在方括号内引用其键名来访问字典的各项 ：x&#x3D; d[“name”]  获取key为“name”的值</li>
<li>用get()方法来访问:x&#x3D;d.get(“age”)   获取”age”键的值<br><strong>改变字典中的值</strong></li>
</ol>
<pre><code class="python">thisdict = &#123;&quot;name&quot;: &quot;cjavapy&quot;,&quot;age&quot;: 3,&quot;gender&quot;: &quot;man&quot;&#125;
thisdict[&quot;age&quot;] = 5
print(thisdict)
# &#123;&quot;name&quot;: &quot;cjavapy&quot;,&quot;age&quot;: 5,&quot;gender&quot;: &quot;man&quot;&#125;
</code></pre>
<p><strong>遍历字典（用的最多的）</strong><br>写在前面：遍历字典中这三个是用得非常非常多的，必须要牢记住： keys()  、values() 、items()，分别是返回字典中的所有key、返回字典中的所有值、返回字典中的所有key&#x3D;value的值（返回的就是一个可以迭代的对象）</p>
<ol>
<li>用for 循环来遍历字典：</li>
</ol>
<pre><code class="python"># 逐行但打印字典中所有键的名称
thisdict =&#123;&#39;name&#39;: &#39;XR&#39;, &#39;age&#39;: 28, &#39;gender&#39;: &#39;man&#39;, &#39;address&#39;: &#39;web&#39;&#125;
for x in thisdict:
    #print(x)
    value=thisdict[x]
    # print(&quot;%s:%s&quot;%(x,value))
    print(&quot;&#123;:&#125;:&#123;:&#125;&quot;.format(x,value))
    print()
# 输出如下：
# name:XR
# age:28
# gender:man
# address:web
# 逐行打印字典中的所有值
for x in thisdict:
    print(thisdict[x])
</code></pre>
<ol start="2">
<li>用values()方法来返回字典的值(和上面输出的是相同的)</li>
</ol>
<pre><code class="python"># vales= thisdict.values()  # 这种就是取出了所有的value值了
for x in thisdict.values():
    print(x)
</code></pre>
<ol start="3">
<li>使用items()来循环遍历键和值</li>
</ol>
<pre><code class="python"># 这道题是牛客网上的一道题，用的字典来写的，磕磕巴巴的写出来的
hashmap=&#123;&#39;rzuwnjvnuz 633&#39;: 1, &#39;atl 637&#39;: 1, &#39;rwyfvzsopsuiqjnr 647&#39;: 1, &#39;eez 648&#39;: 1, &#39;fmwafhhgeyawnool 649&#39;: 1, &#39;c 637&#39;: 1, &#39;f 633&#39;: 1, &#39;ywzqaop 631&#39;: 2&#125;

# 循环遍历键和值
for key,value in hashmap.items():
    # 注释的写法就是本质，不过这样写太麻烦了
    # print(key+ &quot; &quot; +str(value))
    print(key,value)
# 输出结果如下：
# rzuwnjvnuz 633 1
# atl 637 1
# rwyfvzsopsuiqjnr 647 1
# eez 648 1
# fmwafhhgeyawnool 649 1
# c 637 1
# f 633 1
# ywzqaop 631 2
</code></pre>
<p><strong>判断Key是否存在：</strong></p>
<pre><code class="python">thisdict = &#123;&quot;name&quot;: &quot;cjavapy&quot;,&quot;age&quot;: 3,&quot;gender&quot;: &quot;man&quot;&#125;
if &quot;name&quot; in thisdict:
    print(&quot;&#39;name&#39;存在字典中&quot;)   
# &#39;name&#39;存在字典中
</code></pre>
<p><strong>字典的长度：</strong><br>主要是为了确定字典中有多少项（键值对）<br>print(len(thisdict))</p>
<p><strong>向字典中添加项目元素</strong><br>主要通过新的索引键为其分配值</p>
<pre><code class="python">thisdict = &#123;&quot;name&quot;: &quot;   XR&quot;,&quot;age&quot;: 28,&quot;gender&quot;: &quot;man&quot;&#125;
thisdict[&quot;address&quot;] = &quot;web&quot;
print(thisdict)
# &#123;&#39;name&#39;: &#39;   XR&#39;, &#39;age&#39;: 28, &#39;gender&#39;: &#39;man&#39;, &#39;address&#39;: &#39;web&#39;&#125;
</code></pre>
<p><strong>删除字典中项目元素</strong></p>
<ol>
<li>pop()方法移除具有指定key的项:</li>
</ol>
<pre><code class="python">thisdict =&#123;&#39;name&#39;: &#39;XR&#39;, &#39;age&#39;: 28, &#39;gender&#39;: &#39;man&#39;, &#39;address&#39;: &#39;web&#39;&#125;
thisdict.pop(&quot;age&quot;)
print(thisdict)
# &#123;&#39;name&#39;: &#39;XR&#39;, &#39;gender&#39;: &#39;man&#39;, &#39;address&#39;: &#39;web&#39;&#125;
</code></pre>
<ol start="2">
<li>popitem()方法删除最后插入的项</li>
</ol>
<pre><code class="python">thisdict =&#123;&#39;name&#39;: &#39;XR&#39;, &#39;age&#39;: 28, &#39;gender&#39;: &#39;man&#39;, &#39;address&#39;: &#39;web&#39;&#125;
thisdict.popitem()
print(thisdict)
# &#123;&#39;name&#39;: &#39;XR&#39;, &#39;age&#39;: 28, &#39;gender&#39;: &#39;man&#39;&#125;
</code></pre>
<ol start="3">
<li>del()关键字删除具有指定键名的项目</li>
</ol>
<pre><code class="python">thisdict =&#123;&#39;name&#39;: &#39;XR&#39;, &#39;age&#39;: 28, &#39;gender&#39;: &#39;man&#39;, &#39;address&#39;: &#39;web&#39;&#125;
del thisdict[&quot;gender&quot;]
print(thisdict)
#  &#123;&#39;name&#39;: &#39;XR&#39;, &#39;age&#39;: 28, &#39;address&#39;: &#39;web&#39;&#125;
</code></pre>
<ol start="4">
<li>clear()方法清空字典<br>thisdict.clear()<br><strong>复制一个字典：</strong><br>不能简单地通过输入dict2 &#x3D; dict1来复制字典，因为dict2将仅是对dict1的引用，对dict1所做的更改也将自动被改为indict2。<br>有很多方法可以制作副本，一种方法是使用内置的Dictionary方法copy()。</li>
</ol>
<pre><code class="python"># 使用copy（）方法制作字典的副本：
thisdict =&#123;&#39;name&#39;: &#39;XR&#39;, &#39;age&#39;: 28, &#39;gender&#39;: &#39;man&#39;, &#39;address&#39;: &#39;web&#39;&#125;
mydict=thisdict.copy()
print(mydict)
</code></pre>
<pre><code class="python"># 使用内置函数dict()
```python
thisdict =&#123;&#39;name&#39;: &#39;XR&#39;, &#39;age&#39;: 28, &#39;gender&#39;: &#39;man&#39;, &#39;address&#39;: &#39;web&#39;&#125;
mydict=dict(thisdict)
print(mydict)
</code></pre>
<p><strong>嵌套的字典：</strong></p>
<pre><code class="python"># 构建一个字典，嵌套了三个字典
myfamily = &#123;
&quot;child1&quot; : &#123;&quot;name&quot; : &quot;Emil&quot;,&quot;year&quot; : 2004&#125;,
&quot;child2&quot; : &#123;&quot;name&quot; : &quot;Tobias&quot;,&quot;year&quot; : 2007&#125;,
&quot;child3&quot; : &#123;&quot;name&quot; : &quot;Linus&quot;,&quot;year&quot; : 2011&#125;
&#125;
</code></pre>
<p><strong>通过 sorted函数，可以进行排序（</strong>）：**</p>
<pre><code class="python">dict=&#123;&#39;A&#39;: 1, &#39;C&#39;: 5, &#39;APP&#39;: 4, &#39;each&#39;: 7&#125;
lis1=sorted(dict.items(),key=lambda d:d[0]) #按键来排序
lis2=sorted(dict.items(),key=lambda d:d[1]) #按值来排序
print(lis1)
print(lis2)
# 输出结果
[(&#39;A&#39;, 1), (&#39;APP&#39;, 4), (&#39;C&#39;, 5), (&#39;each&#39;, 7)]
[(&#39;A&#39;, 1), (&#39;APP&#39;, 4), (&#39;C&#39;, 5), (&#39;each&#39;, 7)]
</code></pre>
<p><strong>d.values()  以列表返回字典中的所有值</strong></p>
<pre><code class="python">hashmap = &#123;8: 46828, 24: 47153, 3: 93735, 13: 72600, 4: 44422&#125;
l=hashmap.values() 
print(l)
# dict_values([46828, 47153, 93735, 72600, 44422])
</code></pre>
<p><strong>d.keys()    返回列表中所有的键</strong></p>
<pre><code class="python">hashmap = &#123;&#39;name&#39;: &#39;XR&#39;, &#39;age&#39;: 28, &#39;gender&#39;: &#39;man&#39;, &#39;address&#39;: &#39;web&#39;&#125;
l=hashmap.keys() 
print(l)
# 输出结果
# dict_keys([&#39;name&#39;, &#39;age&#39;, &#39;gender&#39;, &#39;address&#39;])
</code></pre>
<p><strong>d.items()      以列表的形式返回可遍历的元组数组</strong></p>
<pre><code class="python">hashmap = &#123;&#39;name&#39;: &#39;XR&#39;, &#39;age&#39;: 28, &#39;gender&#39;: &#39;man&#39;, &#39;address&#39;: &#39;web&#39;&#125;
l=hashmap.items() 
print(l)
# dict_items([(&#39;name&#39;, &#39;XR&#39;), (&#39;age&#39;, 28), (&#39;gender&#39;, &#39;man&#39;), (&#39;address&#39;, &#39;web&#39;)])
</code></pre>
<p><strong>用dict.get()返回指定键的值</strong><br>语法如下：dict.get(key[,value])</p>
<ol>
<li>key–字典中要查的键</li>
<li>value—如果指定的键值存在，返回默认值</li>
</ol>
<pre><code class="python"># 辅助理解这个知识点
hashmap = &#123;&#39;name&#39;: &#39;XR&#39;, &#39;age&#39;: 28, &#39;gender&#39;: &#39;man&#39;, &#39;address&#39;: &#39;web&#39;&#125;
# 直接查询
print(hashmap.get(&#39;name&#39;))
# 直接查询，查询不成功返回None
print(hashmap.get(&#39;birth&#39;))
# 直接查询，查询不成功返回指定的输出
print(hashmap.get(&#39;parent&#39;),&#39;该项信息缺失&#39;)
# 打印结果如下
XR
None
None 该项信息缺失
</code></pre>
<p>与dict[key]的区别：</p>
<ol>
<li>get(key) 方法在 key（键）不在字典中时，可以返回默认值 None 或者设置的默认值。</li>
<li>dict[key]：在Key不在字典中的时候，会触发KeyError异常</li>
</ol>
<p><strong>d.fromkeys(seq[,val])   创建一个新字典   以序列seq中的元素做键   val做字典所有键对应的初始值</strong></p>
<pre><code class="python">nums =[0,2,5,8]
d1=dict.fromkeys(nums, 1)
print(d1)
# 输出结果
# &#123;0: 1, 2: 1, 5: 1, 8: 1&#125;
</code></pre>
<p><strong>使用模块里面的字典以及与lambda结合的用法</strong><br>以一个例子来说明：<br>需要生成一个字典，对于任意key的查询，value都返回XR</p>
<pre><code class="python"># 第一种实现
from collections import defaultdict 
def func1():
    return XR
func2=defaultdict(func1)
</code></pre>
<pre><code class="python"># 第二种实现：采用与lambda结合的方式（不用这种方式就会忘掉）
# 表示用默认的字典defaultdict,如果没有找到对应的value值，会返回一个默认值
func2=defaultdict(lambda:XR)
</code></pre>
<p><strong>用于统计一个字符中各个字符串的数量</strong><br>这个例子使用字典特别的巧妙，值得自己去整理</p>
<pre><code class="python">t=&quot;ABBC&quot;
# hashmap=dict((i,t.count(i)) for i t)
# 换一种好理解的方式
hashmap=dict()
for c in t:
    if c not in hashmap:
        hashmap[c]=1
    else:
        hashmap[c]+=1
print(hashmap)
# 打印结果如下：
&#123;&#39;A&#39;: 1, &#39;B&#39;: 2, &#39;C&#39;: 1&#125;
</code></pre>
<p>以下为leetcoad上的一些关于哈希表的比较典型的几道题目，需要重点掌握。</p>
<h1 id="leetcoad01-两数之和"><a href="#leetcoad01-两数之和" class="headerlink" title="leetcoad01-两数之和"></a>leetcoad01-两数之和</h1><p>这是leetcoad上一道比较简单的题目，也是第一题，解法一用到了常规的思路，解法二用到了散列表也即哈希表的知识点<br>解题思路如下：<br>    * 定义一个二维数组（为了存储找到的两个数）<br>    * 写一个两层的循环，范围是0~num.size<br>    * 判断如下：如果下标为i和j的两个数之和等于目标值并且下标不相等<br>    * 把下标为i和j的两个数储存在定义的数组a里面去。<br>    * 循环结束将a输出来</p>
<p>解法一：</p>
<pre><code class="python">class Solution :
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        list = [0,0]    #定义一个二维的数组
        #写两层循环直接进行遍历寻找到符合相应条件的值
        for i in range(len(nums)):
            for j in range(i+1,len(nums)):
                if nums[i]+nums[j] == target and i != j:
                #把相应的符合条件的下标赋值给之前定义的数组
                    list[0]=i
                    list[1]=j
        return list
</code></pre>
<p>解法二：</p>
<pre><code class="python"># 本质上将数组的值和索引存入map中，当遍历到某个值num的时候，判断map中是否含有target-x
class Solution:
    &#39;&#39;&#39;
        two sum的做法，实际就是在nums[i+1:],求解target为-nums[i]的two sum
    &#39;&#39;&#39;
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
       # 首先构建一个哈希表，用来存放数组的元素值以及索引值
       # 其中 key 是数组中的元素值
       # value 为数组中元素值的索引
       map = dict()
       # 接下来，遍历整个数组，利用enumerate函数可以输出下标以及对应的值
       for i, num in enumerate(nums):
           # 另外的一个值用目标值-num
           anotherNum = target - num
           # 查看这个值是否在哈希表中
           if anotherNum in map :
               # 因为题目的意思答案是唯一额，如果有就可以直接输出来，返回两个数的下标
               return [ map[ target - num ] , i ]
           else:
               # 按照nums[i] :i的格式添加到res中，key是对应的值，value是对应的下标
             map[nums[i]] = i
       return []
</code></pre>
<h1 id="leetcoad15-三数之和"><a href="#leetcoad15-三数之和" class="headerlink" title="leetcoad15-三数之和"></a>leetcoad15-三数之和</h1><p>leetcoad链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a><br>视频链接：<a target="_blank" rel="noopener" href="https://www.algomooc.com/1287.html">https://www.algomooc.com/1287.html</a><br>难点分析：如何去除重复解的问题(这道题也是一个关键的题目。务必要牢牢的掌握里面的框架以及实现的细节)<br><strong>算法流程：排序+双指针</strong><br>不重复的本质：（用排序就可以解决）</p>
<ol>
<li>第二重循环枚举到的元素不小于当前第一重循环枚举到的元素</li>
<li>第三重循环枚举到的元素不小于当前第二重循环枚举到的元素<br>对于每一重循环 :相邻两次枚举的元素不能相同，也需要剔除掉，跳到下一个不相同的元素<br>基于三重循环的伪代码实现：</li>
</ol>
<pre><code class="python">nums.sort()
for first = 0 .. n-1
    // 只有和上一次枚举的元素不相同，我们才会进行枚举
    if first == 0 or nums[first] != nums[first-1] then
        for second = first+1 .. n-1
            if second == first+1 or nums[second] != nums[second-1] then
                for third = second+1 .. n-1
                    if third == second+1 or nums[third] != nums[third-1] then
                        // 判断是否有 a+b+c==0
                        check(first, second, third)
</code></pre>
<p>由于固定一个a，那么另外的b和c是联动的，也即第二重循环和第三重循环是并列的关系，继续优化，保持第二重循环不变，将第三重循环变成从数组的最右端开始向左移动的指针<br>伪代码实现如下：</p>
<pre><code>nums.sort()
for first = 0 .. n-1
    if first == 0 or nums[first] != nums[first-1] then
        // 第三重循环对应的指针
        third = n-1
        for second = first+1 .. n-1
            if second == first+1 or nums[second] != nums[second-1] then
                // 向左移动指针，直到 a+b+c 不大于 0
                while nums[first]+nums[second]+nums[third] &gt; 0
                    third = third-1
                // 判断是否有 a+b+c==0
                check(first, second, third)
</code></pre>
<p>流程如下：</p>
<ol>
<li>特判，对于数组长度 n，如果数组为 null 或者数组长度小于 3，返回 []。</li>
<li>对数组进行排序。</li>
<li>遍历排序后数组：
            </div>
            <div class="post-more">
                <a href="/2022/03/21/%E5%93%88%E5%B8%8C%E8%A1%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%EF%BC%89/" class="post-title-link">
                    Read More
                </a>
            </div>
            <div class="post-meta">
                <div class="post-date">
                    22-03-21
                </div>
            </div>
        </div>
        
        <div class="post">
            <div class="post-title">
                <a href="/2022/03/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%BA%8C/" class="post-title-link">
                    二叉树相关题目汇总二
                </a>
            </div>
            <div class="post-content">
                
            </div>
            <div class="post-more">
                <a href="/2022/03/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%BA%8C/" class="post-title-link">
                    Read More
                </a>
            </div>
            <div class="post-meta">
                <div class="post-date">
                    22-03-21
                </div>
            </div>
        </div>
        
        <div class="post">
            <div class="post-title">
                <a href="/2022/03/21/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E7%B1%BB%E4%BA%8C/" class="post-title-link">
                    搜索算法、回溯算法系类二
                </a>
            </div>
            <div class="post-content">
                
            </div>
            <div class="post-more">
                <a href="/2022/03/21/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E7%B1%BB%E4%BA%8C/" class="post-title-link">
                    Read More
                </a>
            </div>
            <div class="post-meta">
                <div class="post-date">
                    22-03-21
                </div>
            </div>
        </div>
        
        <div class="post">
            <div class="post-title">
                <a href="/2022/03/21/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B8%80/" class="post-title-link">
                    搜索算法、回溯算法系列一
                </a>
            </div>
            <div class="post-content">
                <h1 id="深度优先搜索（Depth-First-Search-DFS）"><a href="#深度优先搜索（Depth-First-Search-DFS）" class="headerlink" title="深度优先搜索（Depth-First-Search,DFS）"></a>深度优先搜索（Depth-First-Search,DFS）</h1><p>类似于树的先序遍历，这种搜素算法尽可能深的去搜索一个图<br>参考链接：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/">https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/</a></p>
<h2 id="DFS和回溯算法的区别："><a href="#DFS和回溯算法的区别：" class="headerlink" title="DFS和回溯算法的区别："></a>DFS和回溯算法的区别：</h2><p>DFS:一种用于遍历或搜索树或图的算法，尽可能深的搜索树的分支，当结点 v 的所在边都己被探寻过，搜索将 回溯 到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。<br>回溯算法：采用试错的思想，尝试分步的去解决问题，在分步解决的过程中，当尝试发现有的分步答案不能得到有效的正确的解答的时候，<strong>取消上一步甚至上几步的计算</strong>，再通过其他可能的分步解答再次尝试寻找问题的答案。反复重复上诉过程后会有两种情况：</p>
<ol>
<li>找到一个可能存在的正确的答案</li>
<li>再尝试了所有可能的分步办法后宣告该问题没有答案。</li>
</ol>
<p>DFS 是一个劲的往某一个方向搜索，而回溯算法建立在 DFS 基础之上的，但不同的是在搜索过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索。因此回溯算法与 DFS 的区别就是有无状态重置，它强调了回退操作对于搜素的合理性，DFS强调一种遍历的思想。（广度优先遍历是另外的一种思想）</p>
<h2 id="与动态规划的区别："><a href="#与动态规划的区别：" class="headerlink" title="与动态规划的区别："></a>与动态规划的区别：</h2><p>共同点：用于求解多阶段的决策问题</p>
<ol>
<li>求解一个问题分为很多的步骤（阶段）</li>
<li>每一个步骤（阶段）可以有多种选择<br>不同点：</li>
<li>动态规划只是要求我们评估最优解是多少，最优解对应的具体解是什么并不要求，很适合应用于评估一个方案的效果</li>
<li>回溯算法可以得到所有方案（最优解含在内），本质是一种遍历算法，时间复杂度很高</li>
</ol>
<h2 id="何时使用回溯算法："><a href="#何时使用回溯算法：" class="headerlink" title="何时使用回溯算法："></a>何时使用回溯算法：</h2><p>当问题需要 “回头”，以此来查找出所有的解的时候，使用回溯算法。即<strong>满足结束条件或者发现不是正确路径的时候(走不通)，要撤销选择</strong>，<strong>回退到上一个状态，继续尝试，直到找出所有解为止</strong>。一般题目中看到需要求所有可能的结果，而不是结果个数的时候，我们就需要用暴力搜索所有的可行解，可以采用回溯法。</p>
<h2 id="递归函数的下面就是回溯的逻辑"><a href="#递归函数的下面就是回溯的逻辑" class="headerlink" title="递归函数的下面就是回溯的逻辑"></a>递归函数的下面就是回溯的逻辑</h2><p>树具有天然的递归：一般这种回溯的题目都是用的树来理解十分的清晰<br><strong>树的宽度用一个for循环来遍历，树的深度就是用的递归的性质</strong></p>
<h2 id="对于剪枝的理解："><a href="#对于剪枝的理解：" class="headerlink" title="对于剪枝的理解："></a>对于剪枝的理解：</h2><p>回溯算法的时间复杂度很高，在遍历的时候如果 能提前知道这一条分支不能搜索到满意的结果，就可以提前结束，加快搜索速度，有时候也需要做一些预处理（排序）才能达到剪枝的目的，预处理也耗时间，但是能够剪枝节约的时间更多。本质上是一种技巧，需要根据不同问题的场景采用不同的剪枝策略，需要在做题的过程中不断的进行总结。由于时间复杂度高，能够用空间换时间就尽量的换。</p>
<h2 id="一般来说回溯算法的思考步骤如下："><a href="#一般来说回溯算法的思考步骤如下：" class="headerlink" title="一般来说回溯算法的思考步骤如下："></a>一般来说回溯算法的思考步骤如下：</h2><p>（结合子集的题目来重点分析将大部分回溯算法的题目掌握清楚，当作一套模板背一下）</p>
<ol>
<li>画出递归树，找到状态变量（当画出树形图之后，整个思路就会一目了然，回溯函数的参数）：不断的去思考<ol>
<li>分支如何产生</li>
<li>题目需要的解在哪里？是在<strong>叶子节点</strong>，还是在<strong>非叶子节点</strong>，还是<strong>从根节点到叶子节点的路径</strong>？</li>
<li><strong>哪些搜索会产生不需要的解</strong>？产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？</li>
</ol>
</li>
<li>寻找结束条件，由于回溯算法是<strong>借助递归</strong>实现的，所以就是需要去寻找递归的终止条件（当前想要遍历的元素操作数组的长度）</li>
<li>确定选择列表，即需要把什么数据存储到结果里面</li>
<li>判断是否需要剪枝，去判断此时存储的数据是否之前已经被储存过（子集II,组合总和II,除去一些不符合题目要求的数，一些比较垃圾的逻辑，需要提前一步剪短）</li>
<li>做出选择，<strong>递归调用该函数，进入下一层继续搜索</strong></li>
<li><strong>撤销选择</strong>，回到上一层的状态（5和6就是通过两个函数来执行选与不选的操作的）</li>
</ol>
<h2 id="回溯算法的模板"><a href="#回溯算法的模板" class="headerlink" title="回溯算法的模板"></a>回溯算法的模板</h2><p>（参考东哥的算法小抄的理解）</p>
<pre><code class="python">ressult=[]
def backtrace(路径，选择列表):
    if 满足结束条件:
        result.append(路径)
        return 
    for 选择 in 选择列表:
        做选择
        backtrace(路径，选择列表)
        撤销选择
</code></pre>
<p>根据书上的额一些讲解，整理一些相对比较重点的点：</p>
<ol>
<li>核心就是for 循环里面的递归，<strong>在递归调用前做选择，在递归调用之后做撤销选择</strong></li>
<li>定义的回溯函数就像时一个指针，在决策树上进行遍历，同时正确维护每个节点的属性，每当走到树的底层，其”路径”就是一个子集（以子集举例）</li>
<li>前序遍历的代码：在进入某个节点之前的那个时间点执行；后序遍历的代码：在离开某个节点之后的那个时间点执行</li>
<li>做选择：从选择列表中拿出一个作为选择，并将它加入路径之中</li>
<li>撤销选择：从路径中拿出一个选择，将它恢复到“选择列表中”</li>
</ol>
<p>在写一遍框架模板：(加深印象)</p>
<pre><code class="python">for 选择 in 选择列表:
    # 做选择
    将该选择从列表中移除
    路径.append(选择)
    backtarce(路径，选择)
    # 撤销选择
    路径.pop(选择)
    将该选择恢复到选择列表中
</code></pre>
<p>这里既然已经谈到了回溯的算法（DFS）,也顺便把广度优先搜索的也整理一下，相应的思想要做一些区分的工作，而且层序遍历、滑动窗口的最大值这两道题也用到了BSF的思想还有二叉树的最小高度<br>主要是想把BFS的框架整理一下：</p>
<pre><code class="python"># 未完待续
# 计算从起点start到终点tareget的最短距离
def bfs(start,target):
    q=queqe()  # 核心数据结构
    visted=[]    #避免走回头路
    # 将起点加入队列中
    q.add(start)
    visited.append(start)
    step = 0 # 记录扩散的步数

    while q not empty:
        n=len(q)
        # 将当前队列中的所有结点向四周扩散
        for i in range(n):
            cur=
</code></pre>
<p>以下为回溯法的一些题目，这里先做一些汇总如下：主要是做了这么多的题目要找到相应的一些套路是十分重要的，多做总结，多归类才能进步的更快，一点一滴的要整理清楚。</p>
<h1 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h1><ol>
<li>leetcoad200-岛屿数量（很经典，值得多做，而且里面的方法也是值得在很多题目里面借鉴的）</li>
</ol>
<h1 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h1><ol>
<li>leetcoad78-子集（*）</li>
<li>leetcoad90-子集II（**）：需要排序，然后还要剪枝</li>
</ol>
<h1 id="组合问题："><a href="#组合问题：" class="headerlink" title="组合问题："></a>组合问题：</h1><ol>
<li>leetcoad77-组合（*递归出口地条件比较特殊）</li>
<li>leetcoad39-组合总和（**递归出口地条件有两个：目标值小于和目标值等于0，后续地一切元素地选择只能从函数地参数开始）</li>
<li>leetcoad40-组合总数II（***在组合总和地基础上其他条件不变，附加需要对元素先排序，然后再剪枝）</li>
<li>leetcoad216-组合总和III（暂时未涉及）</li>
</ol>
<h1 id="排列问题："><a href="#排列问题：" class="headerlink" title="排列问题："></a>排列问题：</h1><ol>
<li>leetcoad46-全排列</li>
<li>leetcoad47-全排列II</li>
</ol>
<h1 id="leetcoad200-岛屿数量"><a href="#leetcoad200-岛屿数量" class="headerlink" title="leetcoad200-岛屿数量(****)"></a>leetcoad200-岛屿数量(****)</h1><p>非常好的一道题，值得认真反复的回味清楚，而且可能还有其他的一些解法什么的，都是需要理解的，也是很基础的DFS的题目，是一道很单纯的题目，每次做一遍都会有新的发现,做个10几遍都不为过。<br>解题思路：</p>
<ol>
<li>创建一个同样大小的二维网格mark(初始化每个都是0)：用这个网格来统计二维数组中的岛屿数量的</li>
<li>每次判断网格是1的时候就记录下来，开始按照上、左、下、右的顺序去搜索当前的网格</li>
<li>0代表当前网格没有被访问，1代表当前网格被访问了</li>
<li>遍历二维网格，对每行、每列进行一个访问<ol>
<li>如果发现（i，j）是没有标记的陆地</li>
<li>对该位置进行搜索，调用DFS函数</li>
</ol>
</li>
<li>DFS函数的书写：<ol>
<li>先找一个已经遍历的</li>
<li>定义方向组</li>
<li>通过for循环来找到相邻的四个方向<ol>
<li>如果新的方向发生了越界（超出了数组边界）<ol>
<li>跳出循环</li>
</ol>
</li>
<li>如果发现新的位置是陆地，并且没有被标记过<ol>
<li>递归搜索函数发现新的位置（用递归的时候就要注意将标记改为1，防止被重复的访问，找到一处就标记一处）</li>
<li>搜索完之后，岛屿数量+1</li>
<li>每次完成一次搜索，都会往前回退（原路返回，回退一步就扩大岛的面积，不断扩大，直至形成一个孤岛）<br><img src="https://runnerxr.github.io/post-images/1651335354445.png"><br><img src="https://runnerxr.github.io/post-images/1651335481424.png"><br><img src="https://runnerxr.github.io/post-images/1651335984684.png"><br><img src="https://runnerxr.github.io/post-images/1651336156364.png"></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code class="python">class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:

        # count 代表岛屿数量
        count=0
        # mark 标记已经搜索的位置，大小与 grid 一致(这里需要理解，这里借助的是另外的数组，没有更改原数组的值，有些题解中，将原来为1的值经过搜索后改为0，直到搜索后不再发现0为止)
        # mark 初始化为 0，代表当前网格没有被访问
        mark=[[0]*len(grid[0]) for _ in range(len(grid))]

        # 遍历 grid，对每行每列都进行访问
        for i in range(len(grid)):
            for j in range(len(grid[i])):

                # 如果发现位置 （i ，j）是没有标记的陆地(是陆地，并且没有被搜索过)
                if grid[i][j] ==&quot;1&quot;and mark[i][j]==0:
                    # 对该位置进行搜索，看看有没有其他的陆地和它共同的组成岛屿
                    # 调用私有函数
                    self.DFS(grid,i,j,mark)
                    # 对 （i ，j）完成搜索后，岛屿数量加 1
                    count +=1

        return count


    # 将 grid 中与 x ，y 相连的位置在 mark 中进行标记
    # x表示行坐标，y表示列坐标
    def DFS(self,grid,x,y,mark: List[List[str]]) :

        # 当前搜索位置在 mark 中标记为 1 ，代表已经遍历了
        mark[x][y]=1

        # 循环遍历当前位置的上、下、左、右四个方向，这里写成了循环的方式，有的地方是分别按照4个敌对来写的
        for dx, dy in ((-1,0),(1,0),(0,-1),(0,1)):

            # newX 代表新的行
            newX=dx + x

            # newY 代表新的列
            newY = dy + y

            # 如果新的位置超出了数组边界
            # x坐标超出左右边界，y坐标超出上下边界
            if newX&lt; 0 or newX&gt;=len(mark) or newY &lt;0 or newY &gt;=len(mark[newX]):
                # 跳出该位置
                continue

            # 如果发现新位置是陆地，并且没有被标记过
            if grid[newX][newY]==&quot;1&quot; and mark[newX][newY]==0:
                # 递归搜索新的位置，查看是否还有新的位置是陆地，共同的加入形成岛屿
                self.DFS(grid,newX,newY,mark)

# 算例（和自己的手抄笔记匹配的）
# [[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]
# 输出 ：3
</code></pre>
<pre><code class="python"># 尝试简化一些写法
class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        count=0
        mark=[[0]*len(grid[0]) for _ in range(len(grid))]

        for i in range(len(grid)):
            for j in range(len(grid[i])):
                if grid[i][j] ==&quot;1&quot;and mark[i][j]==0:
                    self.DFS(grid,i,j,mark)
                    count +=1
        return count

    def DFS(self,grid,x,y,mark: List[List[str]]) :
        mark[x][y]=1
        for dx, dy in ((-1,0),(1,0),(0,-1),(0,1)):
            newX=dx + x
            newY = dy + y
            if newX&lt; 0 or newX&gt;=len(mark) or newY &lt;0 or newY &gt;=len(mark[newX])
                continue
            if grid[newX][newY]==&quot;1&quot; and mark[newX][newY]==0:
                self.DFS(grid,newX,newY,mark)
</code></pre>
<p>5月1日再次回顾：也不知道这是自己写的第几遍的过程了，但是还是存在问题，这里将问题记录如下，不仅是算法思维要正确，同样的代码也要过关才行，否则就是一堆的bug：</p>
<ol>
<li>问题一：边界出现问题。<img src="https://runnerxr.github.io/post-images/1651411102787.png">，dfs函数里面的x和y为矩阵的行坐标和列坐标（从0开始的），出界的条件是x&gt;&#x3D;行数，y&gt;&#x3D;列数</li>
<li>问题二，<img src="https://runnerxr.github.io/post-images/1651411240693.png">判断条件漏写，这里在最后的时候，满足搜索条件有两个，一个是当前访问的是陆地，另一个是当前这块陆地没有被标记。</li>
<li>问题三，这里不像其他的复杂的回溯问题，没有取消元素选择并弹出元素的过程。</li>
</ol>
<p><strong>甚至还可以采用并查集的思想来做题</strong>（主要是理解思路 ）<br>参考链接：<a target="_blank" rel="noopener" href="https://liweiwei1419.gitee.io/leetcode-algo/2017/10/26/leetcode-algo/0200-number-of-islands/">https://liweiwei1419.gitee.io/leetcode-algo/2017/10/26/leetcode-algo/0200-number-of-islands/</a><br><img src="https://runnerxr.github.io/post-images/1650609416171.png"><br>设计算法如下：</p>
<ol>
<li>如果是陆地，尝试与周围合并</li>
<li>如果是水域，把水域合并在一起<br>需要注意的点：</li>
<li>将二维数组与一维数组进行互换的过程需要熟悉（x*列数+y）</li>
<li>对水域也需要计数</li>
<li>最后的数量&#x3D;原数组数量-陆地连通后减少的数量-水域的数量（其实是有一点间接的感觉，不过也是主流的做法之一）</li>
<li>和DFS一样，也是需要做边界情况的判断</li>
</ol>
<pre><code class="python"># 后续代码自己整理
# 值得自己反复的做多遍，因为是python，所以有些代码相教Java是做了一些简化的
class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        # 边界条件
        if not grid:return 0

        m,n = len(grid),len(grid[0])
        # 水域的数量
        water = 0

        # 1. 初始化并查集
        # 一行代码解决,注意数组的大小
        p = [i for i in range(m*n)]

        # 2. 开始遍历，合并为1的节点
        for i in range(m):
            for j in range(n):
                # 如果存在陆地，调用_union函数,将所有的陆地进行合并
                # 需要把二维问题转化为一维问题
                if grid[i][j]==&#39;1&#39;:
                    # self._union(p,i,j)，这是适用于一维的情况
                    # 合并上下左右为1的节点,改为一个共同的祖先
                    directions = [(-1,0),(1,0),(0,-1),(0,1)]
                    for x,y in directions:
                        x= x + i
                        y= y + j
                        # 对于新的行和列，如果行列都不越界，并且此时的标记也是为1的话，就进行合并祖先的操作。
                        if x &gt;=0 and y &gt;=0 and x &lt;m and y &lt;n and grid[x][y]==&#39;1&#39;:
                            # 经过union操作后，祖先都变为相同了，此时数组的值并没有改变，但是下一次遍历到数值虽然是1，祖先已经被同化了
                            self._union(p,x*n+y,i*n+j)
                else:
                    # 把水域的数量+1
                    water +=1

        # 3. 看n里面总共有几个parent
        # 这里取值的问题
        # return len(set([self._parent(p,i) for i in range(m*n)]))
        res = [self._parent(p,i) for i in range(m*n)]
        return len(set(res))-water


    # _union和_parent直接按模板抄上来
    def _union(self,p,i,j):
        p1 = self._parent(p,i)
        p2 = self._parent(p,j)
        p[p2]=p1


    # 类似于find函数
    def _parent(self,p,i):
        root = i
        # 本质上也是一个递归操作
        while p[root] != root:
            root = p[root]
        # 路径压缩
        while p[i] != i:
            x ,i,p[x] = i,p[i],root
        return root
</code></pre>
<p>对python代码做一点修改，主要是为了和java以及主流的代码思路保持一致</p>
<pre><code class="python">class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        # 边界条件:如果网格为空或者行数为0,直接返回空
        if grid is None or len(grid)==0: return 0
        # 统计水域的数量,初始化为0
        waters = 0

        # 为了方便调用函数,因为union  find和getCount都在uf类之下
        uf = UnionFind(grid)
        m,n=len(grid),len(grid[0])
        for i in range(m):
            for j in range(n):
                # 如果发现的是水域,就把水域数量+1
                if grid[i][j]==&#39;0&#39;:
                    waters +=1
                # 如果是陆地,就需要朝四个方向进行搜索
                else:
                    # 合并上下左右为1的节点,改为一个共同的祖先
                    # 合并上边节点(i-1,j)，注意不能出界
                    directions = [(-1,0),(1,0),(0,-1),(0,1)]
                    for x,y in directions:
                        x= x + i
                        y= y + j
                        # 对于新的行和列，如果行列都不越界，并且此时的标记也是为1的话，就进行合并祖先的操作。
                        if x &gt;=0 and y &gt;=0 and x &lt;m and y &lt;n and grid[x][y]==&#39;1&#39;:
                            uf.union(x*n+y,i*n+j)
        return uf.getCount() - waters


# 定义UnionFind类,当作模板
class UnionFind:
    # 方法,类似于构造一个和网格类似的一维数组
    def __init__(self,grid):
        m,n=len(grid),len(grid[0])
        # 创建一个一维的root数组,长度与grid的长度相同
        self.root= [-1]*m*n
        # 一开始初始化为多少个元素
        # 最终应该减去水域的个数-联通之后的减少的个数
        self.count = m*n
        for i in range(m*n):
            self.root[i]=i 
    
    def find(self,x):
        if x ==self.root[x]:
            return self.root[x]
        else:
            self.root[x]=self.find(self.root[x])
            return self.root[x]
    
    def union(self,x,y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX !=rootY:
            self.root[rootX] = rootY
            self.count -=1
    
    def getCount(self):
        return self.count
</code></pre>
<p>在上面的一个题解的基础上做进一步的优化（建议把上面的几种方式十分熟练之后再做相应的处理，还会让自己更上一步台阶）<br>优化的两个点：参考资料<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Q5411H7v5?p=2">https://www.bilibili.com/video/BV1Q5411H7v5?p=2</a></p>
<ol>
<li>优化包括quick find和quick  union,这里主要还是quick union,对树的高度进行了优化，权重的优化</li>
<li>对搜索的方向进行了优化（这个只是作为平时的解答，在面试的时候，还是按照常规思路来作答比较的好）</li>
</ol>
<pre><code class="python"># 定义UnionFind类,模板,但是也是做了一定的修改的.(根据题目的不同)
class UnionFind:
    # 方法,类似于构造一个和网格类似的一维数组
    def __init__(self,grid):
        m,n=len(grid),len(grid[0])
        # 创建一个一维的root数组,长度与grid的长度相同
        self.root= [-1]*m*n
        # 定义了一个rank数组，记录每一组树的高度，初始化为0
        self.rank = [0]*m*n
        # 一开始初始化为0
        self.count = 0
        for i in range(m):
            for j in range(n):
                # 以下的代码既构造一个序列号==祖先的数组,同时还记录了陆地的数量
                if grid[i][j]==&#39;1&#39;:
                    self.root[i*n+j]=i*n+j 
                    self.count+=1
    
    def find(self,x):
        if x ==self.root[x]:
            return self.root[x]
        else:
            self.root[x]=self.find(self.root[x])
            return self.root[x]
    
    def union(self,x,y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX !=rootY:
            # 再加入一个判断,保证并查集不会退化为单链,树形结构尽量的矮一点,从而快速获得结点的根
            
            # 比较两个树的树高,rootX的树高小于rootY的树高，把矮的树连接到高的树上面去
            # 即把rootX的根节点放到rootY
            if self.rank[rootX] &lt;self.rank[rootY]:
                rootX,rootY=rootY,rootX
            # 否则：把rootY的根节点放到rootX(把 y连到x)
            self.root[rootY] = rootX
            # 以上的三行代码是做了相应的优化的实际上是这四行代码
            # if self.rank[rootX] &lt;self.rank[rootY]:
            #      self.root[rootX] = rootY
            # elif self.rank[rootX] &lt;self.rank[rootY]:
            #     self.root[rootY] = rootX
            elif self.rank[rootX] ==self.rank[rootY]:
                self.rank[rootX] +=1
            self.count -=1
    
    def getCount(self):
        return self.count

class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        # 边界条件:如果网格为空或者行数为0,直接返回空
        if grid is None or len(grid)==0: return 0

        # 为了方便调用函数,因为union  find和getCount都在uf类之下
        uf = UnionFind(grid)
        m,n=len(grid),len(grid[0])
        for i in range(m):
            for j in range(n):
                # 如果是陆地,就需要朝四个方向进行搜索
                if grid[i][j]==&#39;1&#39;:
                    # 合并上下左右为1的节点,改为一个共同的祖先
                    # 合并上边节点(i-1,j)，注意不能出界
                    # directions = [(-1,0),(1,0),(0,-1),(0,1)]
                    # 对于方向向量,可以只用右边和下边
                    directions = [(1,0),(0,1)]
                    for x,y in directions:
                        x= x + i
                        y= y + j
                        # 对于新的行和列，如果行列都不越界，并且此时的标记也是为1的话，就进行合并祖先的操作。
                        if x &gt;=0 and y &gt;=0 and x &lt;m and y &lt;n and grid[x][y]==&#39;1&#39;:
                            uf.union(x*n+y,i*n+j)
                    # if i+1&lt;m and grid[i+1][j]==&#39;1&#39;:
                    #     uf.union((i+1)*n+j,i*n+j)
                    # if j+1&lt;n and grid[i][j+1]==&#39;1&#39;:
                    #     uf.union(i*n+j+1,i*n+j)
        return uf.getCount()
</code></pre>
<h1 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h1><p>解题思路：<br>用空间换时间的操作<br>一旦发现是错的，就需要推到重来<br>还有浅拷贝和深拷贝的情况：值传递和引用传递的区别<br>运用数学公式去更新棋盘<br>回溯和递归的关系：用递归的代码来解决回溯的算法，需要把某些代码做一个重置、剪枝操作（一定要深入理解递归的算法）</p>
<ol>
<li>构建两个数组,一个数组是攻击数组:attack(是否可以放置皇后)</li>
</ol>
<pre><code class="python"># 待整理
</code></pre>
<h1 id="leetcoad78-子集-middle"><a href="#leetcoad78-子集-middle" class="headerlink" title="leetcoad78-子集(middle)"></a>leetcoad78-子集(middle)</h1><p><strong>非常重要-重点掌握，每一行代码都要清楚，并且还要清楚相应的调试过程，把DFS+剪枝的操作掌握得烂熟于心的程度（本题没有剪枝过程），由子集的解题步骤衍生出的7道题目的写法</strong><br>方法一：采用树形递归的方式（结合树形图理解相应的递归路线，本质是一种深度优先搜索DFS）<br><img src="https://runnerxr.github.io/post-images/1649694805789.png"><br>结合着张图以及后面自己在本地调式的过程，基本上是把这个过程给完完全全的整理清楚了。<br>方法二：采用循环的思路来解决（与方法一的区别：把子集加入结果数组的时机不一样，本质的思路是一样的）<br>方法三：采用广度优先搜索（BFS）,是一种分层搜索的方法，不是递归形式的，不需要回退<br>函数：</p>
<ol>
<li>每次调用这个函数，我们都会在当前数组中可用的区间中搜索出一个元素来，每找到一个元素就在原先的路径上添加的一个元素，此时你无论添加一个什么样的元素，当前都已经有一条完整的路径了，形成的一个路径就是一个子集，加入到我们的结果数组中</li>
<li>i肯定会超过数组，一旦超过数组的话，就结束相应的判断，否则的话：确定选了1之后，开始查看后面有多少种选择，利用三行代码把所有的子集添加进去：<ol>
<li>利用subset.add扩充新的元素进去，判断是否需要剪枝，去判断此时储存的数据是否之前已经被储存过</li>
<li>做出选择，递归调用该函数，进入下一层继续 （当前的这个搜索区间不再是从2开始的，从2的后面的元素开始的。）backtrack</li>
<li>撤销选择，回到上一层的状态：subset.remove</li>
</ol>
</li>
</ol>
<p>看视频做的一点记录：<br>对于每个元素都有两种选择方案：选或者不选，总共有2^n种<br>无法利用一次循环来把所有的元素都选出来：对于某个元素做出选或者不选的决定后，之前选择的元素与该元素共同组成一个新的组合，会漏掉一个不选的元素<br>把选1的策略全部走完<br>然后把选2的策略全部走完</p>
<pre><code class="python"># 按照吴师兄的思路一步步的调试清楚
class Solution:
    def subsets(self, nums: List[int]) -&gt; List[List[int]]:
        # 结果集合
        sets=[]
        #每次的子集
        subset=[]
        # 执行回溯算法
        self.backtrack(0,nums,subset,sets)
        # 返回结果
        return sets
    # i 表示递归时正在访问的数组元素下标
    # nums 表示当前集合中的元素
    # subset 表示每次递归后生成的子集，就是路径上的那些元素,类似于临时的子数组
    # sets 表示最终生成的所有子集合
    # 画出递归树，找到状态变量（回溯函数的参数）
    def backtrack(self,i:int,nums:List[int],subset:List[int],sets:List[List[int]]) -&gt; List[List[int]]:
        # 每次确定好一个子集，都把它加入到结果集合中
        sets.append(subset[:])
        # 此处在调试的时候加入一个打印，有助于了解相应的不断递归过程
        # print(&quot;  递归前subset =&gt; &quot; ,subset)
        # print(&quot;  递归前sets =&gt; &quot; ,sets)
        # 2、寻找结束条件，由于回溯算法是借助递归实现，所以也就是去寻找递归终止条件
        # 本题中可以不加这个判断，大家可以思考一下为什么可以不加，结合 for 循环的边界来思考
        n = len(nums)
        # 当访问的数组下标超过了nums数组的长度时，递归结束（这里的理解非常重要，只有递归结束了，才会有回溯的操作过程，这是一体的）
        # 此处也可以不加判断，理由，通过调试的过程中我们就会发现，当n=len(nums)的时候，此时不会进入到循环之中，直接跳到subset.pop(len(subset) - 1)这一行代码，类似于是递归的最后一次循环了。
        if i &gt;=n:
            return
        # 3、确定选择列表，需要把什么数据存储到结果里面
        # for 循环就是一个选择的过程
        # 遍历本层集合中的元素
        for j in range(i,n):
            # 把本次递归访问的元素加入到 subset 数组中
            subset.append(nums[j])
            # 4、判断是否需要剪枝，去判断此时存储的数据是否之前已经被存储过
            # 本题不需要剪枝
            # 5、做出选择，递归调用该函数，进入下一层继续搜索
            # 递归
            # 此时需要传入新的参数
            self.backtrack( j+1,nums , subset , sets)
            # 6、撤销选择，回到上一层的状态
            # 取消对 nums[i] 的选择（这里的取消选择的过程，自己也可以通过代码来进行调试，让自己更加熟悉这个过程：只有在递归到尽头的时候才会进行回溯的操作）
            subset.pop(len(subset) - 1)
            #print(&quot; 取消subset最后一个元素 =&gt; &quot; ,subset)

# 头文件
if __name__ == &#39;__main__&#39;:
    # 输入一个特定的需要求解的数组
    nums = [1,2,3]
    res = Solution().subsets(nums)
    #print(res)
    print(&quot;  输出 =&gt; &quot; ,res)

# 输出结果如下
# 一开始就选1时，从头递归到尾
#  递归前subset =&gt;  []
#   递归前sets =&gt;  [[]]
#   递归前subset =&gt;  [1]
#   递归前sets =&gt;  [[], [1]]
#   递归前subset =&gt;  [1, 2]
#   递归前sets =&gt;  [[], [1], [1, 2]]
#   递归前subset =&gt;  [1, 2, 3]
#   递归前sets =&gt;  [[], [1], [1, 2], [1, 2, 3]]

# 一开始就选1时，从递归结束的地方开始回溯
#   取消subset最后一个元素 =&gt;  [1, 2]
#   取消subset最后一个元素 =&gt;  [1]

# # 一开始就选1时，回退到选3不选2的过程
#   递归前subset =&gt;  [1, 3]
#   递归前sets =&gt;  [[], [1], [1, 2], [1, 2, 3], [1, 3]]
#   取消subset最后一个元素 =&gt;  [1]
#   取消subset最后一个元素 =&gt;  []

#   回退到空，然后开始选2的过程
#   递归前subset =&gt;  [2]
#   递归前sets =&gt;  [[], [1], [1, 2], [1, 2, 3], [1, 3], [2]]
#   递归前subset =&gt;  [2, 3]
#   递归前sets =&gt;  [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3]]

# 选2的时候递归结束开始回溯的一个过程
#   取消subset最后一个元素 =&gt;  [2]
#   取消subset最后一个元素 =&gt;  []

#   回退到空，然后开始选3的过程
#   递归前subset =&gt;  [3]
#   递归前sets =&gt;  [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]

#   回退到空，然后开始选3的下一个元素的过程（发现此时已经无元素可以选择了）
#   取消subset最后一个元素 =&gt;  []

# 最终对sets进行输出
#   输出 =&gt;  [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]
</code></pre>
<pre><code class="python"># 自己对代码做一点简化，比如我把函数写在了subsets里面，就不需要再另外的去定义sets和subset变量。
class Solution:
    def subsets(self, nums: List[int]) -&gt; List[List[int]]:
        sets=[]
        subset=[]

        def backtrack(i:int,nums):
            sets.append(subset[:])
            # print(&quot; subset =&gt; &quot; ,subset)
            # print(&quot; sets =&gt; &quot; ,sets)
            n = len(nums)
            if i &gt;=n:
                return
            for j in range(i,n):
                subset.append(nums[j])
                backtrack( j+1,nums )
                # 弹出subset中的最后一个元素
                subset.pop()
                # print(&quot; 取消subset最后一个元素的选择 =&gt; &quot; ,subset)

        # 调用回溯算法
        backtrack(0,nums)
        # 返回结果
        return sets
</code></pre>
<p><strong>迭代法</strong>（待整理）<br>参考链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/">https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/</a></p>
<pre><code class="python">class Solution:
    def subsets(self, nums: List[int]) -&gt; List[List[int]]:
        res = [[]]
        for i in nums:
            res = res + [[i] + num for num in res]
        return res
</code></pre>
<h1 id="leetcoad90-子集II-middle"><a href="#leetcoad90-子集II-middle" class="headerlink" title="leetcoad90-子集II(middle)"></a>leetcoad90-子集II(middle)</h1><p><img src="https://runnerxr.github.io/post-images/1652361154485.png"><br>相比于子集，加入了一个剪枝的操作：判断当前的元素是否和之前的元素相同，如果相同就不去执行后面的代码。（后面的代码是将当前元素作为一种选择情况下的那一个子集加入到相应的结果数组中，当前的情况已经在之前分析过了，不需要再执行了,子集那道题已经限制了给定的值是互不相同的）</p>
<pre><code class="python"># 并加入头文件进行调试，选用的例子是nums=[1,2,2],如果选用[1,2,3],得到的结果和子集I是一样的结果
from typing import List
class Solution:
    def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]:
        # 对原数组排序，这样才能对比当前元素和之前的元素是否相同
        nums.sort()
        sets=[]
        subset=[]

        def backtrack(i:int,nums):
            sets.append(subset[:])
            n = len(nums)
            if i &gt;=n:
                return
            for j in range(i,n):
                # 剪枝
                if j &gt;i and nums[j-1]==nums[j]:
                    continue
                subset.append(nums[j])

                backtrack( j+1,nums )
                # 弹出subset中的最后一个元素
                subset.pop()

        # 调用回溯算法
        backtrack(0,nums)
        # 返回结果
        return sets

# 头文件
if __name__ == &#39;__main__&#39;:
    # 输入一个特定的需要求解的数组
    nums = [1,2,2]
    res = Solution().subsetsWithDup(nums)
    #print(res)
    print(&quot;  输出 =&gt; &quot; ,res)


# 输出结果如下：

# 一开始就选1时，从头递归到尾
# subset =&gt;  []
#  sets =&gt;  [[]]
#  subset =&gt;  [1]
#  sets =&gt;  [[], [1]]
#  subset =&gt;  [1, 2]
#  sets =&gt;  [[], [1], [1, 2]]
#  subset =&gt;  [1, 2, 2]
#  sets =&gt;  [[], [1], [1, 2], [1, 2, 2]]  

# 一开始就选1时，从递归结束的地方开始回溯，由于后面还有一个2，与上一次选择相同，不会再选择，直接回溯到空
#  取消subset最后一个元素的选择 =&gt;  [1, 2]
#  取消subset最后一个元素的选择 =&gt;  [1]   
#  取消subset最后一个元素的选择 =&gt;  []

#   回退到空，然后开始选2的过程
#  subset =&gt;  [2]
#  sets =&gt;  [[], [1], [1, 2], [1, 2, 2], [2]]
#  subset =&gt;  [2, 2]
#  sets =&gt;  [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]
#  取消subset最后一个元素的选择 =&gt;  [2]
#  取消subset最后一个元素的选择 =&gt;  []

#   回退到空，然后开始选2的下一个元素的过程（发现此时已经无元素可以选择了）

#   输出 =&gt;  [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]
</code></pre>
<h1 id="leetcoad77-组合-middle"><a href="#leetcoad77-组合-middle" class="headerlink" title="leetcoad77-组合(middle)"></a>leetcoad77-组合(middle)</h1><p>题目描述：给定两个整数 n 和 k，返回范围 [1, n] 中<strong>所有可能的 k 个数的组合</strong>。<br>你可以按 任何顺序 返回答案。<br>输入：n &#x3D; 4, k &#x3D; 2<br>输出：<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]<br>做题链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/">https://leetcode-cn.com/problems/combinations/</a><br><img src="https://runnerxr.github.io/post-images/1652362914174.png"><br><img src="https://runnerxr.github.io/post-images/1652363742876.png"><br>做题思路：<br>这里用4个元素中找出3个数的组合来解题</p>
<ol>
<li>理解题目的意思：当前总共有三个坑，如何<strong>从四个元素中去寻找三个元素</strong>去填满这些坑，可以将数组中的每一个元素作为三个坑的第一个元素，然后在剩下的三个元素中去寻找两个元素出来，将剩下的这两个坑填满。然后在填了两个坑的基础上，查看后面的以后个坑如何选择</li>
<li>实现地具体过程以及相应地注意点：<ol>
<li>递归地终止条件变了：需要填入地数为0</li>
<li>确定选择列表地时候也变了，选择地终止索引为后面地数刚好能凑齐k个数截至（想要保证数不重复，又要把元素填满）</li>
</ol>
</li>
</ol>
<pre><code class="python">暂时没有代码，待补充
</code></pre>
<h1 id="leetcoad39-组合总和-middle"><a href="#leetcoad39-组合总和-middle" class="headerlink" title="leetcoad39-组合总和(middle)"></a>leetcoad39-组合总和(middle)</h1><p>题目描述：<br>给你一个 <strong>无重复元素</strong> 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。<br>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。<br>理解题目的意思之后再谈做题的方法：</p>
<ol>
<li>仍然可以用回溯的算法思想</li>
<li>第一次是可以选择任意元素，在第一次选择的基础上，剩下的就是要凑出target-nums[i]的和，然后继续进行下一轮的选择，<strong>在选数的时候不能选比当前需要值大的数</strong>。<br>以下结合这几张图来辅助理解这里的过程<br><img src="https://runnerxr.github.io/post-images/1652364640585.png"></li>
<li>罗列所有选择并排除不合适的选择，这样就选出了[2,2,3] [2,3,2] [3,2,2] [7],但是这和题目的意思是不符合的，组合的话是不用管顺序的<br><img src="https://runnerxr.github.io/post-images/1652364808224.png"></li>
<li>紧接着就思考，如何进行剪枝的问题？对于想要凑齐5的情况，由于第一次已经选了2 2 3，当下一次选到2 3的时候就会发现之前是舍弃了2没有选的，那么在接下的选择中就也不能选择2，只能从3开始选择，同理在凑齐4的过程中，由于前面是选择了3的，所以后面就不能再选比3小的数，也就只能从3开始选，也就有了下面的这张图的理解过程<br><img src="https://runnerxr.github.io/post-images/1652364824518.png"></li>
<li>再紧接着就思考递归结束的条件：</li>
</ol>
<pre><code>   1. target&lt;0
   2. target==0
</code></pre>
<p>4.再接着就是确定选择列表，需要将什么样的数加入进去，精髓就在于递归的时候传入的数据：backtrack(nums,target-nums[i],path,newposition)<br>5.初调用函数的时候表示：从第0个元素开始选择，要筹齐的目标数为原始目标数，然后随着不断地递归,target不断地减小，最后达到递归地出口地位置。</p>
            </div>
            <div class="post-more">
                <a href="/2022/03/21/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B8%80/" class="post-title-link">
                    Read More
                </a>
            </div>
            <div class="post-meta">
                <div class="post-date">
                    22-03-21
                </div>
            </div>
        </div>
        
        <div class="post">
            <div class="post-title">
                <a href="/2022/03/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E4%BD%8D%E8%BF%90%E7%AE%97/" class="post-title-link">
                    二分查找-位运算
                </a>
            </div>
            <div class="post-content">
                
            </div>
            <div class="post-more">
                <a href="/2022/03/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E4%BD%8D%E8%BF%90%E7%AE%97/" class="post-title-link">
                    Read More
                </a>
            </div>
            <div class="post-meta">
                <div class="post-date">
                    22-03-21
                </div>
            </div>
        </div>
        
        <div class="post">
            <div class="post-title">
                <a href="/2022/03/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%B8%80/" class="post-title-link">
                    二叉树相关题目汇总一
                </a>
            </div>
            <div class="post-content">
                
            </div>
            <div class="post-more">
                <a href="/2022/03/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%B8%80/" class="post-title-link">
                    Read More
                </a>
            </div>
            <div class="post-meta">
                <div class="post-date">
                    22-03-19
                </div>
            </div>
        </div>
        
        <div class="post">
            <div class="post-title">
                <a href="/2022/03/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%EF%BC%88%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%89/" class="post-title-link">
                    动态规划算法合集（系列一）
                </a>
            </div>
            <div class="post-content">
                
            </div>
            <div class="post-more">
                <a href="/2022/03/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%EF%BC%88%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%89/" class="post-title-link">
                    Read More
                </a>
            </div>
            <div class="post-meta">
                <div class="post-date">
                    22-03-18
                </div>
            </div>
        </div>
        
    </div> -->
    <div class="search-wrapper">
    <form id="search-form"> <!-- 搜索框相关 -->
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off"/>
        <i class="fa fa-times" onclick="resetSearch()"></i> <!-- 清空/重置搜索框 -->
    </form>
    <div id="local-search-result"></div> <!-- 搜索结果区 -->
    <p class='no-result'>No results found </p> <!-- 无匹配时显示，注意请在 CSS 中设置默认隐藏 -->
</div>
    <div class="archive">
    <ul class="post-archive">
        
        <li class="post-item">
            <span class="post-date">
                22/03/25</span>
            <a href="/2022/03/25/%E5%88%86%E6%B2%BB%E6%B3%95%E7%9A%84%E6%80%9D%E6%83%B3%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98%EF%BC%88Divide%20and%20conquer%EF%BC%89/" class="post-title">
                分治法的思想及相关例题（Divide and conquer）
            </a>
        </li>
        
        <li class="post-item">
            <span class="post-date">
                22/03/25</span>
            <a href="/2022/03/25/%E6%97%B6%E5%88%BB%E7%89%A2%E8%AE%B0%E5%9C%A8%E5%BF%83%E5%8D%B4%E4%B8%8D%E5%BF%85%E6%8A%8A%E8%BF%99%E4%BB%B6%E4%BA%8B%E6%8C%82%E5%9C%A8%E5%98%B4%E8%BE%B9/" class="post-title">
                时刻牢记在心却不必把这件事挂在嘴边
            </a>
        </li>
        
        <li class="post-item">
            <span class="post-date">
                22/03/23</span>
            <a href="/2022/03/23/%E7%B3%BB%E7%BB%9F%E8%AF%A6%E7%BB%86%E7%9A%84%E6%95%B4%E7%90%86%E5%85%B3%E4%BA%8Epython%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" class="post-title">
                系统详细的整理关于python中的面向对象编程/面对对象高级编程
            </a>
        </li>
        
        <li class="post-item">
            <span class="post-date">
                22/03/21</span>
            <a href="/2022/03/21/%E5%93%88%E5%B8%8C%E8%A1%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%EF%BC%89/" class="post-title">
                哈希表问题汇总（散列函数）
            </a>
        </li>
        
        <li class="post-item">
            <span class="post-date">
                22/03/21</span>
            <a href="/2022/03/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%BA%8C/" class="post-title">
                二叉树相关题目汇总二
            </a>
        </li>
        
        <li class="post-item">
            <span class="post-date">
                22/03/21</span>
            <a href="/2022/03/21/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E7%B1%BB%E4%BA%8C/" class="post-title">
                搜索算法、回溯算法系类二
            </a>
        </li>
        
        <li class="post-item">
            <span class="post-date">
                22/03/21</span>
            <a href="/2022/03/21/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B8%80/" class="post-title">
                搜索算法、回溯算法系列一
            </a>
        </li>
        
        <li class="post-item">
            <span class="post-date">
                22/03/21</span>
            <a href="/2022/03/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E4%BD%8D%E8%BF%90%E7%AE%97/" class="post-title">
                二分查找-位运算
            </a>
        </li>
        
        <li class="post-item">
            <span class="post-date">
                22/03/19</span>
            <a href="/2022/03/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%B8%80/" class="post-title">
                二叉树相关题目汇总一
            </a>
        </li>
        
        <li class="post-item">
            <span class="post-date">
                22/03/18</span>
            <a href="/2022/03/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%EF%BC%88%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%89/" class="post-title">
                动态规划算法合集（系列一）
            </a>
        </li>
        
    </ul>
</div>

<div class="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo;Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/">Next&amp;raquo;</a>
</div>

</div>

<div class="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo;Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/">Next&amp;raquo;</a>
</div>

        <div class="footer">
    <a href="#">
        2018 <i class="fab fa-studiovinari"></i> bear <i class="fas fa-angle-double-up"></i>
    </a>
</div>


<script src="/js/totop.js"></script>


<script src="/js/search.js"></script>

    </div>
</body>

</html>