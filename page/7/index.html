<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-python数据结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/09/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2022-03-09T05:59:38.000Z" itemprop="datePublished">2022-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/09/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">python数据结构---待持续更新</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>数据结构:</p>
<ol>
<li>是以某一种形式组合在一起的数据集合</li>
<li>是计算机储存和组织数据的方式</li>
<li>支持数据的访问和对数据的操作</li>
<li>数据结构的设计直接影响存储和计算的效率</li>
<li>常用的数据结构:数组 栈  队列   链表 树  图  哈希表等</li>
</ol>
<p>主要网址：<a target="_blank" rel="noopener" href="https://www.runoob.com/python3/python3-data-structure.html">https://www.runoob.com/python3/python3-data-structure.html</a><br>主要的几个大点：<br>    1. 将列表当作堆栈使用<br>    2. 将列表当作队列使用<br>    3. 列表推导式<br>    4. 嵌套列表解析<br>    5. del语句<br>    6. 元组和序列<br>    7. 集合<br>    8. 字典<br>    9. 遍历技巧</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/09/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="claqu8zyz0017iwtke01t92z9" data-title="python数据结构---待持续更新" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-关于栈与队列基础知识及相关衍生的题目汇总二(important)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/09/%E5%85%B3%E4%BA%8E%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A1%8D%E7%94%9F%E7%9A%84%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%BA%8C(important)/" class="article-date">
  <time class="dt-published" datetime="2022-03-09T05:44:13.000Z" itemprop="datePublished">2022-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/09/%E5%85%B3%E4%BA%8E%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A1%8D%E7%94%9F%E7%9A%84%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%BA%8C(important)/">关于栈与队列基础知识及相关衍生的题目汇总二(important)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>未完待续</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/09/%E5%85%B3%E4%BA%8E%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A1%8D%E7%94%9F%E7%9A%84%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%BA%8C(important)/" data-id="claqu8zza001tiwtk9teahzfg" data-title="关于栈与队列基础知识及相关衍生的题目汇总二(important)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" rel="tag">python知识小记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-关于栈与队列基础知识及相关衍生的题目汇总一(important)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/08/%E5%85%B3%E4%BA%8E%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A1%8D%E7%94%9F%E7%9A%84%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%B8%80(important)/" class="article-date">
  <time class="dt-published" datetime="2022-03-08T02:46:17.000Z" itemprop="datePublished">2022-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/08/%E5%85%B3%E4%BA%8E%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A1%8D%E7%94%9F%E7%9A%84%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%B8%80(important)/">关于栈与队列基础知识及相关衍生的题目汇总一(important)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>栈与队列通常放到一起来学习，也是基础中的基础，概念一定要十分的清晰明了</p>
<h1 id="栈是先进后出的线性表"><a href="#栈是先进后出的线性表" class="headerlink" title="栈是先进后出的线性表"></a>栈是先进后出的线性表</h1><p>s.top():获取栈底元素<br>s.empty():判断栈是否为空<br>s.push():往栈中添加一个元素<br>s.pop():栈顶元素的弹出<br>s.size()：获取栈的长度</p>
<hr>
<h1 id="构建一个栈（基础）"><a href="#构建一个栈（基础）" class="headerlink" title="构建一个栈（基础）"></a>构建一个栈（基础）</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment">#定义初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">#初始化一个空列表</span></span><br><span class="line">        self.__<span class="built_in">list</span>=[]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 入栈和出栈的函数体现了先进后出的理念</span></span><br><span class="line">    <span class="comment"># 入栈：将一个元素加入栈顶</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,item</span>):</span><br><span class="line">        self.__<span class="built_in">list</span>.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#出栈：将一个元素从栈顶删除</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__<span class="built_in">list</span>.pop()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#返回栈顶元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__<span class="built_in">list</span>[<span class="built_in">len</span>(self.__<span class="built_in">list</span>)-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#判断栈是否为空</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__<span class="built_in">list</span> == []</span><br><span class="line"></span><br><span class="line">    <span class="comment">#计算栈的大小</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.__<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    stack=Stack()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;是否空栈吗&#x27;</span>,stack.is_empty())</span><br><span class="line">    <span class="comment">#压栈</span></span><br><span class="line">    stack.push(<span class="number">1</span>)</span><br><span class="line">    stack.push(<span class="number">2</span>)</span><br><span class="line">    stack.push(<span class="number">3</span>)</span><br><span class="line">    stack.push(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;是否空栈吗&#x27;</span>, stack.is_empty())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;栈的长度：&#x27;</span>,stack.size())</span><br><span class="line">    <span class="comment">#弹出</span></span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">    <span class="comment"># 打印结果</span></span><br><span class="line">    是否空栈吗 <span class="literal">True</span></span><br><span class="line">是否空栈吗 <span class="literal">False</span></span><br><span class="line">栈的长度： <span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="队列是先进先出的线性表"><a href="#队列是先进先出的线性表" class="headerlink" title="队列是先进先出的线性表"></a>队列是先进先出的线性表</h1><p>q.front():获取队列的队头元素<br>q.push():在队尾添加一个新的元素进队列中<br>q.pop()：把我们的队头元素进行弹出<br>q.empty()：判断我们的队列是否为空<br>q.size():去求队列中的元素的个数</p>
<h1 id="python标准库中包含四种队列："><a href="#python标准库中包含四种队列：" class="headerlink" title="python标准库中包含四种队列："></a>python标准库中包含四种队列：</h1><ol>
<li>queue.Queue</li>
<li>asyncio.Queue </li>
<li>multiprocessing.Queue</li>
<li>collections.deque</li>
</ol>
<p>下面的这这张图很好的展示了这样的一个过程，它们的方式确实不太一样，不要弄混淆了<br><img src="https://runnerxr.github.io//post-images/1653788994859.png"></p>
<h1 id="构建一个单端队列（基础必须掌握-顺序存储）"><a href="#构建一个单端队列（基础必须掌握-顺序存储）" class="headerlink" title="构建一个单端队列（基础必须掌握-顺序存储）"></a>构建一个单端队列（基础必须掌握-顺序存储）</h1><h2 id="第一种创建方式：用列表创建"><a href="#第一种创建方式：用列表创建" class="headerlink" title="第一种创建方式：用列表创建"></a>第一种创建方式：用列表创建</h2><p>这个知识点是自己必须要掌握的点：将<strong>列表的末尾</strong>当作<strong>队列的头部</strong>，<strong>队列的尾部</strong>是列表<strong>下标为0</strong>的位置，主要实现以下几个函数：<strong>进队</strong>、<strong>出队</strong>、<strong>判断是否为空</strong>、<strong>计算队列的长度</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue=[]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 进队和出队的函数体现了队列的先进先出的特点</span></span><br><span class="line">    <span class="comment"># 进队：将元素添加到队尾</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self,item</span>):</span><br><span class="line">        self.queue.insert(<span class="number">0</span>,item)  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 出队：将元素从队头删除</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue.pop() </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断队列是否为空</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.queue==[]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算队列的大小</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    queue=Queue()</span><br><span class="line">    queue.enqueue(<span class="number">10</span>)</span><br><span class="line">    queue.enqueue(<span class="number">20</span>)</span><br><span class="line">    queue.enqueue(<span class="number">30</span>)</span><br><span class="line">    <span class="comment">#判断队列是否空</span></span><br><span class="line">    <span class="built_in">print</span>(queue.is_empty())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;队列大小&#x27;</span>,queue.size())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-----出队---------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(queue.dequeue())</span><br><span class="line">    <span class="built_in">print</span>(queue.dequeue())</span><br><span class="line">    <span class="built_in">print</span>(queue.dequeue())</span><br><span class="line"><span class="comment"># 打印结果如下：</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line">队列大小 <span class="number">3</span></span><br><span class="line">-----出队---------</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h2 id="第二种创建方式：python中的模块的方式"><a href="#第二种创建方式：python中的模块的方式" class="headerlink" title="第二种创建方式：python中的模块的方式"></a>第二种创建方式：python中的模块的方式</h2><p>略</p>
<h1 id="构建一个双端队列"><a href="#构建一个双端队列" class="headerlink" title="构建一个双端队列"></a>构建一个双端队列</h1><p>这里既然讲到了双端队列的问题，就做一点相应的知识整理：<br>deque是双端队列（double-ended queue）的缩写，由于两端都能编辑(<strong>有两个头部和尾部</strong>，可以在<strong>双端</strong>进行数据的<strong>插入</strong>和<strong>删除</strong>)，deque既可以用来实现栈（stack）也可以用来实现队列（queue），栈与队列的完美结合。<br>deque支持丰富的操作方法，主要方法如图：<img src="https://runnerxr.github.io//post-images/1646804844746.png"><br>相比于list实现的队列，deque实现拥有更低的时间和空间复杂度。<br>list实现在出队（pop）和插入（insert）时的空间复杂度大约为O(n)，<br>deque在出队（pop）和入队（append）时的时间复杂度是O(1)。<br>细部剩余知识详见：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lincappu/p/12890765.html">https://www.cnblogs.com/lincappu/p/12890765.html</a><br><a target="_blank" rel="noopener" href="https://www.jb51.net/article/183382.htm">https://www.jb51.net/article/183382.htm</a>  </p>
<h2 id="第一种创建方式：用python内置的双端队列模块"><a href="#第一种创建方式：用python内置的双端队列模块" class="headerlink" title="第一种创建方式：用python内置的双端队列模块"></a>第一种创建方式：用python内置的双端队列模块</h2><p><strong>创建双向对队列：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">d = collections.deque()</span><br></pre></td></tr></table></figure>
<p><strong>append(往右边添加一个元素)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">d = collections.deque()</span><br><span class="line">d.append(<span class="number">1</span>)</span><br><span class="line">d.append(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line">deque([<span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p><strong>appendleft（往左边添加一个元素）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">d = collections.deque()</span><br><span class="line">d.append(<span class="number">1</span>)</span><br><span class="line">d.appendleft(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line">deque([<span class="number">2</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p><strong>clear(清空队列)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">d=collections.deque()</span><br><span class="line">d.append(<span class="number">1</span>)</span><br><span class="line">d.clear()</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line">deque([])</span><br></pre></td></tr></table></figure>
<p><strong>copy(浅拷贝)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">d=collections.deque()</span><br><span class="line">d.append(<span class="number">1</span>)</span><br><span class="line">new_d=d.copy()</span><br><span class="line"><span class="built_in">print</span>(new_d)</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line">deque([<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p><strong>count(返回指定元素的出现次数)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">d=collections.deque()</span><br><span class="line">d.append(<span class="number">1</span>)</span><br><span class="line">d.append(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(d.count(<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="第二种创建方式：使用列表来创建"><a href="#第二种创建方式：使用列表来创建" class="headerlink" title="第二种创建方式：使用列表来创建"></a>第二种创建方式：使用列表来创建</h2><p>将<strong>列表的末尾</strong>作为双端队列的<strong>前端</strong>，列表中<strong>下标索引为0</strong>的位置作为双端队列的<strong>后端</strong>（和列表的模拟十分相似）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用列表来实现一个双端队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span>:</span><br><span class="line">    <span class="comment"># 构造方法创建一个空列表</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.deque=[]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 向双端队列的两端添加元素</span></span><br><span class="line">    <span class="comment"># 通过append()向列表的末尾添加（即向双端队列的前端添加）</span></span><br><span class="line">    <span class="comment"># 通过insert()向列表的索引为0的位置添加（即向双端队列的后端添加）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addFront</span>(<span class="params">self,item</span>):</span><br><span class="line">        self.deque.append(item)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addRear</span>(<span class="params">self,item</span>):</span><br><span class="line">        self.deque.insert(<span class="number">0</span>,item)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 通过pop()移除列表的末尾元素（即删除前端元素）</span></span><br><span class="line">    <span class="comment"># 通过pop(0)移除列表的索引为0的元素（即删除后端元素）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteFront</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.deque.pop()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteRear</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.deque.pop(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回双端队列的前端元素</span></span><br><span class="line">    <span class="comment"># 返回双端队列的后端元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">displayFront</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.deque[<span class="built_in">len</span>(self.deque)-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">displayRear</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.deque[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断双端队列是否为空</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.deque==[]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回双端队列的数目</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.deque)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试如下：</span></span><br><span class="line"><span class="comment"># 创建一个空的双端队列，即创建一个对象，对象名称=类名称()</span></span><br><span class="line">d=Deque()</span><br><span class="line"><span class="built_in">print</span>(d.is_empty()) <span class="comment"># 判断双端队列是否为空</span></span><br><span class="line"><span class="built_in">print</span>(d.size())  <span class="comment"># 统计双端队列的长度</span></span><br><span class="line">d.addFront(<span class="number">123</span>)  <span class="comment"># 向双端队列的前端添加元素</span></span><br><span class="line">d.addFront(<span class="number">456</span>)</span><br><span class="line">d.addRear(<span class="string">&#x27;xr&#x27;</span>)  <span class="comment"># 向双端队列的后端添加元素</span></span><br><span class="line">d.addRear(<span class="string">&#x27;1996-07-26&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(d.size())</span><br><span class="line"><span class="built_in">print</span>(d.displayFront())</span><br><span class="line"><span class="built_in">print</span>(d.displayRear())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-------&#x27;</span>)</span><br><span class="line">d.deleteFront()  <span class="comment"># 删除双端队列的前端元素</span></span><br><span class="line"><span class="built_in">print</span>(d.size())</span><br><span class="line"><span class="built_in">print</span>(d.displayFront())</span><br><span class="line">d.deleteRear()  <span class="comment"># 删除双端队列的后端元素</span></span><br><span class="line"><span class="built_in">print</span>(d.size())</span><br><span class="line"><span class="built_in">print</span>(d.displayRear())</span><br><span class="line"><span class="built_in">print</span>(d.is_empty())</span><br><span class="line"><span class="comment"># 打印结果如下：</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">456</span>       </span><br><span class="line"><span class="number">1996</span>-07-<span class="number">26</span></span><br><span class="line">-------   </span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">123</span>       </span><br><span class="line"><span class="number">2</span></span><br><span class="line">xr</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>以下为主要的几道题目：</p>
<ol>
<li>leetcoad155-最小栈（基础题）</li>
<li>leetcoad232-用两个栈实现队列（基础题）</li>
<li>leetcoad225-用队列实现栈（基础题）</li>
<li>leetcoad42-接雨水</li>
<li></li>
</ol>
<h1 id="leetcoad155-最小栈（easy-值得好好回顾）"><a href="#leetcoad155-最小栈（easy-值得好好回顾）" class="headerlink" title="leetcoad155-最小栈（easy-值得好好回顾）"></a>leetcoad155-最小栈（easy-值得好好回顾）</h1><ol>
<li>需要在常数时间内找到最小的元素，不能够使用遍历，遍历是O(n)级别的，通过辅助栈进行解决（空间换时间）:这里的理解非常到位，值得自己去整理与反思</li>
<li>定义好两个栈<ol>
<li>一个栈叫Stack,负责栈的正常操作</li>
<li>一个栈是min_stack，负责获取 stack 中的最小值(思路的重要性：遍历stack中的所有元素，把升序的数字都删除掉，留下一个从栈底到栈顶降序的栈)</li>
</ol>
</li>
<li>定义一个push函数:（针对普通栈和辅助栈都要执行：普通栈直接加入,最小栈看是不是比原来的元素更下再选择加入）</li>
<li>定义一个pop函数：（针对普通栈和辅助栈都要执行：普通栈直接弹出，最小栈当顶元素和普通栈相等的时候才会弹出）</li>
<li>定义一个top函数：在普通栈中操作，最后一个元素</li>
<li>定义getmim函数：在最小栈中操作，最后一个元素<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 定义好两个栈，一个栈用作正常操作，一个栈用作获取栈中的最小值</span></span><br><span class="line">        <span class="comment"># stack普通栈，负责栈的正常进出</span></span><br><span class="line">        self.stack=[]</span><br><span class="line">        <span class="comment"># min_stack：用栈顶来保存所有元素的最小值，负责获取和存储stack中的最小值</span></span><br><span class="line">        self.min_stack=[]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 入栈</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 把先添加的元素放入到stack中</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        <span class="comment"># 判断min_stack是否为空，如果为空，把新的元素添加进来</span></span><br><span class="line">        <span class="keyword">if</span> self.min_stack:</span><br><span class="line">            <span class="comment"># 获取min_stack的栈顶元素</span></span><br><span class="line">            top = self.min_stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 是否加入的元素是小于栈顶元素的</span></span><br><span class="line">            <span class="keyword">if</span> x&lt;=top:</span><br><span class="line">                self.min_stack.append(x)</span><br><span class="line">        <span class="comment"># 如果min_stack为空的话，直接把元素添加进去。</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.min_stack.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 出栈</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 记录此时出栈的元素</span></span><br><span class="line">        x = self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># stack执行出栈操作</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># stack中的元素出栈，min_stack同步进行</span></span><br><span class="line">        <span class="comment"># 获取min_stack的栈顶元素</span></span><br><span class="line">        top=self.min_stack[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment">#判断top 是否与stack中弹出的的元素相等，如果相等，需要把min_stack中的栈顶元素一并出栈</span></span><br><span class="line">        <span class="keyword">if</span> top ==x:</span><br><span class="line">            self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取栈顶元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取栈中的最小元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">min</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad232-用两个栈实现队列"><a href="#leetcoad232-用两个栈实现队列" class="headerlink" title="leetcoad232-用两个栈实现队列"></a>leetcoad232-用两个栈实现队列</h1><p>这里的关键点我认为有以下几点：（看过动画之后一切都十分的明白了）</p>
<ol>
<li>一个栈负责压入元素，一个栈负责弹出元素（返回队首元素）</li>
<li>压入元素很简单，但弹出元素就很讲究（弹出的过程中，如果不为空直接弹出元素，如果为空，一定要让进入的栈的全部元素都转移到弹出栈中再弹出元素）<ol>
<li>如果负责弹出的栈有元素，直接弹出</li>
<li>如果发现进入的栈不为空，就不停的将一个栈的元素转移到另一个栈中<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 定义两个栈</span></span><br><span class="line">        self.A,self.B=[],[]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将元素推到队列的末尾</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.A.append(x)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 移除队首元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果栈B为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.B:</span><br><span class="line">            <span class="keyword">while</span> self.A:</span><br><span class="line">                self.B.append(self.A.pop())</span><br><span class="line">        <span class="keyword">return</span> self.B.pop()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回队列开头的元素(pop和peek的区别，一个是删除，一个是返回)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.B:</span><br><span class="line">            <span class="keyword">while</span> self.A:</span><br><span class="line">                self.B.append(self.A.pop())</span><br><span class="line">        <span class="keyword">return</span> self.B[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义一个empy函数，如果为空返回true，如果不为空就返回false</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 判断是否两个栈都为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.A <span class="keyword">and</span> <span class="keyword">not</span> self.B:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 牛客网上也有相同的题</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># stack1负责进栈</span></span><br><span class="line">        <span class="comment"># stack2负责出栈</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 将元素加入stack1中，表示队列的入队操作</span></span><br><span class="line">        self.stack1.append(node)</span><br><span class="line">        <span class="comment"># print(self.stack1)</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># return xx</span></span><br><span class="line">        <span class="comment"># 将stack2中的元素进行弹出，构成队列的队头元素（先进先出）</span></span><br><span class="line">        <span class="comment"># 如果stack2空的，只要stack1有元素，stack2就不断添加stack1弹出来的元素</span></span><br><span class="line">        <span class="comment"># 入股哟stack2不是空的，直接弹出就行</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">                <span class="comment">#print(self.stack1)</span></span><br><span class="line">                <span class="comment">#print(self.stack2)</span></span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="leetcoad225-用队列实现栈"><a href="#leetcoad225-用队列实现栈" class="headerlink" title="leetcoad225-用队列实现栈"></a>leetcoad225-用队列实现栈</h1><p>请你仅使用<strong>两个队列</strong>实现一个<strong>后入先出（LIFO）的栈</strong>，并支持<strong>普通栈的全部四种操作</strong>（push、top、pop 和 empty）。<br>实现 MyStack 类：<br>    * void push(int x) 将元素 x 压入栈顶。<br>    * int pop() 移除并返回栈顶元素。<br>    * int top() 返回栈顶元素。<br>    * boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p>
<p>  注意：<br>    * 你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。<br>    * 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p>
<h1 id="leetcoad42-接雨水"><a href="#leetcoad42-接雨水" class="headerlink" title="leetcoad42-接雨水"></a>leetcoad42-接雨水</h1><p>题目描述：给定** n 个非负整数<strong>表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，</strong>下雨之后能接多少雨水**。<br>示例：<br><img src="https://runnerxr.github.io//post-images/1653317536073.png"><br>输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。<br>思路：这道题用到了单调递增栈的思想（之所以放在这里就是这个原因，题目本身并不简单，但是重在里面的思维的点）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/08/%E5%85%B3%E4%BA%8E%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A1%8D%E7%94%9F%E7%9A%84%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%B8%80(important)/" data-id="claqu8zz8001piwtk5hj96sv8" data-title="关于栈与队列基础知识及相关衍生的题目汇总一(important)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" rel="tag">python知识小记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-牛客网刷基础题值得记录的一些问题（值得就整理）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/07/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E5%9F%BA%E7%A1%80%E9%A2%98%E5%80%BC%E5%BE%97%E8%AE%B0%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%88%E5%80%BC%E5%BE%97%E5%B0%B1%E6%95%B4%E7%90%86%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2022-03-07T08:34:49.000Z" itemprop="datePublished">2022-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/07/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E5%9F%BA%E7%A1%80%E9%A2%98%E5%80%BC%E5%BE%97%E8%AE%B0%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%88%E5%80%BC%E5%BE%97%E5%B0%B1%E6%95%B4%E7%90%86%EF%BC%89/">牛客网刷基础题值得记录的一些问题（值得就整理）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>既然记下来就是一些十分基础的题目，肯定是要百分百的掌握的。</p>
<h1 id="牛客网-找出所有三位数中质数的个数"><a href="#牛客网-找出所有三位数中质数的个数" class="headerlink" title="牛客网-找出所有三位数中质数的个数"></a>牛客网-找出所有三位数中质数的个数</h1><p>方法一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>,<span class="number">1000</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,i):</span><br><span class="line">        <span class="keyword">if</span> (i%j == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a.append(i)   <span class="comment">#在数组a原有的基础上加上元素i</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a))</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>,<span class="number">1000</span>):<span class="comment">#对100~999的所有的三位数进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,i): <span class="comment">#对从2~i的所有数进行遍历(排除了1和i本身的这两种情况)</span></span><br><span class="line">        <span class="keyword">if</span> (i % j==<span class="number">0</span>):</span><br><span class="line">            n = n +<span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">900</span>-n)</span><br></pre></td></tr></table></figure>

<h1 id="前n项和的问题"><a href="#前n项和的问题" class="headerlink" title="前n项和的问题"></a>前n项和的问题</h1><p>看似简单，自己因为练习的比较少，觉得很好做，真正去调试的时候发现这些简单的题目也会出错。记录的原因就是不要让自己忘了最基本的东西也是最需要掌握的。<br> 题目一：<br> 输入一个整数n,计算 1+1&#x2F;（1-3）+1&#x2F;（1-3+5）+…+1&#x2F;(1-3+5-…((-1)^(n-1))*(2n-1))<br> 输出描述：输出一个浮点数，保留3位小数<br> 代码如下：<br> n &#x3D; int(input())<br>ai &#x3D; 0<br>total &#x3D; 0<br>#对n项数列的每一项进行遍历<br>#对其中一项的分母的各个子项进行遍历，这里j的范围很重要</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):                   </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,i+<span class="number">1</span>):                 </span><br><span class="line">        ai += (-<span class="number">1</span>)**(j-<span class="number">1</span>)*(<span class="number">2</span>*j-<span class="number">1</span>) <span class="comment">#对每一项值的分母进行记录</span></span><br><span class="line">    total += <span class="number">1</span>/ai <span class="comment">#前i项数列的和</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:.3f&#125;&quot;</span>.<span class="built_in">format</span>(total))</span><br></pre></td></tr></table></figure>
<p>题目二：<br>计算 1+（1+2）+（1+2+3）+…+(1+2+3+…+n)<br>输出描述：输出一个整数<br>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">ai = <span class="number">0</span></span><br><span class="line">aj = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):<span class="comment">#对n项数列的每一项进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,i+<span class="number">1</span>):<span class="comment">#对其中一项的分母的各个子项进行遍历</span></span><br><span class="line">        aj =aj+j</span><br><span class="line">    ai += aj</span><br><span class="line"><span class="built_in">sum</span> +=ai       </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>

<h1 id="一行输入两个整数，输出两个整数最大公约数和最小公倍数的和"><a href="#一行输入两个整数，输出两个整数最大公约数和最小公倍数的和" class="headerlink" title="一行输入两个整数，输出两个整数最大公约数和最小公倍数的和"></a>一行输入两个整数，输出两个整数最大公约数和最小公倍数的和</h1><p>主要是掌握最小公倍数的求法，最小公倍数与最大公约数是相关联的<br>如果能够求出最大公约数，则最小的公倍数&#x3D;a*b&#x2F;&#x2F;最大公约数<br><strong>方法一：辗转相除法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,(<span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>))) </span><br><span class="line">s=n*m</span><br><span class="line"><span class="keyword">while</span> n%m!=<span class="number">0</span>:</span><br><span class="line">    n,m=m,(n%m)  </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># print(m,&#x27;is the maximum common divisor&#x27;)</span></span><br><span class="line">    <span class="comment"># print(s//m,&#x27;is the least common multiple&#x27;) </span></span><br><span class="line">    <span class="built_in">print</span>(m+s//m)</span><br></pre></td></tr></table></figure>
<p><strong>更相减损法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,(<span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>))) </span><br><span class="line">s=n*m  </span><br><span class="line"><span class="keyword">while</span> n!=m:</span><br><span class="line">    <span class="keyword">if</span> n&gt;m:</span><br><span class="line">        <span class="comment">#n-=m  #以后n的值为现在n的值减去m,也即n = n -m</span></span><br><span class="line">        n = n - m</span><br><span class="line">    <span class="keyword">elif</span> n&lt;m:</span><br><span class="line">        <span class="comment">#m-=n</span></span><br><span class="line">        m = m - n</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(m+s//m)</span><br></pre></td></tr></table></figure>

<p>两者的区别：<br>（1）都是求最大公因数的方法，计算上辗转相除法以除法为主，更相减损术以减法为主，计算次数上辗转相除法计算次数相对较少，特别当两个数字大小区别较大时计算次数的区别较明显。更相减损术的时间复杂度约为O(N），辗转相除法的时间复杂度约为O(logN)。<br>（2）从结果体现形式来看，辗转相除法体现结果是以相除余数为0则得到，而更相减损术则以减数与差相等而得到。</p>
<h1 id="BC133-回型矩阵"><a href="#BC133-回型矩阵" class="headerlink" title="BC133-回型矩阵"></a>BC133-回型矩阵</h1><p>刚看到这题直到意思，但是也是不知道该如何处理，还得是去看题解才知道的，这里有两份题解，也是值得自己看一下的。首先有一个总起的思路：回型矩阵的特点：顺时针回型矩阵，按照一个回型为一层的情况来看，推导的前三条矩阵边上的**”结束值”-“起始值”&#x3D;”矩阵边长”-1**，第四条矩阵边的”结束值”为该层的起始值</p>
<ol>
<li>根据设定的矩阵边长，生成一个二维数组</li>
<li>按照矩阵边长生成该层的数据池<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这种方式不太好理解，放弃</span></span><br><span class="line"><span class="keyword">while</span> size &gt;<span class="number">0</span>:</span><br><span class="line">    create pool()</span><br><span class="line">    layer +=<span class="number">1</span></span><br><span class="line">    size -=<span class="number">2</span></span><br></pre></td></tr></table></figure>
最终的代码如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw_matrix</span>(<span class="params">begin,size,layer,arry,controlle_num</span>):</span><br><span class="line">    <span class="comment"># 以顺时针方向建立递增矩阵，按照层级</span></span><br><span class="line">    <span class="comment"># 根据递增1的特点，建立当前层的上下左右，四个list,形成资源池</span></span><br><span class="line">    <span class="comment"># 每个方向列表的长度都等于size的长度</span></span><br><span class="line">    top = <span class="built_in">range</span>(begin,begin +size)</span><br><span class="line">    right = <span class="built_in">range</span>(begin+size-<span class="number">1</span>,begin+size*<span class="number">2</span>-<span class="number">1</span>)</span><br><span class="line">    bottom = <span class="built_in">range</span>(begin+size*<span class="number">2</span>-<span class="number">2</span>,begin+size*<span class="number">3</span>-<span class="number">2</span>)</span><br><span class="line">    left = <span class="built_in">range</span>(begin+size*<span class="number">3</span>-<span class="number">3</span>,begin+size*<span class="number">4</span>-<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 顺时针的左list最后一个值改为起始值</span></span><br><span class="line">    left[size-<span class="number">1</span>]=begin</span><br><span class="line"></span><br><span class="line">    <span class="comment"># size相当于矩阵的边长，i既可以表示长，也可以表示宽</span></span><br><span class="line">    <span class="comment"># 通过i步进来从本层的资源池里面取出各个值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        arry[layer][layer+i] = top[i]</span><br><span class="line">        arry[layer+i][controlle_num-layer-<span class="number">1</span>]=right[i]</span><br><span class="line">        arry[controlle_num-layer-<span class="number">1</span>][controlle_num-layer-i-<span class="number">1</span>] = bottom[i]</span><br><span class="line">        arry[controlle_num-<span class="number">1</span>-layer-i][layer] = left[i]</span><br><span class="line">    <span class="keyword">return</span> arry</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Matirx</span>(<span class="params">size,begin=<span class="number">1</span>,layer=<span class="number">0</span></span>):</span><br><span class="line">    controlle_num = size</span><br><span class="line">    arry = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        arry.append(<span class="built_in">range</span>(size))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> size &gt;<span class="number">0</span>:</span><br><span class="line">        arry = draw_matrix(begin,size,layer,arry,controlle_num)</span><br><span class="line">        begin = begin+(<span class="number">4</span>*(size-<span class="number">1</span>))</span><br><span class="line">        size = size -<span class="number">2</span></span><br><span class="line">        layer = layer +<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> arry</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dat = Matrix(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(dat[i])</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 换第二种方式</span></span><br><span class="line">n= <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">s = [[-<span class="number">1</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">cnt =<span class="number">0</span></span><br><span class="line">directions=[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,-<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>],[-<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line"><span class="comment"># 0 1 = right</span></span><br><span class="line"><span class="comment"># 1 0 = down</span></span><br><span class="line"><span class="comment"># 0 -1 = left</span></span><br><span class="line"><span class="comment"># -1 0 = up</span></span><br><span class="line">x,y = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">state=<span class="number">0</span></span><br><span class="line">trace = []</span><br><span class="line"><span class="comment"># 总共有n**2个数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n**<span class="number">2</span>):</span><br><span class="line">    cnt+=<span class="number">1</span></span><br><span class="line">    s[y][x]=cnt</span><br><span class="line">    <span class="comment"># 记录已经经过的路径,这里的想法很好，如果不记录的话就永远时外层的在变化</span></span><br><span class="line">    trace.append([y,x])</span><br><span class="line">    y+=directions[state%<span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">    x+=directions[state%<span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> ([y,x] <span class="keyword">in</span> trace) <span class="keyword">or</span> y&gt;=n <span class="keyword">or</span> y&lt;<span class="number">0</span> <span class="keyword">or</span> x&gt;=n <span class="keyword">or</span> x&lt;<span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 已经经过或者已经越界的话，回退坐标</span></span><br><span class="line">        y-=directions[state%<span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">        x-=directions[state%<span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 更新状态</span></span><br><span class="line">        state +=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 更新坐标</span></span><br><span class="line">        y+=directions[state%<span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">        x+=directions[state%<span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line"><span class="comment">#print(s)</span></span><br><span class="line"><span class="comment"># 按题目条件打印有两种方式</span></span><br><span class="line"><span class="comment"># 按照两次遍历元素的方式</span></span><br><span class="line"><span class="comment"># 按照下标索引的方式（这种更好理解）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">for i in s:</span></span><br><span class="line"><span class="string">    for j in i:</span></span><br><span class="line"><span class="string">        print(j,end=&#x27; &#x27;)</span></span><br><span class="line"><span class="string">    print()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="built_in">print</span>(s[i][j],end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="comment"># 每次内循环结束后进行一次换行</span></span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>总结，要以这道题为原型来反思矩阵的计算、统计、输入与输出的问题。</p>
<h1 id="BC145笨小猴（很重要）"><a href="#BC145笨小猴（很重要）" class="headerlink" title="BC145笨小猴（很重要）"></a>BC145笨小猴（很重要）</h1><p>做题链接：<br><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/17865bc2a75c4944a872ef709958c56e?tpId=290&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=/exam/oj?tab=%25E8%25AF%25AD%25E6%25B3%2595%25E7%25AF%2587&topicId=290">https://www.nowcoder.com/practice/17865bc2a75c4944a872ef709958c56e?tpId=290&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E8%25AF%25AD%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D290</a><br>使用python判断质数的简单方法：<a target="_blank" rel="noopener" href="https://www.jb51.net/article/83616.htm">https://www.jb51.net/article/83616.htm</a><br>题目描述：找出一个输入的单词中出现频率最大的那个字母出现的次数与频率最小的那个字母出现的次数的差值，并判断该差值是否是一个质数，根据是否是质数，输出不同的结果。<br>解题思路：</p>
<ol>
<li>用数组创建一个哈希表，下标0~25对应的是26个英文单词</li>
<li>统计字母出现的频率</li>
<li>遍历数组，寻找单词中频率最高和最低的字母出现的次数</li>
<li>判断一个数是否为质数（需要写一个对应的判断质数的函数）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写一个判断是否为质数的函数</span></span><br><span class="line"><span class="comment">#定义一个判断质数的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zhi</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,n):</span><br><span class="line">        <span class="keyword">if</span> n%j==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">a= <span class="built_in">input</span>()</span><br><span class="line">lt =[]</span><br><span class="line"><span class="comment">#在所给的单词中去遍历</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    <span class="comment">#用一个变量去储存每一个单词</span></span><br><span class="line">    b =a[i]</span><br><span class="line">    <span class="comment">#用count函数去记录出现的次数</span></span><br><span class="line">    c=a.count(b)</span><br><span class="line">    <span class="comment">#把每次遍历的元素出现的次数都累加到列表中</span></span><br><span class="line">    lt.append(c)</span><br><span class="line"><span class="comment">#对记录的次数进行排序，然后找到maxn和minn</span></span><br><span class="line">lt.sort()</span><br><span class="line">maxn=lt[-<span class="number">1</span>]</span><br><span class="line">minn=lt[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> zhi(maxn-minn):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Lucky Word&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(maxn-minn)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;No Answer&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
调用相应的模块来解题：这种方法也值得自己去掌握清楚<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入python内建模块的collections模块中的Counter类</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="comment">#这里是以类似字典的方式存储起来的</span></span><br><span class="line"><span class="comment">#Counter(&#123;a:x ,b:y&#125; , c:z&#125;)</span></span><br><span class="line">c = Counter(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment">#用到most_common()函数,这里返回的是是一个列表，其中列表的每一个元素都是一个元组</span></span><br><span class="line"><span class="comment">#所以才会用c.most_common[0][1]来找到出现最多频率字母的次数</span></span><br><span class="line"><span class="comment">#most_common()是collections模块中Counter类的函数，使用的时候需要先导入collections模块</span></span><br><span class="line"><span class="comment">#返回的是元组列表，不是字典</span></span><br><span class="line">maxn = c.most_common()[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">minn = c.most_common()[-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 检查质数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isPrime</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>]:</span><br><span class="line">    <span class="comment">#if n==0 or n==1:</span></span><br><span class="line">    <span class="comment">#if n &lt;=1:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment">#运用到了质数的定义法：如果在2~√n中都不能被整除，那么在√n~n中也一定不能被整除</span></span><br><span class="line">    <span class="comment">#并且由于开方之后是浮点数，需要向上取整，这里进行了+1后int取整，或者直接round(n**0.5)代替int(n**0.5)+1)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n%i==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isPrime(maxn-minn):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Lucky Word&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(maxn-minn)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;No Answer&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="BM44-有效括号"><a href="#BM44-有效括号" class="headerlink" title="BM44-有效括号"></a>BM44-有效括号</h1><p>结合leetcoad上的一些思路：<br>自己第一遍做的时候，只能通过一部分的案例，题目要求最好是用栈来解决，虽然自己也用了但是也只是解决了一部分问题，以下是自己整理题解的时候发现的，希望自己能够好好掌握并且触类旁通。<br>思路如下：括号的匹配规则符合先进后出的规则，最外层的括号最早出现的左括号，也对应最晚出现的右括号（<strong>符合先进后出的规则，可以使用先进后出的栈</strong>），遇到左括号就将相应匹配的右括号加入栈中，后续如果是合法的，右括号来的顺序就是栈中弹出的顺序。</p>
<ol>
<li>创建辅助栈，遍历字符串</li>
<li>每次遇到小括号的左，中括号的左，大括号的左，就将其对应的右括号加入栈中，期待在后续遇到。</li>
<li>如果没有遇到左括号但是栈为空，说明直接遇到了右括号，不合法</li>
<li>其他情况下，如果遇到右括号，刚好会与栈顶元素相同，弹出栈顶元素继续遍历</li>
<li>只要括号是匹配的，栈中元素最后是为空的，因此检查栈是否为空即可最后判读是否合法</li>
</ol>
<p>下面的这两张图也可以用来辅助理解<br><img src="https://runnerxr.github.io//post-images/1651476583992.png"><br><img src="https://runnerxr.github.io//post-images/1651476591581.png"><br>注意事项：<br><img src="https://runnerxr.github.io//post-images/1651508460475.png"></p>
        
          <p class="article-more-link">
            <a href="/2022/03/07/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E5%9F%BA%E7%A1%80%E9%A2%98%E5%80%BC%E5%BE%97%E8%AE%B0%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%88%E5%80%BC%E5%BE%97%E5%B0%B1%E6%95%B4%E7%90%86%EF%BC%89/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/07/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E5%9F%BA%E7%A1%80%E9%A2%98%E5%80%BC%E5%BE%97%E8%AE%B0%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%88%E5%80%BC%E5%BE%97%E5%B0%B1%E6%95%B4%E7%90%86%EF%BC%89/" data-id="claqu8zzz002xiwtkcxske1qa" data-title="牛客网刷基础题值得记录的一些问题（值得就整理）" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" rel="tag">python知识小记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-链表的基础以及相关衍生的题目" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/06/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A1%8D%E7%94%9F%E7%9A%84%E9%A2%98%E7%9B%AE/" class="article-date">
  <time class="dt-published" datetime="2022-03-06T14:53:57.000Z" itemprop="datePublished">2022-03-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/06/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A1%8D%E7%94%9F%E7%9A%84%E9%A2%98%E7%9B%AE/">链表的基础以及相关衍生的题目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>单链表(线性表的链式存储)<br>定义：非连续、非顺序的存储结构<br><strong>数据域+指针域</strong><br>数据域：存储相应的数据<br>指针域：存储下一个节点的地址<br>一些特性：</p>
<ol>
<li>适用于数据数量不能预知的情况</li>
<li>逻辑相邻的两元素的存储空间可以不连续</li>
<li>链表一般有数据元素和指针域两部分组成</li>
<li>存储空间需要动态分配</li>
</ol>
<p>分类:</p>
<ol>
<li>单向链表</li>
<li>双向链表</li>
<li>循环链表</li>
</ol>
<p>一些类型:</p>
<ol>
<li>链表的搜索:查找链表中第一个key&#x3D; k的元素,返回该元素的指针<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LIST-SEARCH(L,K)</span><br><span class="line">x = L.head</span><br><span class="line">while x!=None and x.key !=k</span><br><span class="line">    x = x.next</span><br><span class="line">return x</span><br></pre></td></tr></table></figure></li>
<li>链表的插入:给定一个已设置key的元素x,将其接入链表的前端<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LIST-INSERT(L,X)</span><br><span class="line">x.next = L.head</span><br><span class="line">if L.head !=None</span><br><span class="line">    L.head.prev = x</span><br><span class="line">L.head = x</span><br><span class="line">x.prev = None</span><br></pre></td></tr></table></figure></li>
<li>链表删除:将一个元素从链表中删除<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LIST-DELETE(L,X)</span><br><span class="line">if x.prev !=None</span><br><span class="line">    x.pre.next = x.next</span><br><span class="line">else L.hea = x.next</span><br><span class="line">if x.next !=None</span><br><span class="line">    x.next.prev = x.prev</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>关于头节点与头指针</strong></p>
<ol>
<li>第一个数据节点的位置被存放在头结点的指针域中，链表的第一个位置上的操作和表的其他位置上操作相同，不用特殊处理</li>
<li>无论链表是否为空，头指针都指向头节点的非空指针（空表中头结点的指针域为空），空表和非空表的处理得到统一。</li>
</ol>
<p><strong>关于链表的解题方法：</strong><br>先画图（在纸上把过程先画出来），再分析，最后写代码<br>一般创建单链表，先设置一个虚拟头结点，这样每一个结点都有一个前驱结点，完美解决需要加各种判空逻辑的烦恼。</p>
<h1 id="单向链表的实现"><a href="#单向链表的实现" class="headerlink" title="单向链表的实现"></a>单向链表的实现</h1><p>这种纯构造的，只能是对概念十分清楚之后才会做的，而且自己要能够十分熟练的构造出来。<br>以下的一些图片可以帮助自己去辅助理解相应的一些构造过程<br><img src="https://runnerxr.github.io/post-images/1653832257085.png"><br><img src="https://runnerxr.github.io/post-images/1653832272113.png"><br><img src="https://runnerxr.github.io/post-images/1653832286975.png"><br><img src="https://runnerxr.github.io/post-images/1653832301656.png"><br><img src="https://runnerxr.github.io/post-images/1653832346012.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 总体思路：需要定义两个类，一个是结点类，一个是链表类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先定义一个结点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 定义结点类的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,data</span>):</span><br><span class="line">        <span class="comment"># self.item 存放自定义的数据 </span></span><br><span class="line">        <span class="comment"># sele.next 存放下一个结点对象的地址，一开始指向为None</span></span><br><span class="line">        self.data=data</span><br><span class="line">        self.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义单向链表类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 定义链表类的方法,并初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,node=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># 一个私有的head属性，指向None</span></span><br><span class="line">        self.__head=<span class="literal">None</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 以下为对象的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断链表是否为空</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isempty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 判断链表是否指向None,如果是None就是空链表</span></span><br><span class="line">        <span class="comment"># if self.__head==None:</span></span><br><span class="line">        <span class="comment">#     return True</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     return False</span></span><br><span class="line">        <span class="comment"># 直接返回表达式的结果，把判断的结果当作函数的返回值</span></span><br><span class="line">        <span class="keyword">return</span> self.__head==<span class="literal">None</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">     <span class="comment"># 计算链表的长度</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 定义一个cur指针，让它一开始指向头结点</span></span><br><span class="line">        cur=self.__head</span><br><span class="line">        <span class="comment"># 让头结点进行移动，直到指向None</span></span><br><span class="line">        <span class="keyword">while</span> cur !=<span class="literal">None</span>:</span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 把游标往后移动一个位置</span></span><br><span class="line">            cur=cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 最后返回的就是链表的长度</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历链表的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur!=<span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 打印当前的结点</span></span><br><span class="line">            <span class="built_in">print</span>(cur.item,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="comment"># 让指向继续向后移动</span></span><br><span class="line">            cur=cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在链表头部添加结点（头插法）</span></span><br><span class="line">    <span class="comment"># 这里注意思考的过程，还要注意一个顺序的问题，为了保证原有链表的所有节点不丢掉</span></span><br><span class="line">    <span class="comment"># 先操作新节点的next域，让它指向原有的首节点</span></span><br><span class="line">    <span class="comment"># 想想特殊的情况，也可以用这三行来表示，不需要进行特殊的判断</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,item</span>):</span><br><span class="line">        <span class="comment"># 将传入的值构造成结点（把item数据封装成链表所使用的）</span></span><br><span class="line">        node=ListNode(item)</span><br><span class="line">        <span class="comment"># 1. 将新的节点的链接域next指向头节点</span></span><br><span class="line">        node.<span class="built_in">next</span>=self.__head</span><br><span class="line">        <span class="comment"># 2.将链表的头节点指向新节点</span></span><br><span class="line">        self.__head=node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在链表的尾部添加节点的方法（尾插法）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self,item</span>):</span><br><span class="line">        node=ListNode(item)</span><br><span class="line">        <span class="comment"># 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> self.isempty():</span><br><span class="line">            <span class="comment"># 直接让self.__head指向node</span></span><br><span class="line">            self.__head=node</span><br><span class="line">        <span class="comment"># 链表不为空</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur=self.__head</span><br><span class="line">            <span class="comment"># 这个时候的循环判断条件发生变化</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span>!=<span class="literal">None</span>:</span><br><span class="line">                cur=cur.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 循环结束的时候cur.next指向为None</span></span><br><span class="line">            <span class="comment"># 修改最后一个节点的指向，将cur.next指向node </span></span><br><span class="line">            cur.<span class="built_in">next</span>=node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在任意的指定位置插入节点的方法</span></span><br><span class="line">    <span class="comment"># 同样的思考相应的过程</span></span><br><span class="line">    <span class="comment"># 1. 先调整新节点的next域</span></span><br><span class="line">    <span class="comment"># 2. 然后再改变原有链表之间的链接关系</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self,pos,item</span>):</span><br><span class="line">        <span class="comment"># 先找到下标所指的位置在哪</span></span><br><span class="line">        <span class="comment"># 考虑pos的特殊情况</span></span><br><span class="line">        <span class="comment"># 如果传入的pos是小于等于0的数，默认的将节点插入头部</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;<span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="comment"># 如果pos的值大于链表的长度，默认将节点添加到尾部</span></span><br><span class="line">        <span class="keyword">elif</span> pos&gt;(self.length()-<span class="number">1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="comment"># 除此之外的情况就包含在内的情况</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node=ListNode(item)</span><br><span class="line">            <span class="comment"># 让pre指针指向头节点的位置</span></span><br><span class="line">            pre=self.__head</span><br><span class="line">            <span class="comment"># 用来计数</span></span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt;(pos-<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># pre指针移动到指定位置的前一个位置（如果移动到指定位置，之后前面的就无法操作了）</span></span><br><span class="line">                <span class="comment"># 先去改变node节点的next区域</span></span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                pre=pre.<span class="built_in">next</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 当循环退出之后，pre指向pos-1的位置</span></span><br><span class="line">            <span class="comment"># 修改指向</span></span><br><span class="line">            <span class="comment"># 将前一个节点的next指向插入位置节点</span></span><br><span class="line">            node.<span class="built_in">next</span>=pre.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 让pre所指的指向我的节点</span></span><br><span class="line">            pre.<span class="built_in">next</span>=node </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除节点</span></span><br><span class="line">    <span class="comment"># 需要两个游标来解决（也可以只用一个游标，但是写法上就不是那么的好理解）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self,item</span>):</span><br><span class="line">        pre=<span class="literal">None</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="comment"># 保证之前地每一个节点都被比较过</span></span><br><span class="line">        <span class="comment"># 查看特殊地情况：对于空链表，当前地代码满足要求（While不执行）</span></span><br><span class="line">        <span class="comment"># 如果要删除地节点恰好是首节点</span></span><br><span class="line">        <span class="keyword">while</span> cur!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.data==item:</span><br><span class="line">                <span class="comment"># 先判断次节点是否是头节点</span></span><br><span class="line">                <span class="keyword">if</span> cur==self.__head:</span><br><span class="line">                    self.__head=cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 怎么删除节点</span></span><br><span class="line">                    <span class="comment"># 整个链表已经完成了一条主线了（这里地理解太关键了）</span></span><br><span class="line">                    <span class="comment"># 对于只有一个节点地可以这行代码来执行</span></span><br><span class="line">                    <span class="comment"># 对于要删除最后一个节点也可以用这行代码实现</span></span><br><span class="line">                    pre.<span class="built_in">next</span>=cur.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 删除完毕后退出循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 让两个指针往后移动，始终保证pre在cur的前面</span></span><br><span class="line">                <span class="comment"># 这两个游标的移动顺序</span></span><br><span class="line">                pre=cur</span><br><span class="line">                cur=cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 针对返回值问题，有两种</span></span><br><span class="line">        <span class="comment"># 1. 返回删除的数据</span></span><br><span class="line">        <span class="comment"># 2. 返回要删除的数据的下标（我删除的是链表中的几个元素）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查找节点是否存在</span></span><br><span class="line">    <span class="comment"># 对于特殊情况也可以表示</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,item</span>):</span><br><span class="line">        cur=self.__head</span><br><span class="line">        <span class="keyword">while</span> cur!=<span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 不断地进行比对</span></span><br><span class="line">            <span class="keyword">if</span> cur.data==item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur=cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义主函数</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 初始化一个为空的单向链表</span></span><br><span class="line">    sll=SingleLinkList()</span><br><span class="line">    <span class="built_in">print</span>(sll.isempty())</span><br><span class="line">    <span class="built_in">print</span>(sll.length())</span><br><span class="line">    sll.append(<span class="number">10</span>)</span><br><span class="line">    sll.append(<span class="number">20</span>)</span><br><span class="line">    sll.append(<span class="number">30</span>)</span><br><span class="line">    sll.append(<span class="number">40</span>)</span><br><span class="line">    sll.append(<span class="number">50</span>)</span><br><span class="line">    sll.add(<span class="number">5</span>)</span><br><span class="line">    sll.insert(<span class="number">2</span>,<span class="number">35</span>)</span><br><span class="line">    <span class="built_in">print</span>(sll.isempty())</span><br><span class="line">    <span class="built_in">print</span>(sll.length())</span><br><span class="line">    sll.travel()</span><br></pre></td></tr></table></figure>
<h1 id="双向链表的实现"><a href="#双向链表的实现" class="headerlink" title="双向链表的实现"></a>双向链表的实现</h1><p>同样要把实现方式、存储方式以及这个数据结构所支持的操作函数<br>每个节点有两个链接，一个指向前一个节点，<strong>当此节点为第一个节点时，指向空值</strong>；另一个指向一下一个节点，<strong>当此节点为最后一个节点时，指向空值</strong>。<br>针对判空，求链表长度以及遍历链表和单链表的方法是一样的，可以采用继承的方式来解决（这里的理解十分的重要，将单链表的类进行封装就可以不用重复再写了，面对对象的思想）<br>头插法：加入一行代码<br>尾插法：加入一行代码<br>在指定位置插入：由于已经有了前驱节点，就只需要一个游标了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,data</span>):</span><br><span class="line">        self.data=data</span><br><span class="line">        self.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">        self.prev=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义双向链表类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleLinkList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__inint__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__head=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断链表是否为空</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isempty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__head==<span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算链表的长度</span></span><br><span class="line">    <span class="comment"># 在求长度的过程中就把它当成单链表进行求解就行</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 定义一个cur指针，让它一开始指向头结点</span></span><br><span class="line">        cur=self.__head</span><br><span class="line">        <span class="comment"># 让头结点进行移动，直到指向None</span></span><br><span class="line">        <span class="keyword">while</span> cur !=<span class="literal">None</span>:</span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 把游标往后移动一个位置</span></span><br><span class="line">            cur=cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 最后返回的就是链表的长度</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历链表的方法</span></span><br><span class="line">    <span class="comment"># 和单链表同样</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur!=<span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 打印当前的结点</span></span><br><span class="line">            <span class="built_in">print</span>(cur.item,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="comment"># 让指向继续向后移动</span></span><br><span class="line">            cur=cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在链表头部添加结点（头插法）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,item</span>):</span><br><span class="line">        <span class="comment"># 将传入的值构造成结点（把item数据封装成链表所使用的）</span></span><br><span class="line">        node=ListNode(item)</span><br><span class="line">        <span class="comment"># 1. 将新的节点的链接域next指向头节点</span></span><br><span class="line">        node.<span class="built_in">next</span>=self.__head</span><br><span class="line">        <span class="comment"># 2.将链表的头节点指向新节点</span></span><br><span class="line">        self.__head=node</span><br><span class="line">        <span class="comment"># 3.原有节点的p区需要改变指向(通过画图来理解,这里需要重点理解)</span></span><br><span class="line">        node.<span class="built_in">next</span>.prev=node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在链表的尾部添加节点的方法（尾插法）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self,item</span>):</span><br><span class="line">        node=ListNode(item)</span><br><span class="line">        <span class="comment"># 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> self.isempty():</span><br><span class="line">            <span class="comment"># 直接让self.__head指向node</span></span><br><span class="line">            self.__head=node</span><br><span class="line">        <span class="comment"># 链表不为空</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur=self.__head</span><br><span class="line">            <span class="comment"># 这个时候的循环判断条件发生变化</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span>!=<span class="literal">None</span>:</span><br><span class="line">                cur=cur.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 循环结束的时候cur.next指向为None</span></span><br><span class="line">            <span class="comment"># 修改最后一个节点的指向，将cur.next指向node </span></span><br><span class="line">            cur.<span class="built_in">next</span>=node</span><br><span class="line">            <span class="comment"># 相比单链表，再加入一行代码(把node的前驱指向cur就OK了)</span></span><br><span class="line">            node.prev=cur</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在任意的指定位置插入节点的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self,pos,item</span>):</span><br><span class="line">        <span class="comment"># 先找到下标所指的位置在哪</span></span><br><span class="line">        <span class="comment"># 考虑pos的特殊情况</span></span><br><span class="line">        <span class="comment"># 如果传入的pos是小于等于0的数，默认的将节点插入头部</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;<span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="comment"># 如果pos的值大于链表的长度，默认将节点添加到尾部</span></span><br><span class="line">        <span class="keyword">elif</span> pos&gt;(self.length()-<span class="number">1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="comment"># 除此之外的情况就包含在内的情况</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur=self.__head</span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count&lt;pos:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                cur=cur.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 循环退出,cur指向pos的位置</span></span><br><span class="line">            node=ListNode(item)</span><br><span class="line">            node.<span class="built_in">next</span>=cur</span><br><span class="line">            node.prev=cur.prev</span><br><span class="line">            <span class="comment"># 然后把原有的两条链接打断,这里的顺序很重要</span></span><br><span class="line">            <span class="comment"># 1. 先把前面节点的next指向node</span></span><br><span class="line">            cur.prev.<span class="built_in">next</span>=node</span><br><span class="line">            <span class="comment"># 2. cur节点的前驱指向node</span></span><br><span class="line">            cur.prev=node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除节点</span></span><br><span class="line">    <span class="comment"># 核心思想要弄懂</span></span><br><span class="line">    <span class="comment"># cur.prev.next=cur.next</span></span><br><span class="line">    <span class="comment"># cur.next.prev=cur.prev</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self,item</span>):</span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="comment"># 只要cur没有到最尾就还是要去找</span></span><br><span class="line">        <span class="keyword">while</span> cur!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.data==item:</span><br><span class="line">                <span class="comment"># 先判断次节点是否是头节点</span></span><br><span class="line">                <span class="comment"># 在单链表的基础上加上cur.next.prev=None</span></span><br><span class="line">                <span class="keyword">if</span> cur==self.__head:</span><br><span class="line">                    self.__head=cur.<span class="built_in">next</span></span><br><span class="line">                    <span class="comment"># 对于只有一个节点的情况，还要再加入一个判断（这里不是特别的好想）</span></span><br><span class="line">                    <span class="comment"># 如果cur.next已经指向空，空的节点没有相应的前驱节点</span></span><br><span class="line">                    <span class="keyword">if</span> cur.<span class="built_in">next</span>:</span><br><span class="line">                        cur.<span class="built_in">next</span>.prev=<span class="literal">None</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur.prev.<span class="built_in">next</span>=cur.<span class="built_in">next</span></span><br><span class="line">                    <span class="comment"># 针对如果指向的是最后一个节点的情况，还要再加入一个判断（认真理解）</span></span><br><span class="line">                    <span class="comment"># 如果cur.next已经指向为None，空的节点没有相应的前驱节点</span></span><br><span class="line">                    <span class="keyword">if</span> cur.<span class="built_in">next</span>:</span><br><span class="line">                        cur.<span class="built_in">next</span>.prev=cur.prev</span><br><span class="line">                <span class="comment"># 删除完毕后退出循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur=cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查找节点是否存在</span></span><br><span class="line">    <span class="comment"># 也是可以当作单链表来对待</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,item</span>):</span><br><span class="line">        cur=self.__head</span><br><span class="line">        <span class="keyword">while</span> cur!=<span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 不断地进行比对</span></span><br><span class="line">            <span class="keyword">if</span> cur.data==item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur=cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>(self):</span><br><span class="line">    dll=DoubleLinkList()</span><br><span class="line">    <span class="built_in">print</span>(dll.isempty())</span><br><span class="line">    <span class="built_in">print</span>(dll.length())</span><br><span class="line">    dll.append(<span class="number">10</span>)</span><br><span class="line">    dll.append(<span class="number">20</span>)</span><br><span class="line">    dll.append(<span class="number">30</span>)</span><br><span class="line">    dll.append(<span class="number">40</span>)</span><br><span class="line">    dll.append(<span class="number">50</span>)</span><br><span class="line">    dll.add(<span class="number">5</span>)</span><br><span class="line">    dll.insert(<span class="number">2</span>,<span class="number">35</span>)</span><br><span class="line">    <span class="built_in">print</span>(dll.isempty())</span><br><span class="line">    <span class="built_in">print</span>(dll.length())</span><br><span class="line">    dll.travel()</span><br></pre></td></tr></table></figure>


<h1 id="单向循环链表的实现"><a href="#单向循环链表的实现" class="headerlink" title="单向循环链表的实现"></a>单向循环链表的实现</h1><p>略<br>以下为一些对应的题目</p>
<h1 id="leetcoad206-x2F-92-反转链表和反转链表II（easy-x2F-middle）"><a href="#leetcoad206-x2F-92-反转链表和反转链表II（easy-x2F-middle）" class="headerlink" title="leetcoad206&#x2F;92-反转链表和反转链表II（easy&#x2F;middle）"></a>leetcoad206&#x2F;92-反转链表和反转链表II（easy&#x2F;middle）</h1><p>这道题是一道很经典的题目。很适合理解一些常用的算法以及递归的知识，值得自己反复的去做，反复的去刷，理解其中的一些内涵！！！属于必做和必须深入理解的类型。<br>反转链表：<br>leetcoad链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a><br>视频链接：&lt;&gt;<br>题目要求：给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。<br>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br><strong>常规思路：采用递归的写法</strong><br><img src="https://runnerxr.github.io/post-images/1654528804497.png"><br>首先要明白递推公式的含义：对于节点1来说：<strong>只需要知道它之后的所有节点反转之后的结果就可以了</strong>，也即递推公式的含义：<strong>把拿到的链表进行反转，然后返回新的头结点</strong><br><img src="https://runnerxr.github.io/post-images/1654528985077.png"><br>结点1之后的结点，经过递归公式reverseList处理之后的结果如下图：<br><img src="https://runnerxr.github.io/post-images/1654529090594.png"><br>看了很多的题解之后才发现当初自己根本没有把每一行的代码正真的弄懂</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head</span>):</span><br><span class="line">    <span class="comment"># 调用递推公式反转当前结点之后的所有结点</span></span><br><span class="line">    <span class="comment"># 返回的结果是反转后的链表的头结点</span></span><br></pre></td></tr></table></figure>
<p>接下来要做的是反转结点1，将head指向的结点作为其下一个结点的下一个结点<code>head.next.next=head</code><br><img src="https://runnerxr.github.io/post-images/1654529392558.png"><br>最后，将head指向的结点下一个结点置为None，就完成了整个链表的反转<br><img src="https://runnerxr.github.io/post-images/1654529513119.png"></p>
<ol>
<li><p>寻找递归的终止条件</p>
<ul>
<li>head指向的节点为null（空表）</li>
<li>head指向的节点的下一个节点为null（只有一个节点）</li>
</ul>
</li>
<li><p>不断的通过递归调用，直到无法递归下去，递归的最小粒度是在最后一个节点(理解：到最后一个节点的时候，由于当前节点的next节点是空，该节点就是反转成功后的头节点，会直接的返回head)</p>
<ul>
<li>cur &#x3D; self.reverseList(head.next)</li>
<li>head.next.next &#x3D; head   #去设置当前节点的下一个节点等于xxx  也即：让当前节点的下一个节点的next指针指向当前节点</li>
<li>head.next &#x3D; None  #让当前节点的next指针指向null</li>
</ul>
</li>
<li><p>把每一次反转后的结果传递给上一层:return cur（每次返回的cur是最后一个节点，在递归函数内部改变的是当前节点的指向）<br>核心中的核心：当前链表的次节点往后都已经反转好了，只要反转头两个节点就好了。用下面的这张动图来辅助理解。递归的写法往往是抽象的，确实很难理解。十分锻炼自己的抽象思维能力。<br><img src="https://runnerxr.github.io/post-images/1652603382074.gif"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="comment">#递归的终止条件：当前为空或者下一个为空（当前为空是为了防止链表不存在的情况）</span></span><br><span class="line">        <span class="comment">#正确的说法应该是：当链表只有一个节点或者是空表的情况，啥也不用干，直接返回head</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> == <span class="literal">None</span>):</span><br><span class="line">            <span class="comment">#此处属于第一次返回，当遍历到最后一个节点的时候触发</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment">#这里的cur就是最后一个节点，也即新链表的头结点</span></span><br><span class="line">        cur = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        <span class="comment">#从这里开始，节点开始反转，节点的下一个节点的下一个节点指向它本身了。</span></span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head      </span><br><span class="line">        <span class="comment">#同时把头节点的下一个节点指向空（原先是指向顺序结构的，现在指向反转，防止循环指向）</span></span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="comment">#把下一个递归过程的结果传递给上一个递归过程</span></span><br><span class="line">        <span class="comment">#每层的递归函数都返回cur，就是最后一个节点，理解为返回的是已经反转过的那部分的头指针，而恰好头指针是确定的。</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>非递归（双指针迭代）：</strong><br><img src="https://runnerxr.github.io/post-images/1652603630612.gif"><br>这里点当时自己是<strong>理解了好久好久</strong>，甚至是在图上画了一遍又一遍的演示过程，才慢慢的理解其中的一些过程的，用迭代的写法可以弄懂里面每一步的细致过程。<img src="https://runnerxr.github.io/post-images/1652603780711.jpg"><br>在遍历列表时，将<strong>当前节点的next指针改为指向前一个节点</strong>（这一过程就是反转），由于节点没有引用其前一个节点，必须事先存储前一个节点，在更改引用之前，还<strong>需要存储后一个节点</strong>，最后返回新的头引用。<br>解题思路如下：<strong>将链表所有节点的next指针指向它的前面的节点</strong>（如果不考虑递归的细节，这就是一个大的方向）</p>
<ol>
<li>首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。</li>
<li>把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点的指针。</li>
<li>改变cur-&gt;next节点的指向，将它指向pre(反转了第一个节点，也是很重要的一步过程：每次迭代到cur，都将cur的next指向pre)</li>
<li>更新pre和cur指针（pre指针后cur指针分别后移一位），都迭代完了，pre就是最后一个节点<ul>
<li>pre &#x3D; cur</li>
<li>cur &#x3D; tmp<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        cur = head  <span class="comment">#定义一个cur指针，指向头节点head</span></span><br><span class="line">        pre = <span class="literal">None</span> <span class="comment">#定义一个pre指针，初始化为None</span></span><br><span class="line">        <span class="keyword">while</span>(cur !=<span class="literal">None</span>):   <span class="comment">#当cur为空的时候循环结束，不断的将cur指向pre的过程</span></span><br><span class="line">                temp = cur.<span class="built_in">next</span>  <span class="comment">#保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = pre <span class="comment">#反转</span></span><br><span class="line">                <span class="comment">#更新pre、cur指针</span></span><br><span class="line">                pre = cur</span><br><span class="line">                cur = temp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="反转链表II"><a href="#反转链表II" class="headerlink" title="反转链表II:"></a>反转链表II:</h1><p>将链表的<strong>部分元素</strong>进行<strong>反转</strong><br>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。<br>说明:<br>1 ≤ m ≤ n ≤ 链表长度。<br>示例:<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4<br>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL<br>仍然是辅助一些图片来加深理解：<br><img src="https://runnerxr.github.io/post-images/1654529827582.png"><br>在这里，head指向结点1，<strong>不用关注其后的所有结点如何将m&#x3D;3与n&#x3D;5之间的部分是如何反转的，只需要知道反转之后的结果就行了</strong>，也即这里的递推的公式的含义为：<strong>将拿到的链表反转，然后返回反转后的链表的头结点</strong><br><img src="https://runnerxr.github.io/post-images/1654530025019.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head, m, n</span>):</span><br><span class="line">        between = self.reverseBetween(head.<span class="built_in">next</span>,m-<span class="number">1</span>,n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>接下来将递推公式返回的结果<strong>挂在head之后</strong>，即<code> head.next=between</code><br><img src="https://runnerxr.github.io/post-images/1654530273016.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head, m, n</span>):</span><br><span class="line">        between = self.reverseBetween(head.<span class="built_in">next</span>,m-<span class="number">1</span>,n-<span class="number">1</span>)</span><br><span class="line">        head.<span class="built_in">next</span>=between</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<p>递推的部分已经完成了，现在就是需要明确递归的终止条件<br><img src="https://runnerxr.github.io/post-images/1654530644621.png"><br>原问题：     反转链表1–&gt;2–&gt;3–&gt;4–&gt;5–&gt;None  m&#x3D;3和n&#x3D;5之间的部分<br>更小的子问题：反转链表：2–&gt;3–4–5–6–&gt;None m&#x3D;2和n&#x3D;4之间的部分<br>进一步的反转链表：3–4–5–6–&gt;None m&#x3D;1和n&#x3D;3之间的部分<br>通过分析我们知道，当m&#x3D;&#x3D;1的时候，递归需要停止</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head, m, n</span>):</span><br><span class="line">        <span class="keyword">if</span> m==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">pass</span></span><br><span class="line">        between = self.reverseBetween(head.<span class="built_in">next</span>,m-<span class="number">1</span>,n-<span class="number">1</span>)</span><br><span class="line">        head.<span class="built_in">next</span>=between</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<p>接下来的重点问题就是如何利用递归的思想反转3–4–5–6–&gt;None   m&#x3D;1和n&#x3D;3 即如何反转链表的前n个结点<br>借用东哥的代码的思路，需要的参数有两个：带反转的链表的头结点  以及 反转前几个结点（n值）<br><img src="https://runnerxr.github.io/post-images/1654531300211.png"><br>因此写出反转前n个结点的函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseN</span>(<span class="params">head,n</span>):</span><br><span class="line">           <span class="comment"># 当反转的就是第一个节点，直接返回头节点就行</span></span><br><span class="line">           <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">               <span class="keyword">return</span> head</span><br><span class="line">           <span class="comment"># 以 head.next 为起点，需要反转前 n - 1 个节点</span></span><br><span class="line">           last = reverseN(head.<span class="built_in">next</span>, n-<span class="number">1</span>)</span><br><span class="line">           successor = head.<span class="built_in">next</span>.<span class="built_in">next</span> </span><br><span class="line">           <span class="comment"># 以head.next为开头的链表已经完成翻转，那么head.next.next正确指向后继节点</span></span><br><span class="line">           head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">           head.<span class="built_in">next</span> = successor</span><br><span class="line">           <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>
<p>leetcoad链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">https://leetcode-cn.com/problems/reverse-linked-list-ii/</a><br>视频链接：<a target="_blank" rel="noopener" href="https://ke.algomooc.com/detail/v_621d9b82e4b066e9608a2c07/3">https://ke.algomooc.com/detail/v_621d9b82e4b066e9608a2c07/3</a><br>参考leetcoad上的一篇题解：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/java-shuang-zhi-zhen-tou-cha-fa-by-mu-yi-cheng-zho/">https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/java-shuang-zhi-zhen-tou-cha-fa-by-mu-yi-cheng-zho/</a><br>解题思路：（此道题的解题思路要和合并两个有序链表那题一起来看，重要的是思路+代码实现）</p>
<ol>
<li>一开始设置一个虚拟节点，为了让原链表的所有节点都可以按照统一的方式进行翻转</li>
<li>让虚拟节点指向原链表的头部</li>
<li>设置一个虚拟指针，指向以虚拟节点为链表的头部位置</li>
<li>设置一个指针，指向原链表的头部位置</li>
<li>从虚拟头节点出发，pre走left -1步找到需要翻转的左区间</li>
<li>for循环：结束后，pre的右节点就是要翻转的节点，cur指向就是需要翻转的节点<br> + pre不断的向右移动，直到找到翻转的左区间为止<br> + cur不断的向右移动，找到需要翻转的第一个节点</li>
<li>开始翻转这些节点：（最要的三句代码）</li>
<li>设置临时变量，保存当前需要翻转节点的后面的节点<br> + 让temp和cur两个节点翻转：cur.next &#x3D; cur.next.next(想让2的下一个节点不是3而是4，就需要需要把cur的下一节点指向temp的下一个节点)<br> + temp.next &#x3D; pre.next（执行代码的目的：让temp的下一个节点是2而不是4<br> + pre.next &#x3D; temp(pre的下一节点是等号右侧的值)</li>
<li>最后返回虚拟头节点的下一个节点（虚拟头节点不在链表中，用完之后就可以丢弃了）<br><strong>附上相关的代码：</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#本质上采用的是双指针+头插法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head: ListNode, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="comment">#此处定义虚拟指针是为了方便处理（但凡是需要考虑左右边界的时候就需要考虑虚拟节点）</span></span><br><span class="line">        <span class="comment">#设置一个虚拟节点，指向原链表的头部</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#让虚拟节点指向原链表的头部</span></span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line"></span><br><span class="line">        <span class="comment">#初始化指针的位置</span></span><br><span class="line">        <span class="comment">#设置一个虚拟指针，指向以虚拟节点为链表的头部位置</span></span><br><span class="line">        pre = dummy</span><br><span class="line">        <span class="comment">#设置一个指针，指向原链表的头部位置</span></span><br><span class="line">        cur = head</span><br><span class="line"></span><br><span class="line">        <span class="comment">#将指针移动到相应的位置</span></span><br><span class="line">        <span class="comment">#从虚拟节点出发，pre走left-1步找到需要翻转的左区间</span></span><br><span class="line">        <span class="comment">#for循环：结束后，pre的右节点就是要翻转的节点，cur指向的就是要翻转的节点（需要结合相应的动画来理解）</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(left -<span class="number">1</span>):</span><br><span class="line">            <span class="comment">#pre不断的向右移动，直到走到翻转的左区间为止</span></span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">            <span class="comment">#cur不断的向右移动，找到了需要翻转的第一个节点</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#开始翻转这些节点（也即用头插法插入节点）</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span> (right -left):</span><br><span class="line">            <span class="comment">#设置临时变量，保存当前需要翻转节点的后面的节点</span></span><br><span class="line">            temp = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="comment">#接后面</span></span><br><span class="line">            cur.<span class="built_in">next</span>= cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="comment">#头插</span></span><br><span class="line">            temp.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">            pre.<span class="built_in">next</span> = temp</span><br><span class="line"></span><br><span class="line">        <span class="comment">#最后返回虚拟头结点的下一个节点（虚拟头结点不在链表中，用完之后就可以丢弃）</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">        <span class="comment">#时间复杂度：O(N):N是链表节点总数，最多只遍历了链表一次</span></span><br><span class="line">        <span class="comment">#空间复杂度：O(1)：只使用到了常数个变量</span></span><br></pre></td></tr></table></figure>
递归版本：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归的思路太难想了，要写的化还是迭代的思路要清晰一些</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head, m, n</span>):</span><br><span class="line">        <span class="comment"># 借助反转前n个节点的函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverseN</span>(<span class="params">head,n</span>):</span><br><span class="line">            <span class="comment"># 当反转的就是第一个节点，直接返回头节点就行</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            <span class="comment"># 以 head.next 为起点，需要反转前 n - 1 个节点</span></span><br><span class="line">            last = reverseN(head.<span class="built_in">next</span>, n-<span class="number">1</span>)</span><br><span class="line">            successor = head.<span class="built_in">next</span>.<span class="built_in">next</span> </span><br><span class="line">            <span class="comment"># 以head.next为开头的链表已经完成翻转，那么head.next.next正确指向后继节点</span></span><br><span class="line">            head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">            head.<span class="built_in">next</span> = successor</span><br><span class="line">            <span class="keyword">return</span> last</span><br><span class="line">        <span class="comment"># 如果m==1,就像相当于  </span></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> reverseN(head,n)</span><br><span class="line">        head.<span class="built_in">next</span> = self.reverseBetween(head.<span class="built_in">next</span>,m-<span class="number">1</span>,n-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad21-x2F-23-合并两-x2F-k个有序链表-easy-x2F-hard"><a href="#leetcoad21-x2F-23-合并两-x2F-k个有序链表-easy-x2F-hard" class="headerlink" title="leetcoad21&#x2F;23-合并两&#x2F;k个有序链表(easy&#x2F;hard)"></a>leetcoad21&#x2F;23-合并两&#x2F;k个有序链表(easy&#x2F;hard)</h1><p><strong>合并两个有序链表</strong><br>leetcoad链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a><br>视频链接：<a target="_blank" rel="noopener" href="https://www.algomooc.com/658.html">https://www.algomooc.com/658.html</a><br>解题思路如下：<br>    + 一开始设置一个虚拟节点，它的值为 -1，它的值可以设置为任何的数，因为我们根本不需要使用它的值（dummy）<br>    + 设置一个指针，指向虚拟节点(pre &#x3D; dummy)<br>    + 通过一个循环，不断的比较L1和L2中当前节点值的大小，直到L1或者L2遍历完毕为止（指出这个循环就是问题的关键）</p>
<pre><code>    + 如果 l1 当前节点的值小于等于了 l2 当前节点的值
        + 让 pre 指向节点的 next 指针指向这个更小值的节l1 
        + 让 l1 向后移动
    + else：

        + 让 pre 指向节点的 next 指针指向这个更小值的节l2
        + 让 l2 向后移动
    + 让pre向后移动
    + 跳出循环后，L1或l2中可能有剩余的节点没有被观察过
    + 直接把剩下的节点加入到pre的next指针位置
        + 如果 l1 中还有节点
            + 把 l1 中剩下的节点全部加入到 pre 的 next 指针位置
        + 如果 l2 中还有节点
            + 把 l2 中剩下的节点全部加入到 pre 的 next 指针位置
+ 最后返回虚拟节点的next指针
</code></pre>
<p>自己调试的版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将传入的数组转化为链表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_linked_list</span>(<span class="params">arr</span>):</span><br><span class="line">    head = ListNode(arr[<span class="number">0</span>])</span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        cur.<span class="built_in">next</span> = ListNode(arr[i])</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="comment">#传入链表头节点，以数组形式返回</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_linked_list</span>(<span class="params">head</span>):</span><br><span class="line">    cur = head</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        res.append(cur.val)</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, l1, l2</span>):</span><br><span class="line">        pre = ListNode(<span class="number">0</span>)</span><br><span class="line">        head = pre</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &gt;= l2.val:</span><br><span class="line">                pre.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">        pre.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    head1 = create_linked_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line">    head2 = create_linked_list([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">    solution = Solution()</span><br><span class="line">    sorted_lists = solution.mergeTwoLists(head1, head2)</span><br><span class="line">    <span class="built_in">print</span>(print_linked_list(sorted_lists))</span><br><span class="line"><span class="comment">#输出：[1, 1, 2, 3, 4, 4]</span></span><br></pre></td></tr></table></figure>
<p>吴师兄给的思路的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Merge</span>(<span class="params">self , L1: ListNode, L2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="comment">#设置一个虚拟节点,因为不知道构建的结果中，开头的元素到底是l1还是l2,就是为了在后面比较后加入才直到，所以设置后就可以不用管了</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#设置一个虚拟指针，指向虚拟节点。这个虚拟指针是可以移动的，目的是让指针指向链表的最后一个元素，可以是l1，也可以是l2,是按照从小到大的顺序不断的进行移动的</span></span><br><span class="line">        pre = dummy</span><br><span class="line">        <span class="comment">#通过一个循环，不断的比较L1和L2中当前节点值的大小，直到L1或者L2遍历完为止</span></span><br><span class="line">        <span class="keyword">while</span> L1 <span class="keyword">and</span> L2:</span><br><span class="line">            <span class="comment">#如果L1对应的节点值更小，就把pre指向节点的next指针指向L1</span></span><br><span class="line">            <span class="keyword">if</span>  L1.val &lt;= L2.val:</span><br><span class="line">                pre.<span class="built_in">next</span> = L1</span><br><span class="line">                <span class="comment">#然后把L1向前移动（很重要的一步）</span></span><br><span class="line">                L1= L1.<span class="built_in">next</span></span><br><span class="line">            <span class="comment">#如果L2对应的节点值更小，就把pre指向节点的next指针指向L2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.<span class="built_in">next</span> = L2</span><br><span class="line">                 <span class="comment">#然后把L2向前移动</span></span><br><span class="line">                L2 = L2.<span class="built_in">next</span></span><br><span class="line">            <span class="comment">#让pre不断的向后移动</span></span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="comment">#跳出循环后，L1和L2中可能有剩余的节点没有观察到</span></span><br><span class="line">        <span class="comment">#直接把剩下的节点加入到pre的next指针位置</span></span><br><span class="line">        <span class="keyword">if</span> L1 !=<span class="literal">None</span>:</span><br><span class="line">            pre.<span class="built_in">next</span>=L1</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> L2 !=<span class="literal">None</span>:</span><br><span class="line">            pre.<span class="built_in">next</span> = L2</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>尝试写一下递归的版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">**合并k个升序链表**</span><br><span class="line">leetcoad链接：&lt;https://leetcode-cn.com/problems/merge-k-<span class="built_in">sorted</span>-lists/&gt;</span><br><span class="line">这题是在合并两个有序链表的基础上衍生出来的（把递归的知识再融合进去）</span><br><span class="line">```python</span><br><span class="line">代码待填充.......</span><br></pre></td></tr></table></figure>

<p><strong>leetcoad25-每k个一组翻转链表</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Definition <span class="keyword">for</span> singly-linked <span class="built_in">list</span>.</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 采用迭代地思路解题</span></span><br><span class="line">        dummy=ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span>=head</span><br><span class="line">        <span class="comment"># 设置两个指针，一个pre指针指向虚拟结点，一个end指针，初始时指向虚拟结点，后面表示每次要翻转地链表地尾结点</span></span><br><span class="line">        <span class="comment"># pre:-1--&gt;1--&gt;2--&gt;3</span></span><br><span class="line">        <span class="comment"># end:-1--&gt;1--&gt;2--&gt;3</span></span><br><span class="line">        pre,end=dummy,dummy</span><br><span class="line">        <span class="comment"># 通过循环不断地找到翻转链表的尾部</span></span><br><span class="line">        <span class="keyword">while</span> end.<span class="built_in">next</span>!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                <span class="keyword">if</span> end <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># end不断地向后移动，移动k次达到每一组翻转链表地尾部</span></span><br><span class="line">                    end=end.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 如果发现end==None，说明此时翻转地链表地节点数小于k，保存原有的顺序</span></span><br><span class="line">            <span class="keyword">if</span> end <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 直接跳出循环，执行下面的翻转操作</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># next表示【待翻转区域】里面的第一个结点</span></span><br><span class="line">            <span class="built_in">next</span>=end.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 翻转区域的最尾部结点先断开</span></span><br><span class="line">            end.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># start表示【翻转区域】里面的第一个结点</span></span><br><span class="line">            start=pre.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 此时翻转区域的头结点时start，尾结点时end,执行后续的翻转操作</span></span><br><span class="line">            <span class="comment"># start--&gt;---&gt;end  变成 end---&gt;----&gt;start</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 要翻转的链表的头结点的【上一个节点】的 next 指针指向这次翻转的结果</span></span><br><span class="line">            pre.<span class="built_in">next</span>=self.reverseList(start)</span><br><span class="line">            <span class="comment"># 【翻转区域】里面的尾结点的next指针指向【待翻转区域】的第一个结点</span></span><br><span class="line">            start.<span class="built_in">next</span>=<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># pre表示每次翻转的链表的头结点的上一个结点</span></span><br><span class="line">            pre=start</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将end重置为[待翻转链表区]的头节点的上一个节点</span></span><br><span class="line">            end=start</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self,head:ListNode</span>):</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> == <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        cur = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head      </span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>

<h1 id="leetcoad142-环形链表II-middle"><a href="#leetcoad142-环形链表II-middle" class="headerlink" title="leetcoad142-环形链表II(middle)"></a>leetcoad142-环形链表II(middle)</h1><p>leetcoad链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a><br>视频链接：<a target="_blank" rel="noopener" href="https://www.algomooc.com/746.html">https://www.algomooc.com/746.html</a><br>涉及到的知识点:快慢指针<br>有一些理解的东西可能也很重要，自己要内化成为自己的东西</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/06/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A1%8D%E7%94%9F%E7%9A%84%E9%A2%98%E7%9B%AE/" data-id="claqu90020034iwtkcnhih0gd" data-title="链表的基础以及相关衍生的题目" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-leetcoad643-子数组最大平均数I" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/06/leetcoad643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0I/" class="article-date">
  <time class="dt-published" datetime="2022-03-06T14:25:07.000Z" itemprop="datePublished">2022-03-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/06/leetcoad643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0I/">leetcoad643-子数组最大平均数I</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>题目描述：<br>给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。<br>请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。<br>任何误差小于 10-5 的答案都将被视为正确答案。<br>示例输入：<br>输入：nums &#x3D; [1,12,-5,-6,50,3], k &#x3D; 4<br>输出：12.75<br>解释：最大平均数 (12-5-6+50)&#x2F;4 &#x3D; 51&#x2F;4 &#x3D; 12.75</p>
<p>解题思路分析：<br>要点分析：滑动窗口的思路<br>step1:找出其中一个长度为k的连续子数组<br>           第一个子数组的元素和sumk-1  需要计算nums的前k个元素之和得到<br>                 遍历数组nums一次即可得到<br>           依次计算第二个子数字的元素和sumk（推演过程）<br>step2:求出该连续子数组的k项和<br>           用sumi表示数组以下标i结尾的长度为k的子数组的元素和，i&gt;&#x3D;k-1,其中子数组的个数为              n-k+1个<br>           维护一个长度为k的滑动窗口，当窗口从下标范围[i-k,i-1],移动到[i-k+,i]时，nums            [i-k]从窗口移除，nums[i]从窗口进入<br>step3:写循环，求出所有连续子数组k项和的最大值<br>step4:输出最大值的平均数</p>
<p>解题代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxAverage</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="comment">#用数组total将nums中任意取的k个连续的子数组存起来</span></span><br><span class="line">    maxTotal = total = <span class="built_in">sum</span>(nums(:k))  </span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">#对i从k到n-1进行遍历（总共有n-k+1个子数组）</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,n):  </span><br><span class="line">            total = total -nums[i-k] + mums[i]</span><br><span class="line">            matotal = <span class="built_in">max</span>(maxTotal,totla)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxTotal / k</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/06/leetcoad643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0I/" data-id="claqu8zyt000piwtkc5h2b1an" data-title="leetcoad643-子数组最大平均数I" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" rel="tag">算法专栏（用python注写）</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-时间复杂度与空间复杂度(深度理解)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/06/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6(%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3)/" class="article-date">
  <time class="dt-published" datetime="2022-03-06T03:28:30.000Z" itemprop="datePublished">2022-03-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/06/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6(%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3)/">时间复杂度与空间复杂度(深度理解)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>主要是从时间和空间两方面来去考虑的</strong><br><strong>时间复杂度：</strong><br><strong>大O表示法：</strong><br>算法的时间复杂度通常用大O符号表述，定义为 **T[n] &#x3D; O(f(n)) **。称函数T(n)以f(n)为界或者称T(n)受限于f(n)。</p>
<p><strong>常见的时间复杂度的度量级：</strong><br>常数阶O(1)：无论代码执行了多少行，其他区域不会影响到操作，这个代码的时间复杂度都是O(1)<br>线性阶O(n)：for循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的<br>平方阶O(n²)：当存在双重循环的时候，即把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)<br>对数阶O(logn)：在二分查找法的代码中，通过while循环，成 2 倍数的缩减搜索范围，也就是说需要经过 log2^n 次即可跳出循环。<br>线性对数阶O(nlogn)：将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logn)，也就是了O(nlogn)。</p>
<p><strong>空间复杂度：</strong><br>(1) 固定部分，这部分空间的大小与输入&#x2F;输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。<br>(2) 可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。<br>一个算法所需的存储空间用f(n)表示。S(n)&#x3D;O(f(n))，其中n为问题的规模，S(n)表示空间复杂度。<br><strong>平衡二叉树：</strong><br>n 个节点的二叉排序树的高度为 log2n+1 ，其查找效率为O(Log2n)，近似于折半查找。<br><strong>列表二叉树：</strong><br>如果二叉树退变为列表了，则 n 个节点的高度或者说是长度变为了n，查找效率为O(n)，变成了顺序查找。<br><strong>一般二叉树：</strong><br>查找性能位于O(Log2n)到O(n)之间<br><strong>结语：</strong><br>算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/06/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6(%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3)/" data-id="claqu8zzw002piwtk9rit0fxk" data-title="时间复杂度与空间复杂度(深度理解)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" rel="tag">算法专栏（用python注写）</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-从安装python到自动画CAD" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/21/%E4%BB%8E%E5%AE%89%E8%A3%85python%E5%88%B0%E8%87%AA%E5%8A%A8%E7%94%BBCAD/" class="article-date">
  <time class="dt-published" datetime="2021-09-21T03:57:35.000Z" itemprop="datePublished">2021-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/21/%E4%BB%8E%E5%AE%89%E8%A3%85python%E5%88%B0%E8%87%AA%E5%8A%A8%E7%94%BBCAD/">从安装python到自动画CAD</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>主要解决的几个问题：<br>    1:python怎么和autocad连接<br>    2:python怎么和excel连接<br>    3 :怎么安装库<br>    4:怎么循环输入excel数据<br>    5:怎么插入块<br>    6 :怎么做成界面<br>    7:怎么选择文件<br>    8:怎么打包成exe</p>
<p><a target="_blank" rel="noopener" href="https://img2.baidu.com/it/u=1790615149,2362182487&amp;fm=26&amp;fmt=auto">https://img2.baidu.com/it/u=1790615149,2362182487&amp;fm=26&amp;fmt=auto</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/21/%E4%BB%8E%E5%AE%89%E8%A3%85python%E5%88%B0%E8%87%AA%E5%8A%A8%E7%94%BBCAD/" data-id="claqu8zz5001iiwtk96b3daej" data-title="从安装python到自动画CAD" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99%E7%9A%84%E5%B0%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/" rel="tag">工作之余的小的编程小知识</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-sap2000的二次开发+非解构+Grasshopper" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/21/sap2000%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91+%E9%9D%9E%E8%A7%A3%E6%9E%84+Grasshopper/" class="article-date">
  <time class="dt-published" datetime="2021-09-21T03:55:01.000Z" itemprop="datePublished">2021-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/21/sap2000%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91+%E9%9D%9E%E8%A7%A3%E6%9E%84+Grasshopper/">sap2000的二次开发+非解构+Grasshopper</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>目前还是想用非解构里面一些有用的东西，重在积累，所以现在要一点一滴的去积累，去整理，去发现其中的一些东西</p>
<p>配置几基本环境所必须的两个文件：<br>    *<br>SAP2000v20.dll   是用C#或C++进行编程的<br>    *<br>SAP2000v20.tlb  用于vba的编程</p>
<p>以下整理的是二次开发的一些知识点，慢慢积累下来，并写成文章的形式<br>后面再做一点持续的更新的文章<br>参考资料：<a target="_blank" rel="noopener" href="https://www.freesion.com/article/7503442976/#Blog_Links_6">https://www.freesion.com/article/7503442976/#Blog_Links_6</a><br>sap2000中几何模型的创建，其中包括绘制点对象、线对象、面对象和实体对象等</p>
<h2 id="创建点"><a href="#创建点" class="headerlink" title="创建点"></a>创建点</h2><p>几个常用的参数及其含义如下：<br>x, y, z&#x2F;r, Theta, z &#x2F;r, a, b：相应坐标系下的坐标值<br>Name：创建点的名称&#x2F;标签<br>UserName:用户自定义的创建带你的名称&#x2F;标签<br>CSys:坐标系名称<br>MergeOff：若此项为False，同一位置处创建的点将被合并<br>MergeNumber：Two points objects in the same location will merge only if their merge number assignments are the same. By default all pointobjects have a merge number of zero.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    =============================</span></span><br><span class="line"><span class="string">    Author: DalNur</span></span><br><span class="line"><span class="string">    Email: liyang@alu.hit.edu.cn</span></span><br><span class="line"><span class="string">    =============================</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> win32com.client  <span class="comment"># 库导入</span></span><br><span class="line">SapObject = win32com.client.Dispatch(<span class="string">&quot;Sap2000v15.SapObject&quot;</span>)  <span class="comment"># 创建Sap2000对象</span></span><br><span class="line">SapObject.ApplicationStart()  <span class="comment"># 启动Sap2000程序</span></span><br><span class="line">SapModel = SapObject.SapModel  <span class="comment"># 创建SapModel对象</span></span><br><span class="line">SapModel.InitializeNewModel(<span class="number">9</span>)  <span class="comment"># 初始化模型，设置单位为N_mm_C。</span></span><br></pre></td></tr></table></figure>
<h3 id="笛卡尔坐标系下创建点"><a href="#笛卡尔坐标系下创建点" class="headerlink" title="笛卡尔坐标系下创建点"></a>笛卡尔坐标系下创建点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x, y, z = <span class="number">12</span>, <span class="number">37</span>, <span class="number">0</span></span><br><span class="line">Name = <span class="string">&quot; &quot;</span></span><br><span class="line">UserName = <span class="string">&quot;A1&quot;</span></span><br><span class="line">CSys = <span class="string">&quot;Global&quot;</span>  <span class="comment"># 默认值</span></span><br><span class="line">MergeOff = <span class="literal">False</span>  <span class="comment"># 默认值</span></span><br><span class="line">MergeNumber = <span class="number">0</span>  <span class="comment"># 默认值</span></span><br><span class="line">ret = SapModel.PointObj.AddCartesian(x, y, z, Name, UserName, CSys, MergeOff, MergeNumber)</span><br></pre></td></tr></table></figure>
<h3 id="柱坐标系创建点"><a href="#柱坐标系创建点" class="headerlink" title="柱坐标系创建点"></a>柱坐标系创建点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r, Theta, z = <span class="number">12</span>, <span class="number">37</span>, <span class="number">0</span></span><br><span class="line">Name = <span class="literal">None</span></span><br><span class="line">UserName = <span class="string">&quot;A2&quot;</span></span><br><span class="line">CSys = = <span class="string">&quot;Global&quot;</span>  <span class="comment"># 默认值</span></span><br><span class="line">MergeOff = <span class="literal">False</span>  <span class="comment"># 默认值</span></span><br><span class="line">MergeNumber = <span class="number">0</span>  <span class="comment"># 默认值</span></span><br><span class="line">ret = SapModel.PointObj.AddCartesian(r, Theta, z, Name, UserName, CSys, MergeOff, MergeNumber)</span><br></pre></td></tr></table></figure>
<h3 id="球坐标系创建点"><a href="#球坐标系创建点" class="headerlink" title="球坐标系创建点"></a>球坐标系创建点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r,a,b=<span class="number">12</span>,<span class="number">37</span>,<span class="number">23</span></span><br><span class="line">Name=<span class="string">&quot; &quot;</span></span><br><span class="line">UserName=<span class="string">&quot;A3&quot;</span></span><br><span class="line">CSys =<span class="string">&quot;Global&quot;</span> <span class="comment">#默认值</span></span><br><span class="line">MergeOff = <span class="comment"># 默认值</span></span><br><span class="line">MergeNumber =<span class="number">0</span> <span class="comment"># 默认值</span></span><br><span class="line">ret=SapModel.Pointobj.AddSpherical(r,a,b,Name,UserName,CSys,MergeOff,MergeNumber)</span><br></pre></td></tr></table></figure>
<p>解释如下：上面的函数用于将点对象添加到模型中，添加的点对象被标记为特殊的点，除非它与另一个点对象合并，允许在模型中存在特殊的点，不需要连接其他的对象。<br>如果点对象已经成功的添加或合并，则该函数返回零，否则返回非零值。</p>
<h2 id="创建线"><a href="#创建线" class="headerlink" title="创建线"></a>创建线</h2><p>主要包括：框架梁、柱、次梁、斜撑、索、钢束等</p>
<h3 id="创建直线框架"><a href="#创建直线框架" class="headerlink" title="创建直线框架"></a>创建直线框架</h3><h4 id="由节点坐标创建直线框架"><a href="#由节点坐标创建直线框架" class="headerlink" title="由节点坐标创建直线框架"></a>由节点坐标创建直线框架</h4><p>相关的一些参数如下：<br>xi, yi, zi：创建框架 I 端节点坐标值<br>xj, yj, zj：创建框架 J 端节点坐标值<br>Name：This is the name that the program ultimately assigns for the frame object. If no UserName is specified, the program assigns a default name to the frame object. If a UserName is specified and that name is not used for another frame, cable or tendon object, the UserName is assigned to the frame object, otherwise a default name is assigned to the frame object.<br>PropName：<br>    + 若 PropName &#x3D; “Default”，系统指定默认截面属性给框架；<br>    + 若 PropName &#x3D; None，系统不指定任何截面属性给框架；<br>    + 若 PropName 为已定义的框架截面属性名称，则该截面属性被指定给框架。<br>UserName：用户自定义的框架名称&#x2F;标签，若名称已存在，则系统忽略该指定，框架将采用系统默认名称。<br>CSys：定义框架端点坐标值的坐标系名称</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xi, yi, zi = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">xj, yj, zj = <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span></span><br><span class="line">Name = <span class="string">&quot; &quot;</span></span><br><span class="line">PropName = <span class="string">&quot;Default&quot;</span>, </span><br><span class="line">UserName = <span class="string">&quot;Frame1&quot;</span></span><br><span class="line">CSys = <span class="string">&quot;Global&quot;</span></span><br><span class="line">ret = SapModel.FrameObj.AddByCoord(xi, yi, zi, xj, yj, zj, Name, PropName, UserName, CSys)</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/21/sap2000%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91+%E9%9D%9E%E8%A7%A3%E6%9E%84+Grasshopper/" data-id="claqu8zz2001biwtk24glhlo8" data-title="sap2000的二次开发+非解构+Grasshopper" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99%E7%9A%84%E5%B0%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/" rel="tag">工作之余的小的编程小知识</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Autolisp开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/21/Autolisp%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2021-09-21T03:33:37.000Z" itemprop="datePublished">2021-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/21/Autolisp%E5%BC%80%E5%8F%91/">Autolisp开发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>主要事一些记录，也是最原始的一些东西</p>
<p>list函数：（可能会经常的用到，注意一下）在 AutoLISP 中, 此函数经常用来定义 2D 或 3D 点的变量(一个含有两实型数坐标或三实型数坐标的表)。<br>变量清空的方法：（setq p1 nil):把变量p1置为空<br>查询变量的值：！p1:查询变量p1的值<br>prin1函数语法如下：  (prin1 [expr [file-desc]])<br>setq 函数：基本赋值函数，可以在对 setq 函数的一次调用中给多个符号赋值。  示例：下面的函数调用将变量 a 设为 5.0：命令： (setq a 5.0)5.0每次对 a 进行求值时，都返回实数 5.0。<br>princ:<br>此函数除了expr中的控制字符不以展开的方式显示出来以外, 其他均和prin1 函数相同。一般来说, prin1 函数是被设定来和 load 函数共用, 以输出表达式。而 princ函数则可输出由 read-line 函数所读进的文件。<br>print:<br>progn:函数除了在输出 expr 前会先输出新行, 同时也会在表达式后输出一空格以外, 其他功能均与 prin1 函数相同。语法如下：(progn [expr]…)<br>strcase函数：（学这个函数的背景：在输入的如论是大写还是小写，最后都会通过这个函数转化成统一的格式）语法如下： (strcase string [which])<br>strcase函数将接受string 参数所指定的字符串, 并且返回一个该字符串的拷贝, 其中所有字母的字符都按照第二个参数 which 的指定转换成大写或小写。如果 which 被省略或被判为 nil, 那么所有在 string 内的字母都会被转换成大写。如果 which 存在且其值为非 nil, 那么所有在 string中的字符均将被换成小写。<br>setvar函数(setvar varname value)用法：此函数可将 AutoCAD 系统变量设定给 value, 然后再返回其值。变量名称一定要以双引号括起。<br>范例cond函数：（相比于if函数更加的好用，if函数只是两者取其一）<br>polar函数 ：（polar pt angle distance）用法：此函数将返回距 UCS 某 pt 某 angle 某 distance 的 UCS3D 点。angle 是从 X 轴开始的角度, 以逆时针方向递增。虽然pt可能是3D点, angle 则永远相对于目前的基准绘图平面。<br>getdist函数：(getdist [pt] [prompt])用法：暂停等待用户输入距离换行“\n对象捕捉的参数：osmode<br>    * 关闭对象捕捉：（setvar “osmode” 0)<br>    * 获取对象捕捉：（getvar “osmode”）<br>    * 保留对象捕捉变量：</p>
<pre><code>    * 最开始先设置一个变量（setq osm (getvar &quot;osmode&quot;)) 
    * 程序用完之后再返回来：(setvar &quot;osmode&quot; osm)
</code></pre>
<p>strcat函数(strcat string1 [string2]…)用法：此函数将用来连接string1、string2等字符串, 并返回最后得到的字符串。rtos函数：将实型转化为字符串sqrt函数：计算一个数的平方根<br>car函数：返回列表(list)的第一个元素，如果是空表，那么car将返回nil(有点类似与二维数组中提取x坐标的感觉)<br>cdr函数：返回列表（list）中除第一个元素以外的所有元素的表<br>cadr函数：返回的是第二个元素<br>caddr函数：返回的是第三个元素<br>nth函数：此函数将返回List中的第n个元素（第一个元素是从0开始的，超过list中的数目后，函数将返回nil）<br>entget函数：获取图元或对象的定义数据<br>entlast函数：选中最后一个图元，并且把图元属性获取<br>entsel函数：提示用户通过指定一个点来选择单个对象（图元）<br>    entsel [msg])<br>    参数<br>    msg<br>    用于提示用户的字符串。如果省略该参数，则提示信息为“选择对象”。<br>assoc函数：从关联表中搜索一个元素，如果找到则返回该关联表条目<br>getpoint函数：<br>getcorner函数：此函数就如 getpoint 函数一样会返回在目前 UCS 中的一点, 不过, 此函数会要求 pt 参数, 并且由此基准点到屏幕上移动的十字光标间画出一矩形。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/21/Autolisp%E5%BC%80%E5%8F%91/" data-id="claqu8zy40000iwtk596w4smd" data-title="Autolisp开发" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99%E7%9A%84%E5%B0%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/" rel="tag">工作之余的小的编程小知识</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gridea/" rel="tag">Gridea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" rel="tag">python知识小记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99%E7%9A%84%E5%B0%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/" rel="tag">工作之余的小的编程小知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" rel="tag">算法专栏（用python注写）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0/" rel="tag">读书摘记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Gridea/" style="font-size: 10px;">Gridea</a> <a href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" style="font-size: 13.33px;">python知识小记</a> <a href="/tags/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99%E7%9A%84%E5%B0%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/" style="font-size: 16.67px;">工作之余的小的编程小知识</a> <a href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" style="font-size: 20px;">算法专栏（用python注写）</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0/" style="font-size: 10px;">读书摘记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/21/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2022/11/12/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%BA%94%E7%9A%84%E5%90%8C%E6%AD%A5/">搭建自己的博客并进行相应的同步</a>
          </li>
        
          <li>
            <a href="/2022/10/03/vs%20code%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%B7%A5%E5%85%B7%E5%8C%85/">关于vs code导入本地工具包和消除&#39;import [module] could not be resolved in pylance&#39;</a>
          </li>
        
          <li>
            <a href="/2022/09/25/%E5%85%B3%E4%BA%8Ematalab%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">关于matalab的数据分析</a>
          </li>
        
          <li>
            <a href="/2022/07/30/%E5%85%B3%E4%BA%8Epython%E7%88%AC%E8%99%AB%E4%B8%80%E7%82%B9%E5%B0%8F%E7%9A%84%E6%95%B4%E7%90%86/">关于python爬虫一点小的整理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>