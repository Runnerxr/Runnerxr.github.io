<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-关于python的一些高级特性-生成器-迭代器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/16/%E5%85%B3%E4%BA%8Epython%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E7%94%9F%E6%88%90%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2022-06-16T07:19:13.000Z" itemprop="datePublished">2022-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/16/%E5%85%B3%E4%BA%8Epython%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E7%94%9F%E6%88%90%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8/">关于python的一些高级特性-生成器/迭代器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这里面主要还是一些基础的知识，之前自己在印象笔记里面也有相应的整理的过程，总之相互结合，最后的目的是能够对知识点的掌握。</p>
<h1 id="生成器：generator"><a href="#生成器：generator" class="headerlink" title="生成器：generator"></a>生成器：generator</h1><ol>
<li>单纯通过列表生成式有时会很占相应的内存空间</li>
<li>列表元素按照某种算法推算出来，可以在循环的过程中不断的推算出后续的元素，可以不用创建完整的list，可以节省大量的存储空间</li>
<li><strong>一边循环一边计算的机制</strong>：generator</li>
<li>创建一个generator的方法：<ul>
<li>把列表生成式的[]改为（）</li>
<li>如果要打印出generator的每一个元素：通过next（）函数获得返回值</li>
<li>改进每次都需要不断的next的操作，采用for循环来迭代（<strong>generator也是可以迭代的对象</strong>），不需要关心产生的StopIteration的错误</li>
<li>第二种方法：如果函数定义中包含了yield关键字，函数不再是普通函数，是generator函数，调用一个generator函数就会返回一个generator</li>
</ul>
</li>
<li>工作原理：<ul>
<li>在for循环的过程中不断的计算出下一个元素，并在适当的条件结束for循环</li>
<li>对于函数改成的generator来说，遇到return或执行到函数体最后一行语句就是结束generator指令，for循环结束</li>
<li>普通函数调用直接返回结果，generator函数的调用返回一个generator对象</li>
</ul>
</li>
<li>案例：斐波拉契数列</li>
</ol>
<p>几个小例子辅助理解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 采用for循环来迭代，不需要关心产生的StopIteration的错误</span></span><br><span class="line">g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line"><span class="comment"># 打印结果如下</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">49</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当推算的算法比较的复杂的时候，用列表生成式的for循环无法实现的时候，用函数实现比较好</span></span><br><span class="line"><span class="comment"># 用斐波拉契数列来说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    n,a,b=<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n&lt;<span class="built_in">max</span>:</span><br><span class="line">        <span class="built_in">print</span>(b)</span><br><span class="line">        a,b=b,a+b</span><br><span class="line">        n=n+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;done&quot;</span></span><br><span class="line"><span class="built_in">print</span>(fib(<span class="number">6</span>))</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>由上面的演算逻辑可知：fib函数定义了斐波拉契数列的推算规则，可以从第一个元素开，推算处后续的任意元素。这种逻辑类似与generator,将上面的代码中的print(b)改为yield b，就可以把fib函数变成generator函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于包含关键字，函数不再是一个普通函数，调用一个generator函数将会返回一个generator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(fib(<span class="number">6</span>))</span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line">&lt;generator <span class="built_in">object</span> fib at <span class="number">0x000002CFDD443C80</span>&gt;</span><br></pre></td></tr></table></figure>
<p>附加理解：generator函数与普通函数的执行流程不同：</p>
<ol>
<li>普通函数：顺序执行，遇到return或者是最后一行函数语句就返回</li>
<li>对于generator函数来说：每次调用next()的时候执行，遇到yield语句返回，再次执行时的时候返回yield语句处处继续执行</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因此将上面的代码进行改进，不用next()来获取下一个返回值，直接用for循环迭代</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fib(<span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line"><span class="comment"># 打印结果如下：</span></span><br><span class="line"><span class="comment"># 没有获取return语句的返回值</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br><span class="line">    </span><br><span class="line">g=fib(<span class="number">6</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x=<span class="built_in">next</span>(g)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;g:&#x27;</span>,x)</span><br><span class="line">    <span class="comment"># 为了捕获StopIteration错误</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Generator return value:&#x27;</span> ,e.value)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 打印结果如下：</span></span><br><span class="line">g: <span class="number">1</span></span><br><span class="line">g: <span class="number">1</span></span><br><span class="line">g: <span class="number">2</span></span><br><span class="line">g: <span class="number">3</span></span><br><span class="line">g: <span class="number">5</span></span><br><span class="line">g: <span class="number">8</span></span><br><span class="line">Generator <span class="keyword">return</span> value: done</span><br></pre></td></tr></table></figure>


<h1 id="迭代器：Iterable"><a href="#迭代器：Iterable" class="headerlink" title="迭代器：Iterable"></a>迭代器：Iterable</h1><p>for循环的数据类型的以下几种：</p>
<ol>
<li>合数据类型：list 、tuple、dict、set、str等</li>
<li>generator:包含生成器和带yield的generator function<ul>
<li>可以直接作用于for循环的对象的为可迭代对象：Iterable</li>
<li>可以使用isinstance()判断一个对象是否是Iterable对象</li>
<li>不但可以作用于for循环，还可以被next()函数不断的调用并返回下一个值，直到抛出StopIteration错误无法继续返回下一个值</li>
<li>生成器都是Iterator对象，但list、dict、str虽然都是Iterable，不是Iterator</li>
<li>把list、dict、str等Iterable变成Iterator可以使用iter()函数：</li>
</ul>
</li>
<li>总结：<ul>
<li>凡是可以作用于for循环的对象的都是Iterable类型</li>
<li>凡是可作用于 next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；</li>
<li>Python的for循环本质上就是通过不断调用next()函数实现的</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/16/%E5%85%B3%E4%BA%8Epython%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E7%94%9F%E6%88%90%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8/" data-id="claquc62t001lz0tk5fnjhhqc" data-title="关于python的一些高级特性-生成器/迭代器" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-进程和线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/15/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2022-06-15T14:23:26.000Z" itemprop="datePublished">2022-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/15/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">进程和线程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><img src="https://runnerxr.github.io/post-images/1655606079687.png"><br>这一节也要搞懂相应的知识点，对于后面的运用很关键，这一节尤其难啃的，但是如果这节没有啃下来，后面的就更不用说了，会更难的，所以慢慢来，<strong>搞懂，概念梳理清楚，着急也是没有用的</strong>。<br>现在的操作系统都是支持“多任务”的操作系统<br>多任务：概念清楚就行（<strong>操作系统可以同时运行多个任务</strong>）<br>多核和单核CPU： 都可以执行多任务<br>单核CPU如何执行多任务：<strong>操作系统轮流让各个任务交替执行</strong>，<strong>任务1执行0.01秒</strong>，<strong>切换到任务2</strong>，任务2执行0.01秒，再切<strong>换到任务3</strong>，执行0.01秒……这样<strong>反复执行下去</strong>。<strong>表面上看，每个任务都是交替执行的</strong>，但是，由于CPU的<strong>执行速度实在是太快</strong>了，我们<strong>感觉</strong>就像所有任务都在<strong>同时执行一样</strong>。（后面编写实际的代码的时候才会慢慢感觉到）<br>一个比较恰当的比喻：</p>
<ol>
<li>一个工厂，至少有一个车间，一个车间中至少有一个工人，最终是工人在工作</li>
<li>一个程序，至少有一个进程，一个进程中至少有一个线程，最终是线程在工作<br>前面的编写的python程序，都是执行单任务的进程，也就只有一个线程，如果要同时执行多个任务的解决方案如下：</li>
<li>启动多个进程，<strong>虽然每个进程只有一个线程，但是多个进程可以一块执行多个任务</strong>（多进程模式）</li>
<li>启动一个进程，<strong>在一个进程内启动多个线程</strong>，这样多个线程可以 一块执行多个任务（多线程模式）</li>
<li>启动<strong>多个进程</strong>，每个进程启动<strong>多个线程</strong>，执行的任务更多，模型更加的复杂（多进程+多线程模式）[要想提高产能，可以提高增加车间的数量或者增加工人的数量,开发程序也是这样的一个思路。]</li>
</ol>
<p>小结：</p>
<ol>
<li>线程是最小的执行单元，进程又至少一个线程组成，<strong>如何调度进程和线程</strong>，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</li>
<li>通过进程比通过线程资源消耗要多。</li>
<li>多进程和多线程都涉及<strong>同步</strong>、<strong>数据共享的问题</strong>，编写起来相对<strong>更复杂</strong>。</li>
</ol>
<h1 id="多进程（multiprocessing）"><a href="#多进程（multiprocessing）" class="headerlink" title="多进程（multiprocessing）"></a>多进程（multiprocessing）</h1><p>把上面的例子做一个修改：</p>
<ol>
<li>一个工厂，创建<strong>三个车间</strong>，每个车间一个工人（共三人），并行处理任务</li>
<li>一个程序，创建<strong>三个进程</strong>，每个进程一个线程（共三个线程），并行处理任务<br>Unix&#x2F;Linux操作系统提供了一个<strong>fork()系统调用</strong>，普通函数的调用，调用一次，返回一次，fork()<strong>调用一次</strong>，<strong>返回两次</strong>，操作系统自动把当前进程（父进程）复制了一份（子进程），然后分别在<strong>父进程和子进程</strong>内返回<br>子进程永远返回0，父进程返回子进程的ID（<strong>一个父进程可以frok出很多子进程，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID</strong>）<br>Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Process (%s) start...&#x27;</span> % os.getpid())</span><br><span class="line"><span class="comment"># Only works on Unix/Linux/Mac:</span></span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="keyword">if</span> pid ==<span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;I am child process (%s) and my parent is %s.&#x27;</span> % (os.getpid(), os.getppid()))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;I (%s) just created a child process (%s).&#x27;</span> % (os.getpid(), pid))</span><br></pre></td></tr></table></figure>
不过在windows上无法运行，有了fork调用，一个进程在接到新的任务的时候就可以复制出一个子进程来出来处理新任务，常见的<strong>Apache服务器</strong>就是由父进程监听端口，每当有新的http请求的时候，就fork出子进程来处理新的http请求。<br>为了让Python也能在windows上运行，用<strong>multiprocessing模块</strong>就是跨平台版本的多进程模块<br>multiprocessing模块提供了一个<strong>process类来代表一个进程对象</strong>，下面的是演示启动一个启动子进程并等待其结束的过程。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_proc</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Run child process %s (%s)...&#x27;</span> % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多进程的编写需要写在main函数里面</span></span><br><span class="line"><span class="comment"># 原因：在python的底层，对于不同的操作系统创建进程的时候，内部机制不一样</span></span><br><span class="line"><span class="comment"># window是用spawn的模式创建进程就会报错</span></span><br><span class="line"><span class="comment"># 对于Linux是基于fork就不需要放在if__name__==&quot;__main__&quot;里面</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Parent process %s.&#x27;</span> % os.getpid())</span><br><span class="line">    <span class="comment"># 创建一个Process实例（在进程中还会创建一个线程，线程是工作的最小单元）</span></span><br><span class="line">    p=Process(target = run_proc,args=(<span class="string">&#x27;test&#x27;</span>,))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Child process will start.&#x27;</span>)</span><br><span class="line">    <span class="comment"># 用start()方法启动</span></span><br><span class="line">    p.start()</span><br><span class="line">    <span class="comment"># join()方法可以等待进程结束后再继续往下运行，通常用于进程间的同步</span></span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Child process end.&#x27;</span>)</span><br></pre></td></tr></table></figure>
如果要启动大量的子进程，可以用进程池的方式批量创建子进程：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">long_time_task</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Run task %s (%s)...&#x27;</span> % (name,os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() *<span class="number">3</span>)</span><br><span class="line">    end= time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task %s runs %0.2f seconds.&#x27;</span> % (name,(end-start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Parent process %s.&#x27;</span> % os.getpid())</span><br><span class="line">    p=Pool(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(long_time_task,args=(i,))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Waiting for all subprocesses done...&#x27;</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;All subprocesses done.&#x27;</span>)</span><br><span class="line"><span class="comment"># 执行结果如下：</span></span><br><span class="line">Parent process <span class="number">2508.</span></span><br><span class="line">Waiting <span class="keyword">for</span> <span class="built_in">all</span> subprocesses done...</span><br><span class="line">Run task <span class="number">0</span> (<span class="number">2548</span>)...</span><br><span class="line">Run task <span class="number">1</span> (<span class="number">3788</span>)...</span><br><span class="line">Run task <span class="number">2</span> (<span class="number">6204</span>)...</span><br><span class="line">Run task <span class="number">3</span> (<span class="number">3704</span>)...</span><br><span class="line">Task <span class="number">3</span> runs <span class="number">0.50</span> seconds.</span><br><span class="line">Run task <span class="number">4</span> (<span class="number">3704</span>)...</span><br><span class="line">Task <span class="number">2</span> runs <span class="number">0.92</span> seconds.</span><br><span class="line">Task <span class="number">1</span> runs <span class="number">0.98</span> seconds.</span><br><span class="line">Task <span class="number">4</span> runs <span class="number">0.54</span> seconds.</span><br><span class="line">Task <span class="number">0</span> runs <span class="number">1.94</span> seconds.</span><br><span class="line">All subprocesses done.</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h1><p>很多时候，子进程并不是自身，而是<strong>一个外部进程</strong>，我们创建了子进程后，还需要<strong>控制子进程的输入和输出</strong>，subprocess模块可以<strong>让我们非常方便启动一个子进程</strong>，然后<strong>控制其输入于输出</strong>。<br>演示如**何在python中运行命令nslookup <a target="_blank" rel="noopener" href="http://www.python.org/">www.python.org</a> **（感觉知识点又卡在这里了，没有理解其中的内涵）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;$ nslookup www.python.org&#x27;</span>)</span><br><span class="line">r=subprocess.call([<span class="string">&#x27;nslookup&#x27;</span>,<span class="string">&#x27;www.python.org&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Exit code:&#x27;</span>,r)</span><br><span class="line"><span class="comment"># 运行结果如下：</span></span><br><span class="line">$ nslookup www.python.org</span><br><span class="line">Server:  public1.alidns.com</span><br><span class="line">Address:  <span class="number">223.5</span><span class="number">.5</span><span class="number">.5</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:    dualstack.python.<span class="built_in">map</span>.fastly.net</span><br><span class="line">Addresses:  2a04:<span class="number">4e42</span>:8c::<span class="number">223</span></span><br><span class="line">          <span class="number">151.101</span><span class="number">.76</span><span class="number">.223</span></span><br><span class="line">Aliases:  www.python.org</span><br></pre></td></tr></table></figure>

<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>基于多线程对上述串行示例就行优化：（这种类比的解释让概念十分的清晰）</p>
<ol>
<li>一个工厂，创建一个车间，这个车间中创建3个工人，并进行处理任务</li>
<li>一个程序，创建一个进程，这个进程中创建3个线程，并进行处理任务</li>
</ol>
<p><strong>线程</strong>是操作系统<strong>直接支持的执行单元</strong>，因此<strong>高级语言都内置多线程的支持</strong>，python的线程是真正的Posix Thread ，不是模拟出来的线程，Python的标准库提供了两个模块：**_thread<strong>和</strong>threading**（对_thread进行了封装），分别是低级模块和高级模块，大部分情况用高级模块就行。<br><strong>启动一个线程就是把一个函数传入并创建Thread实例，然后调用strat()开始执行</strong>（后面看代码的时候就发现这只要理解清楚了也就不难理解了）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码来自廖雪峰的官方网站</span></span><br><span class="line"><span class="comment"># 导入threading模块</span></span><br><span class="line"><span class="keyword">import</span> time,threading</span><br><span class="line"><span class="comment"># 新线程执行的代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;thread %s is running...&#x27;</span> % threading.current_thread().name)</span><br><span class="line">    n=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n&lt;<span class="number">5</span>:</span><br><span class="line">        n=n+<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;thread %s &gt;&gt;&gt;%s&#x27;</span> % (threading.current_thread().name, n))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 子线程结束</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;thread %s ended.&#x27;</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 此处会默认启动一个主线程，用current_thread()返回当前线程的实例：MainThread   </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;thread %s is running...&#x27;</span> % threading.current_thread().name)</span><br><span class="line"><span class="comment"># 调用threading模块下的Thread类，创建一个Thread对象（实例化：线程），并封装线程被CPU调度时应该执行的任务和相关参数</span></span><br><span class="line"><span class="comment"># 此处用LoopThread命名子线程（人为的一个命名，打印显示，没有其他的意义）</span></span><br><span class="line">t=threading.Thread(target=loop,name=<span class="string">&#x27;LoopThread&#x27;</span>)</span><br><span class="line"><span class="comment"># 线程准备就绪（等待CPU调度，具体的时间由CPU来决定），代码继续向下执行</span></span><br><span class="line">t.start()</span><br><span class="line"><span class="comment"># 等待当前线程的任务执行完毕后再向下继续执行其他线程或主线程</span></span><br><span class="line">t.join()</span><br><span class="line"><span class="comment"># 主线程结束</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;thread %s ended.&#x27;</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果如下：</span></span><br><span class="line">thread MainThread <span class="keyword">is</span> running...</span><br><span class="line">thread LoopThread <span class="keyword">is</span> running...</span><br><span class="line">thread LoopThread &gt;&gt;&gt;<span class="number">1</span></span><br><span class="line">thread LoopThread &gt;&gt;&gt;<span class="number">2</span></span><br><span class="line">thread LoopThread &gt;&gt;&gt;<span class="number">3</span></span><br><span class="line">thread LoopThread &gt;&gt;&gt;<span class="number">4</span></span><br><span class="line">thread LoopThread &gt;&gt;&gt;<span class="number">5</span></span><br><span class="line">thread LoopThread ended.</span><br><span class="line">thread MainThread ended.</span><br></pre></td></tr></table></figure>
<p>需要特别梳理的地方：<br>任何进程<strong>默认会启动一个线程</strong>，该线程是主线程，<strong>主线程又可以启动新的线程</strong>，Python的threading模块有一个<strong>current_thread()函数</strong>，永远返回当前线程的实例，主线程实例的名字叫MainThread,子线程的名字在创建的时候指定，上面代码中用的LoopThread命名的子线程<br>由主线程从上到下去执行代码，当发现要创建一个线程的时候，线程在当前进程中会创建一个子线程去执行。主线程执行完所有代码，此时<strong>不结束，等待子线程</strong>，当子线程结束后，主线程运行完毕，整个程序才会运行结束。（通过运行上面的代码自己也能够弄清楚上面的一些过程，文字+代码能更好的理解）</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>t.setDaemon(布尔值)</p>
<ol>
<li><strong>t.setDaemon(True):<strong>设置为守护线程，主线程执行完毕，</strong>子线程</strong>也<strong>自动关闭</strong></li>
<li>t.setDaemon(False):设置为非守护线程，主线程<strong>等待子线程</strong>，子线程执行完毕后，主线程才结束（程序如果不修改，默认的就是非守护线程）</li>
</ol>
<p>因为默认的就是非守护线程。这里为了学习更深入，用守护线程的例子来理解，这里用setDaemon(True)把所有的子线程都变成了主线程的守护线程，主线程结束后，整个程序就退出了（子线程随着主线程的结束而结束）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time,threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task&quot;</span>,n)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    t=threading.Thread(target=run,args=(<span class="string">&quot;t-%s&quot;</span> % i,))</span><br><span class="line">    <span class="comment"># 把子进程设置为守护线程，必须在start()之前设置</span></span><br><span class="line">    t.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">0.5</span>)   <span class="comment"># 主线程停0.5s</span></span><br><span class="line"><span class="built_in">print</span>(threading.active_count())   <span class="comment"># 输出活跃的线程数</span></span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line">task t-<span class="number">0</span></span><br><span class="line">task t-<span class="number">1</span></span><br><span class="line">task t-<span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="线程名称的设置和获取"><a href="#线程名称的设置和获取" class="headerlink" title="线程名称的设置和获取"></a>线程名称的设置和获取</h3><p>待整理</p>
<h3 id="自定义线程类，直接将线程需要做的事写到run方法中"><a href="#自定义线程类，直接将线程需要做的事写到run方法中" class="headerlink" title="自定义线程类，直接将线程需要做的事写到run方法中"></a>自定义线程类，直接将线程需要做的事写到run方法中</h3><p>待整理</p>
<h2 id="GIL锁-Global-Interpreter-Lock-："><a href="#GIL锁-Global-Interpreter-Lock-：" class="headerlink" title="GIL锁(Global Interpreter Lock)："></a>GIL锁(Global Interpreter Lock)：</h2><p>如果是非Python环境，在单核情况下，同时只能有一个任务执行，多核的时候可以支持多个线程同时执行。但在python中，无论有多少核都只能执行一个线程。（和下面的解释是一样的）<br>以自己的电脑为例子<br>电脑的CPU是6核的，现在写一个死循环，如果是其他的语言，会将所有的CPU进程占据满，但是通过自己发现也验证了，cpu的占用率大约为16%（也就是只有一个线程被调用）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看电脑是几核的（用代码的语言来查看）</span></span><br><span class="line"><span class="keyword">import</span> threading, multiprocessing</span><br><span class="line">multiprocessing.cpu_count()</span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line"><span class="number">12</span>(双核CPU:用两个CPU去处理同一个数据)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用python写了一个死循环</span></span><br><span class="line"><span class="keyword">import</span> threading, multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop</span>():</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = x ^ <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(multiprocessing.cpu_count()):</span><br><span class="line">    t = threading.Thread(target=loop)</span><br><span class="line">    t.start()</span><br><span class="line"><span class="comment"># 通过观察任务管理器的占用率16%</span></span><br></pre></td></tr></table></figure>
<p>也即全局解释器，是Cpython（通过调用c语言的原生线程来实现）解释器特有的一个玩意，让进程中<strong>同一时刻只能有一个线程可以被CPU 调用</strong>如果想<strong>利用</strong>计算机的多核优势，让CPU同时处理一些任务，适合<strong>多进程开发</strong>（即使资源开销大），GIL锁就锁不住计算机的并发能力。GIL就像一个”通行证”，在一个python进程中只有一个GIL,拿不到通行证的线程就不允许进入CPU执行</p>
<h3 id="梳理多线程的工作过程"><a href="#梳理多线程的工作过程" class="headerlink" title="梳理多线程的工作过程"></a>梳理多线程的工作过程</h3><ol>
<li>拿到公共数据</li>
<li>申请gil</li>
<li>python解释器调用os原生线程</li>
<li>os操作CPU执行运算</li>
<li>当该线程执行时间到后，无论运算是否已经执行完毕，gil都被要求释放</li>
<li>由其他进程重复上面的过程</li>
<li>等其他进程执行完后，又会切换之前的进程（<strong>从他记录的上下文继续执行</strong>），整个过程是每个线程执行自己的运算，当<strong>执行时间到</strong>就进行相应的<strong>切换</strong>（context switch）<br><img src="https://runnerxr.github.io/post-images/1655477864283.png"><br>程序<strong>不利用</strong>计算机的多核优势，适合<strong>多线程开发</strong><br><img src="https://runnerxr.github.io/post-images/1655478007462.png"><br>所以什么时候利用多核优势进行多进程开发，什么时候不利用多核优势，进行多线程开发，两者都可以进行并发（终于理解了这样的一个过过程）</li>
<li><strong>计算密集型</strong>，用多进程，例如大量的数据计算[累加]</li>
<li><strong>IO密集型</strong>，用多线程，例如文件的读写，用网路数据传输[下载抖音视频示例]</li>
</ol>
<h3 id="GIL在不同版本之间的差异"><a href="#GIL在不同版本之间的差异" class="headerlink" title="GIL在不同版本之间的差异"></a>GIL在不同版本之间的差异</h3><p>只罗列最新的版本:GI不使用ticks，改为使用计时器（执行时间达到阈值后，当前线程释放GIL）,对CPU密集型程序比较的友好（提升了一定的计算效率），但是无法解决GIL导致的<strong>同一时间只能执行一个线程的问题</strong>（最原始的问题）。</p>
<h2 id="多线程开发"><a href="#多线程开发" class="headerlink" title="多线程开发"></a>多线程开发</h2><h2 id="线程锁（LOCK）"><a href="#线程锁（LOCK）" class="headerlink" title="线程锁（LOCK）"></a>线程锁（LOCK）</h2><p>有关其他锁的知识可以参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/whatisfantasy/p/6440585.html">https://www.cnblogs.com/whatisfantasy/p/6440585.html</a><br>多线程和多进程最大的不同：多进程中,同一变量，<strong>各自有一份拷贝存在每个进程中，互不影响</strong>，多线程中，所有变量都由所有线程共享，<strong>任何一个变量都可以被任何一个线程修改，存在多个线程同时改一个变量的风险</strong>（通过看视频还有当前的例子，自己对这个概念是已经理解了的），也就是存在线程安全的问题<br>如何避免这样的一种情况了？通过给线程上锁，锁的好处就是：确保了<strong>某段关键代码</strong>只能由<strong>一个线程从头到尾完整的执行</strong>阻止了多线程并发执行，只能以单线程模式执行，效率大大的降低了（一个线程执行完毕再让另外的一个线程去执行）。<br>下面的这个例子就很好的阐释了如果不加锁的话会存在线程的安全问题，将 run_thread()里面加入锁机制，当该线程获得锁，其他线程不能同时执行change_it()，只能等待，直到锁被释放后，获得该锁以后才能改。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假定这是你的银行存款（此处是一个共享变量）</span></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line"><span class="comment"># 创建一个锁就是通过threading.Lock()来实现</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_it</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 先存后取，结果应该为0:</span></span><br><span class="line">    <span class="keyword">global</span> balance</span><br><span class="line">    balance = balance + n</span><br><span class="line">    balance = balance - n</span><br><span class="line"></span><br><span class="line"><span class="comment"># def run_thread(n):</span></span><br><span class="line"><span class="comment">#     for i in range(2000000):</span></span><br><span class="line"><span class="comment">#         change_it(n)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_thread</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2000000</span>):</span><br><span class="line">        <span class="comment"># 为了确保balance的计算正确，给change_it()上一把锁</span></span><br><span class="line">        <span class="comment"># 先要获取锁</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 当t1线程开始执行的时候，其他线程不能同时执行change_it()</span></span><br><span class="line">            change_it(n)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 改完一定要释放锁，不然会成为死线程</span></span><br><span class="line">            lock.release()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=run_thread, args=(<span class="number">5</span>,))</span><br><span class="line">t2 = threading.Thread(target=run_thread, args=(<span class="number">8</span>,))</span><br><span class="line"><span class="comment"># 先后启动了两个线程</span></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"><span class="built_in">print</span>(balance)</span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>结合廖神的资料作最后的总结：</p>
<ol>
<li>GIL是python解释器的遗留问题，要正真利用多核，除非重写一个不带GIL的解释器，</li>
<li><strong>可以使用多线程，却不要指望有效利用多核，如果一定要用的话，只能通过C扩展来实现</strong>；</li>
<li>虽然不能利用多线程实现多核任务，但是可以通过<strong>多进程</strong>实现<strong>多核</strong>任务，多个进程有各自独立的GIL锁，互不影响。</li>
<li>多线程编程模型复杂，容易发生冲突，必须用锁加以隔离，同时要小心死锁发生</li>
</ol>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>这一节的内容还要反复的看，不断地找别的资料完善自己地理解和相应地知识结构体系。（不是那么好懂的，结合前后知识点和相关代码辅助理解。）<br>引出的原因：每个线程都有自己的数据，一个线程使用自己的局部变量比使用全局变量好（<strong>局部变量</strong>只有线程<strong>自己能看到</strong>，不会影响其他线程，<strong>全局变量的修改必须加锁</strong>[这个也是上一节的时候重点讨论过的]，局部变量也存在问题：<strong>函数调用的时候，传递起来很麻烦</strong>）<br>用一个具体的例子来说明存在的问题：每个函数一层一层调用传参会十分的麻烦，用全局变量也不行（<strong>每个线程处理不同的Student对象，不能共享</strong>）[这里的话反复的理解，没有一定的积累是很难理解的]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_student</span>(<span class="params">name</span>):</span><br><span class="line">    std=student(name)</span><br><span class="line">    <span class="comment"># std是局部变量，但是每个函数都要用它，需要传进去</span></span><br><span class="line">    do_task_1(std)</span><br><span class="line">    do_task_2(std)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_task_1</span>(<span class="params">std</span>):</span><br><span class="line">    do_subtask_1(std)</span><br><span class="line">    do_subtask_2(std)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_task_2</span>(<span class="params">std</span>):</span><br><span class="line">    do_subtask_2(std)</span><br><span class="line">    do_subtask_2(std)</span><br></pre></td></tr></table></figure>
<p>想办法解决上述的问题：用一个全局的<strong>dict</strong>存放所有的<strong>Student</strong>对象，然后以<strong>thread</strong>自身作为<strong>key</strong>获得线程对应的<strong>Student</strong>对象（跟着廖神的思路慢慢走）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个全局的字典</span></span><br><span class="line">global_dict=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">std_thread</span>(<span class="params">name</span>):</span><br><span class="line">    std=Student(name)</span><br><span class="line">    <span class="comment"># 把std放到全局变量global_dict中：</span></span><br><span class="line">    gloabal_dict[threading.current_thread()] = std</span><br><span class="line">    do_task_1(std)</span><br><span class="line">    do_task_2(std)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_task_1</span>(<span class="params">std</span>):</span><br><span class="line">    <span class="comment"># 不传入std，而是根据当前线程查找：</span></span><br><span class="line">    std = global_dict[threading.current_thread()]</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_task_2</span>(<span class="params">std</span>):</span><br><span class="line">    <span class="comment"># 任何函数都可以查找出当前线程的std变量</span></span><br><span class="line">    std = global_dict[threading.current_thread()]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>解决了：std对象在每层函数中的传递问题<br>不足之处：每个函数获取std的代码有点丑<br>….<br>跟着廖神的思路继续走，查看有没有更加简单的方式？<br>这里引出了ThreadLocal，<strong>不用查找dict</strong>，用<strong>ThreadLocal</strong>帮你<strong>自动做</strong>这件事<br>…思路是符合层层推进的过程的，所以自己一时没有理解也是没有关系的，要注意看懂，也是这三段中唯一可以运行的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 导入threading模块</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建全局ThreadLocal对象：</span></span><br><span class="line"><span class="comment"># 每个Thread对它都可以读写student属性</span></span><br><span class="line"><span class="comment"># local_school是全局变量，local_school.student都是线程的局部变量</span></span><br><span class="line"><span class="comment"># 任意读写并且可以互不干扰，不用管理锁的问题，ThreadLocal内部会处理</span></span><br><span class="line">local_school = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_stuent</span>():</span><br><span class="line">    <span class="comment"># 获取当前线程关联的student:（也也即线程的局部变量）</span></span><br><span class="line">    std=local_school.student</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, %s (in %s)&quot;</span> % (std,threading.current_thread().name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_thread</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="comment"># 绑定ThreadLocal的student:</span></span><br><span class="line">    loacl_student.student = name</span><br><span class="line">    process_student()</span><br><span class="line"></span><br><span class="line">t1= threading.Thread(target = process_thread,args=(<span class="string">&#x27;Alice&#x27;</span>, ),name=<span class="string">&#x27;Thread-A&#x27;</span>)</span><br><span class="line">t2= threading.Thread(target = process_thread,args=(<span class="string">&#x27;Bob&#x27;</span>, ) , name=<span class="string">&#x27;Thread-B&#x27;</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line">Hello, Alice (<span class="keyword">in</span> Thread-A)</span><br><span class="line">Hello, Bob (<span class="keyword">in</span> Thread-B)</span><br></pre></td></tr></table></figure>
<p> 小结：（说实话，有点不好理解确实虽然是层层推进的这样的一个过程）</p>
<ol>
<li>全局变量local_school是一个dict，不但可以用loacl_school.student，还可以绑定其他变量（local_school.teacher）另类的解释：threadlocal让一个变量在<strong>自己的线程内</strong>相当于是<strong>全局变量</strong>（所有函数都能访问），在<strong>不同的线程间</strong>相当于是<strong>局部变量</strong>（其他线程无法访问）</li>
<li>ThreadLocal最常用的可以<strong>为每个线程绑定一个数据库连接</strong>，<strong>HTTP请求</strong>，<strong>用户身份信息</strong>等，一个线程的<strong>所有调用到的处理函数</strong>都可以方便的访问这些资源。（这点暂时无法理解）</li>
<li>一个ThreadLocal变量虽然是<strong>全局变量</strong>，但是<strong>每个线程都只能读写自己线程的独立副本</strong>，互不干扰，ThreadLocal解决了<strong>参数</strong>在一个线程中<strong>各个函数之间互相传递</strong>的问题。</li>
<li>附加一个参考链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/whatisfantasy/p/6440585.html">https://www.cnblogs.com/whatisfantasy/p/6440585.html</a></li>
</ol>
<h3 id="进程-vs-线程"><a href="#进程-vs-线程" class="headerlink" title="进程 vs 线程"></a>进程 vs 线程</h3><p>主要是了讨论两种方式的优缺点：<br>要实现多任务，通常会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，在多任务的环境下，一个是Master，一个是Worker</p>
<ol>
<li>用多进程实现Master-Worker，<strong>主进程</strong>就是Master，<strong>其他进程</strong>就是Worker</li>
<li>用多线程事项Master-Worker，主线程就是Master,其他线程就是Worker</li>
</ol>
<p>多进程模式:<br>优点：稳定性高，一个子进程崩溃，不会影响主进程和其他的子进程（主进程Master只负责分配任务，挂掉的概率很低）<br>缺点：创建进程代价大，比如在Windows，操作系统<strong>同时运行的进程数是有限的</strong>，如果同时有几千个进程同时运行，在<strong>内存和CPU的限制</strong>下，操作<strong>系统的调度会成问题</strong>。</p>
<p>多线程模式：<br>优点：相对快一点<br>缺点：任何一个线程挂掉都有可能直接造成整个进程崩溃（<strong>所有线程共享进程的内存</strong>）：结合自己平和的一些经验来理解就可以了</p>
<h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><p>操作系统在切换进程或者线程时也是一样的，它需要先<strong>保存当前执行的现场环境</strong>（CPU寄存器状态、内存页等），然后，<strong>把新任务的执行环境准备好</strong>（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要<strong>耗费时间</strong>。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是<strong>硬盘狂响</strong>，<strong>点窗口无反应</strong>，系统处于<strong>假死状态</strong>。<br>导致的结果：一但多任务到达一个限度：会消耗系统所有的资源，效率急剧下降，所有的任务都无法做好</p>
<h2 id="计算密集型-vs-IO密集型"><a href="#计算密集型-vs-IO密集型" class="headerlink" title="计算密集型 vs IO密集型"></a>计算密集型 vs IO密集型</h2><p>是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为计算密集型和IO密集型。（结合这里的理解对两种任务类型有了更加深刻的认识与理解）</p>
<p>计算密集型任务：要进行<strong>大量的计算</strong>，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是<strong>任务越多</strong>，花在<strong>任务切换的时间就越多</strong>，CPU执行任务的效率就越低，所以，要<strong>最高效地利用CPU</strong>（多线程切换需要消耗资源），计算密集型任务同时进行的数量应当等于CPU的核心数。计算密集型任务由于<strong>主要消耗CPU资源</strong>，因此，代码运行效率至关重要。Python这样的<strong>脚本语言</strong>运行<strong>效率很低</strong>，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p>
<p>第二种任务的类型是IO密集型：涉及到<strong>文件处理</strong>、<strong>网络爬虫</strong>、<strong>磁盘IO</strong>的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在<strong>等待IO操作完成</strong>（因为IO的速度远远低于CPU和内存的速度，开启多个线程，自动进行切换可以不浪费CPU的资源，提高程序的执行效率）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，<strong>用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率</strong>。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p>
<h2 id="分步式进程"><a href="#分步式进程" class="headerlink" title="分步式进程"></a>分步式进程</h2><p> 在Thread（进程）和Process(线程)中，应当优先选Process,Posses更稳定，Prossess可以<strong>分布到多台机器</strong>上，但是Thread最多只能<strong>分布到同一台机器的多个CPU上</strong><br>multiprocessing模块不但支持多进程，其中的mangers子模块支持把多进程分步到多台机器上，一个服务器进程可以作为调度者，将任务分布到其他多个进程中，依靠<strong>网络通信</strong>，managers模块封装很好，不必了解网络通信的细节，就可以很容易地<strong>编写分布式多进程程序</strong><br>…理解廖神的教程真的需要很大的精力去理解（但是还是需要努力去啃）<br>有一个通过<strong>Queue通信的多进程</strong>程序在同一机器上运行，现在想改进：因为处理进程的任务繁重，希望把<strong>发送任务的进程</strong>和<strong>处理任务的进程</strong>分布到两台机器上，如何用分布式来实现？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补充知识：为什么这里会提到queue？在python中多个线程的数据是共享的，多个线程进行数据交换的时候，不能保证数据的安全性和一致性。当多个线程需要进行数据交换的时候，队列可以解决线程间的数据交换（可以保证线程间数据的安全性和一致性）</span><br></pre></td></tr></table></figure>
<p>解决方法：原有的Queue继续用，通过mangers模块把<strong>Queue</strong>通过网络暴露出去，就可以<strong>让其他机器的进程访问Queue了</strong>，先看服务进程，服务进程负责启动Queue，把Queue注册到网络上，然后往Queue里面写入任务。<br>参考资料：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011318077/article/details/88094583">https://blog.csdn.net/u011318077/article/details/88094583</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个分布式进程，用来完成10次乘法任务</span></span><br><span class="line"><span class="comment"># 服务器在win系统和在Linux上有所不同</span></span><br><span class="line"><span class="comment"># 创建一个分布式进程：包括服务器进程和任务进程</span></span><br><span class="line"><span class="comment"># 多个进程之间的通信使用queue</span></span><br><span class="line"><span class="comment"># 该代码为服务进程</span></span><br><span class="line"><span class="comment"># 运行时先运行服务进程，再运行任务进程</span></span><br><span class="line"><span class="comment"># 执行任务循序：</span></span><br><span class="line"><span class="comment"># 服务进程和任务进程都创建了相同的两个队列，一个用来放任务，一个用来放结果</span></span><br><span class="line"><span class="comment"># 第一步：服务器进程运行，例：将数字2放进任务队列，任务进程从任务队列中取出数字2</span></span><br><span class="line"><span class="comment"># 第二步：取出数字，执行任务，即2*2=4，任务执行完后，放入结果队列中</span></span><br><span class="line"><span class="comment"># 第三步：服务进程从结果队列中，取出结果</span></span><br><span class="line"><span class="comment"># 第四步：所有任务执行完毕，所有结果都已经取出，最终任务队列和结果队列都是空的了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random,queue   <span class="comment"># 导入随机 时间  队列模块</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager   <span class="comment"># 导入多进程管理</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> freeze_support   <span class="comment"># window防出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一步：定义两个Queue队列，一个用于发送任务，一个接收结果</span></span><br><span class="line"><span class="comment"># 发送任务的队列（实例化队列为任务队列）</span></span><br><span class="line">task_queue = queue.Queue()</span><br><span class="line"><span class="comment"># 接收结果的队列（实例化队列为结果队列）</span></span><br><span class="line">result_queue = queue.Queue()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从BaseManger继承的QueueManger:(定义QueueManger继承BaseManager,用于后面创建管理器)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueueManager</span>(<span class="title class_ inherited__">BaseManager</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义两个函数，返回结果就是Queue队列</span></span><br><span class="line"><span class="comment"># win下queuemanger注册到网络关联队列不能用lambda，自定义一个函数用于关联</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_task_queue</span>():</span><br><span class="line">    <span class="keyword">global</span> task_queue  <span class="comment"># 定义成全局变量</span></span><br><span class="line">    <span class="keyword">return</span> task_queue  <span class="comment"># 饭返回发送任务的队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># win下queuemanger注册到网络关联队列不能用lambda，自定义一个函数用于关联</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_result_queue</span>():</span><br><span class="line">    <span class="keyword">global</span> result_queue</span><br><span class="line">    <span class="keyword">return</span> result_queue  <span class="comment"># 返回接收结果的队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：把上面创建的两个队列注册在网络上，利用register方法</span></span><br><span class="line"><span class="comment"># callable参数关联了Queue对象，将Queue对象在网络中暴露出来</span></span><br><span class="line"><span class="comment"># 第一个参数是注册在网络上队列的名称</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    QueueManager.register(<span class="string">&#x27;get_task_queue&#x27;</span>, <span class="built_in">callable</span>=return_task_queue)</span><br><span class="line">    QueueManager.register(<span class="string">&#x27;get_result_queue&#x27;</span>, <span class="built_in">callable</span>=return_result_queue)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第三步：绑定端口8001，设置验证口令，这个相当于对象的初始化</span></span><br><span class="line">    <span class="comment"># 绑定端口并填写验证口令，window下需要填写IP地址，Linux下默认为本地，地址为空</span></span><br><span class="line">    manager= QueueManager(address=(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8001</span>), authkey=<span class="string">b&#x27;abc&#x27;</span>)  <span class="comment"># 口令必须斜撑类似b&#x27;abc&#x27;形式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第四步：启动管理器，启动Queue队列，监听信息通道</span></span><br><span class="line">    manager.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第五步：通过管理实例的方法获访问网络中的Queue对象</span></span><br><span class="line">    task = manager.get_task_queue()</span><br><span class="line">    result = manager.get_result_queue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第六步：添加任务，获得返回的结果</span></span><br><span class="line">    <span class="comment"># 将任务放到Queue队列中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        n=random.randint(<span class="number">0</span>,<span class="number">10</span>)  <span class="comment"># 返回0~10之间的随机数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;put task %d...&#x27;</span> % n)</span><br><span class="line">        task.put(n)  <span class="comment"># 将n放入到任务队列中</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从结果队列中取出结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Try get results...&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">        <span class="comment"># 总共循环10次，上面放了10个数字作为任务</span></span><br><span class="line">        <span class="comment"># 加载一个异常捕获</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            r=result.get(timeout=<span class="number">5</span>) <span class="comment"># 每次等待5s,取结果队列中的值</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Result:%s&#x27;</span> % r)</span><br><span class="line">        <span class="keyword">except</span> queue.Empty:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;result queue is empty.&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 最后一定要关闭服务，不然会报错</span></span><br><span class="line">    manager.shutdown()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;master exit.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    freeze_support()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Start!&quot;</span>)</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>
<p>然后是任务进程</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/15/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" data-id="claquc63j002zz0tkbyx84j25" data-title="进程和线程" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-IO编程-与异步IO" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/15/IO%E7%BC%96%E7%A8%8B-%E4%B8%8E%E5%BC%82%E6%AD%A5IO/" class="article-date">
  <time class="dt-published" datetime="2022-06-15T12:04:42.000Z" itemprop="datePublished">2022-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/15/IO%E7%BC%96%E7%A8%8B-%E4%B8%8E%E5%BC%82%E6%AD%A5IO/">IO编程-与异步IO</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>IO编程中，Stream（流）的概念：Input stream 就是数据从外面（磁盘、网络）流进内存，output stream就是数据从内存流到外面去。对于浏览网页来说：浏览器与服务器之间至少要建立两根水管，才可以既能发数据，又能收数据。<br>由于CPU和内存的速度远远高于外设的速度，解决IO编程中速度严重不匹配的情况(两者区别：是否等待IO执行的结果)</p>
<ol>
<li>一种是CPU等着，程序暂停执行后序代码，等数据写入磁盘再接着往下执行，称为同步IO</li>
<li>CPU不等待，去执行其他的事情， 后续代码可以立刻接着执行，这种模式称为异步IO</li>
<li>使用异步编程的性能会远远高于同步IO,但是编程的模型复杂</li>
</ol>
<p>每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用，异步IO在涉及到服务器端程序开发时再讨论。</p>
<h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><h1 id="stringIO-和BytesIO"><a href="#stringIO-和BytesIO" class="headerlink" title="stringIO 和BytesIO"></a>stringIO 和BytesIO</h1><h1 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h1><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>异步IO<br>一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用<strong>多线程或者多进程</strong>来并发执行代码，为<strong>多个用户</strong>服务。每个用户都会<strong>分配一个线程</strong>，如果遇到IO导致线程被挂起，其<strong>他用户的线程不受影响</strong>。<br>多线程和多进程的模型虽然解决了并发问题，但是<strong>系统不能无上限地增加线程</strong>。由于<strong>系统切换线程的开销也很大</strong>，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。<br>目的：解决的问题是CPU高速执行能力与IO设备的龟速的严重不匹配：</p>
<ol>
<li>多线程与多进程</li>
<li>异步IO,当代码需要执行一个耗时的IO操作的时候，<strong>只发出指令，并不等待IO结果</strong>，去执行其他代码，一段时间结束后，当IO返回结果的时候，通知CPU执行处理</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do_some_coad()</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">r = f.read()  <span class="comment"># &lt;==线程停在此处等待IO操作结果</span></span><br><span class="line"><span class="comment"># IO操作完成后线程才能继续执行</span></span><br><span class="line">do_some_code(r)</span><br></pre></td></tr></table></figure>
<p>异步IO模型需要一个消息循环，在消息循环中，主线不断地重复“读取消息-处理消息”这一过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loop=get_event_loop()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    event = loop.get_event()</span><br><span class="line">    process_event(event)</span><br></pre></td></tr></table></figure>
<p>这里附上一个比较好地理解的方式：<br>老张爱喝茶，废话不说，煮开水。 出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。<br>1 老张把水壶放到火上，立等水开。（同步阻塞） 老张觉得自己有点傻<br>2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞） 老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。<br>3 老张把响水壶放到火上，立等水开。（异步阻塞） 老张觉得这样傻等意义不大<br> 4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞） 老张觉得自己聪明了。<br>所谓<strong>同步异步</strong>，只是对于<strong>水壶</strong>而言。 普通水壶，同步；响水壶，异步。 虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。 <strong>同步只能让调用者去轮询自己</strong>（情况2中），造成老张效率的低下。</p>
<p>所谓<strong>阻塞非阻塞</strong>，仅仅对于<strong>老张</strong>而言。 立等的老张，阻塞；看电视的老张，非阻塞。 情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以<strong>一般异步是配合非阻塞使用的，这样才能发挥异步的效用</strong>。</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程又称微线程，英文名字为Coroutine,以下为与子程序的对比：</p>
<ol>
<li>子程序是通过<strong>栈实现</strong>的，<strong>一个线程</strong>就是执行<strong>一个子程序</strong>，子程序调用总是<strong>一个入口</strong>，<strong>一次返回</strong>，<strong>调用顺序是明确</strong>的</li>
<li>协程在执行的过程中，<strong>在子程序内部可以中断</strong>，然后<strong>执行别的子程序</strong>，在<strong>适当</strong>的时候再返回来<strong>接着执行</strong></li>
<li>在一个子程序中中断，去执行其他的子程序，不是函数的调用，有点类似CPU的中断</li>
</ol>
<p>另外的资料辅助理解：</p>
<ol>
<li>协程不是计算机提供的，程序员人为创造</li>
<li>通过一个线程实现代码的相互切换<br>以下用两个函数来理解：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">A</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">B</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;z&#x27;</span>)</span><br></pre></td></tr></table></figure>
如果由协程来执行，在执行A的过程中，<strong>可以随时中断，去执行B</strong>，B也可能在执行过程中中断再去执行A,相应的可能的结果为：<br>1<br>2<br>x<br>y<br>3<br>z<br>但是在A中是没有调用B的，协程的调用比<strong>函数的调用要复杂</strong>一点。执行看似有点像多线程，但是实际上是一个线程执行，相比多线程的优势如下：</li>
<li>协程极<strong>高的执行效率</strong>，子程序切换不是线程切换，是<strong>程序自身控制</strong>，也就<strong>没有线程切换的开销</strong>，当线程数量越多的时候，协程的性能优势就越明显。</li>
<li>不需要多线程的锁机制，只有一个线程，<strong>不存在同时写变量冲突</strong>，在协程中<strong>控制共享资源不加锁</strong>，只需要<strong>判断状态</strong>就好了，执行效率比多线程的效率高很多。</li>
<li>如何利用多核CPU？：<strong>多进程+协程</strong>，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能</li>
</ol>
<h3 id="对协程的支持"><a href="#对协程的支持" class="headerlink" title="对协程的支持"></a>对协程的支持</h3><p>python对协程的支持通过<strong>generator</strong>来实现，不但可以<strong>通过for循环来迭代</strong>，还可以不<strong>断调用next()函数</strong>获取由yield语句返回的下一个值（可能刚开始还不太理解：python中的yield不但可以返回一个值，它还可以接受调用者发出的参数）<br>目前实现协程的几种方式：</p>
<ol>
<li>greenlet，早期模块</li>
<li>yield关键字</li>
<li>asyncio装饰器（python3.4）</li>
<li>async await关键字（python3.5）[最主流的，也是官方最推荐的方式]<br>以一个例子来举例：<br>传统的生产者-消费者模型是<strong>一个线程写消息</strong>，<strong>一个线程取消息</strong>，通过<strong>锁机制</strong>控制队列和等待，但是一不小心可能死锁，现在换一种方式：<strong>如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率会大大提高</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>():</span><br><span class="line">    r=<span class="string">&#x27; &#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n=<span class="keyword">yield</span> r  <span class="comment"># yield对应挂起（yield语句执行后，进入暂停，赋值语句在下一次启动生成器的时候首先被执行）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[CONSUMER] Consuming %s...&#x27;</span> % n)</span><br><span class="line">        r = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">produce</span>(<span class="params">c</span>):</span><br><span class="line">    <span class="comment"># send在接受None参数的情况下，等同于next(generator)的功能，同时send也可以接受其他的参数，后面举例说明</span></span><br><span class="line">    c.send(<span class="literal">None</span>)  <span class="comment"># 调用c.send(None)，启动生成器</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Producing %s...&#x27;</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Consumer return: %s&#x27;</span> % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line">c = consumer()</span><br><span class="line">produce(c)</span><br><span class="line"><span class="comment"># 执行结果如下：</span></span><br><span class="line">[PRODUCER] Producing <span class="number">1.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">1.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br><span class="line">[PRODUCER] Producing <span class="number">2.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">2.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br><span class="line">[PRODUCER] Producing <span class="number">3.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">3.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br><span class="line">[PRODUCER] Producing <span class="number">4.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">4.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br><span class="line">[PRODUCER] Producing <span class="number">5.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">5.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br></pre></td></tr></table></figure>
以下为对这段代码的解释：<br>consumer函数就是一个generator ,把一个consumer 传入produce后</li>
<li>调用c.send(None)，启动生成器</li>
<li>一旦生产了东西，通过c.send(n),切换到consumer执行</li>
<li>consumer通过yield拿到消息，处理，又通过yield把结果传回</li>
<li>produce拿到consumer处理的结果，继续生下一条消息</li>
<li>produce决定不生产，通过c.close()关闭consumer整个过程结束</li>
</ol>
<p>为了更好的理解上面的c.send(n)的用法，这里也是参照别人的例子来辅助理解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">num</span>():</span><br><span class="line">    a = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        a = <span class="keyword">yield</span> a</span><br><span class="line">c = num()</span><br><span class="line">c.send(<span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(c.send(<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(c.send(<span class="number">100</span>))</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>对上面的运行的理解：</p>
<ol>
<li>首先使用c.send(None),返回生成器的第一个值 a&#x3D;yield 1(只是挂起，并没有执行赋值语句)</li>
<li>使用c.send(5),再次启动生成器，这里传入了参数5，再次启动的时候，<strong>从上次yield语句断掉的地方开始执行</strong>，由于此时传入参数5，所以a被赋值5</li>
<li>然后程序进入while循环，当程序执行到a&#x3D;yield a，此时<strong>先返回生成器的值5</strong>，<strong>下次</strong>启动生成器的时候，<strong>再执行赋值赋值语句</strong></li>
<li>到这里再次理解：<strong>python的yield不但可以返回一个值，它还可以接收调用者发出的参数</strong></li>
<li>有没有什么注意事项：在一个生成器函数未启动前，是不能传递值进去，也即<strong>在使用c.send(n)之前，必须先使用c.send(None)或者next(c)来返回生成器的第一个值</strong></li>
</ol>
<p>再次结合别人的整理来理解：<br>使用协程比较奇特：把数据传过去了，又神奇的接受到了数据，协程被创造出来就是<strong>用来解决异步任务的</strong>，不能够和多线程弄混，<strong>多线程是用来完成并发任务</strong>，异步和并发是两个不同的概念，同步和异步是一种<strong>描述指令执行或事件产生顺序</strong>，并发与并行指多个或多段可以独立运行的程序对系统资源（主要是CPU）的占用。异步任务最常见的就是读取文件，网络请求等IO操作。<br>以前处理异步任务都是使用回调（缺点就是地狱回调：回调函数套回调函数），协程的目标就是<strong>将这些烦人的异步代码可以像同步代码一样写</strong>，就是异步代码的同步化<br>协程的核心概念就是函数或一段程序能够被挂起，稍后在挂起的位置恢复，挂起和恢复是可以控制的，<strong>始终围绕的是挂起和恢复这两个概念</strong>，还有一个重要的组成—状态机，协程将原本连续的逻辑拆散，需要状态机来维护状态，每一次的挂起和恢复都会切换到对应的状态，以便下一次的操作可以知道该做什么？<br>这里结合这位答主更好的去理解：<br>另外还附上另一份参考资料：<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21823699">https://www.zhihu.com/question/21823699</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/SL_World/article/details/86597738">https://blog.csdn.net/SL_World/article/details/86597738</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>():</span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[CONSUMER] 挂起&#x27;</span>)</span><br><span class="line">        <span class="comment"># 1. 启动协程后运行到yield，挂起函数，并将状态扭转为挂起。函数栈跳转到producer</span></span><br><span class="line">        <span class="comment"># 3.consumer函数从yield处恢复，从恢复状态中拿到sendData的值赋值给next。一个循环后到达yield，继续将函数挂起，并将状态扭转为挂起，result的值保存在状态中。函数栈跳到producer</span></span><br><span class="line">        <span class="built_in">next</span> = <span class="keyword">yield</span> result</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[CONSUMER] 恢复--并接受到数据%s&#x27;</span> % <span class="built_in">next</span>)</span><br><span class="line">        result = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">produce</span>(<span class="params">coroutine</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] 准备启动协程&#x27;</span>)</span><br><span class="line">    <span class="comment"># 这里采用next(coroutine)是启动协程，与c.send(None)的功能是一样的</span></span><br><span class="line">    <span class="comment"># 启动协程就是运行这个函数，比较特殊，普通的调用方式无法运行，需要使用next(c)或者c.send(None)</span></span><br><span class="line">    <span class="built_in">next</span>(coroutine)</span><br><span class="line">    sendData = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> sendData &lt; <span class="number">2</span>:</span><br><span class="line">        sendData = sendData + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] 发送数据 %s&#x27;</span> % sendData)</span><br><span class="line">        <span class="comment"># 2. producer函数继续执行到send方法，send恢复当前挂起，将状态扭转为恢复并将sendData的值保存在状态中。函数栈跳转到consumer</span></span><br><span class="line">        <span class="comment"># 4. producer函数send方法从挂起状态中拿到result的值赋值给result</span></span><br><span class="line">        result = coroutine.send(sendData)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] 处理结果: %s&#x27;</span> % result)</span><br><span class="line">    coroutine.close()</span><br><span class="line"></span><br><span class="line">coroutine = consumer()</span><br><span class="line">produce(coroutine)</span><br><span class="line"><span class="comment"># 运行结果如下：</span></span><br><span class="line">[PRODUCER] 准备启动协程</span><br><span class="line">[CONSUMER] 挂起</span><br><span class="line">[PRODUCER] 发送数据 <span class="number">1</span></span><br><span class="line">[CONSUMER] 恢复--并接受到数据<span class="number">1</span></span><br><span class="line">[CONSUMER] 挂起</span><br><span class="line">[PRODUCER] 处理结果: <span class="number">200</span> OK</span><br><span class="line">[PRODUCER] 发送数据 <span class="number">2</span></span><br><span class="line">[CONSUMER] 恢复--并接受到数据<span class="number">2</span></span><br><span class="line">[CONSUMER] 挂起</span><br><span class="line">[PRODUCER] 处理结果: <span class="number">200</span> OK</span><br></pre></td></tr></table></figure>

<h2 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h2><p>直接内置了对异步IO的支持<br>asyncio的编程模型就是一个<strong>消息循环</strong>，从asyncio模块中直接<strong>获取一个EventLoop的引用</strong>，然后把需要执行的协程扔到<strong>EventLoop中执行</strong>，就实现了异步IO<br>用asyncio实现Hello world的代码：后面有点逐层深入的感觉，感觉理解起来并没有那么容易呀：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用asynicio实现Hello world</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="comment"># 把一个generator标记为coroutine类型，然后把coroutine扔到EventLoop中执行</span></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">    <span class="comment"># 异步调用asyncio.sleep(1):</span></span><br><span class="line">    <span class="comment"># yield from语法可以让我们方便地调用另一个generator</span></span><br><span class="line">    <span class="comment"># 把asyncio.sleep(1)看成是一个耗时1秒的IO操作</span></span><br><span class="line">    r=<span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello again!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取EventLoop:</span></span><br><span class="line">loop =asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 执行coroutine</span></span><br><span class="line">loop.run_until_complete(hello())</span><br><span class="line">loop.close</span><br></pre></td></tr></table></figure>
<p>接下来用Task封装两个coroutine（这里需要理解，也是很重要的一点：也算是比较难理解的一点）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用Task封装两个coroutine</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello word! (%s)&quot;</span> % threading.currentThrentThread())</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello again!(%s)&quot;</span> % threading.currentThread())</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [hello(),hello()]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>
<p>这里为了搞懂协程的知识以及这部分章节的理解又看了其他的一些理解（说实话才发现前面的理解的有点浅了，这些概念都还是十分抽象的），这里引用别人博客的文章来辅助理解。</p>
<h2 id="从yield-from-到-async的使用"><a href="#从yield-from-到-async的使用" class="headerlink" title="从yield from 到 async的使用"></a>从yield from 到 async的使用</h2><p>“对同步和异步的看法，上面自己总结的时候也用了一些例子来说明”<br>【同步】：就是发出一个“调用”时，在没有得到结果之前，该“调用”就不返回，“调用者”需要一直等待该“调用”结束，才能进行下一步工作。<br>【异步】：“调用”在发出之后，就直接返回了，也就没有返回结果。“被调用者”完成任务后，通过状态来通知“调用者”继续回来处理该“调用”。<br>下面的这个例子通过顺序实现两个同步IO任务taskIO_1()和taskIO_2()很好的解释了如果cpu运行完毕之后要闲置很长时间取等待IO任务完成才能进行下一个任务计算这种模型的低效率。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用普通同步代码实现多个IO任务的案例</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">taskIO_1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始运行IO任务1...&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)  <span class="comment"># 假设该任务耗时2s</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;IO任务1已完成，耗时2s&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">taskIO_2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始运行IO任务2...&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)  <span class="comment"># 假设该任务耗时3s</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;IO任务2已完成，耗时3s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">taskIO_1()</span><br><span class="line">taskIO_2()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;所有IO任务总耗时%.5f秒&#x27;</span> % <span class="built_in">float</span>(time.time()-start))</span><br><span class="line"><span class="comment"># 运行结果如下：</span></span><br><span class="line">开始运行IO任务<span class="number">1.</span>..</span><br><span class="line">IO任务<span class="number">1</span>已完成，耗时2s</span><br><span class="line">开始运行IO任务<span class="number">2.</span>..</span><br><span class="line">IO任务<span class="number">2</span>已完成，耗时3s</span><br><span class="line">所有IO任务总耗时<span class="number">5.02295</span>秒</span><br></pre></td></tr></table></figure>
<p>因此需要用到异步的方式来处理上述的任务，极大的增大效率，就是运用协程，在python生成器的关键字yield中可以实现中断功能，<strong>也即协程是基于生成器的变形实现的，之后虽然编码的形式有变化，但是基本原理不变</strong></p>
<h3 id="使用yield-from和-asyncio-coroutine实现协程"><a href="#使用yield-from和-asyncio-coroutine实现协程" class="headerlink" title="使用yield from和@asyncio.coroutine实现协程"></a>使用yield from和@asyncio.coroutine实现协程</h3><p>协程都是通过使用yield from和asyncio中的@asyncio.coroutine来实现的，asyncio专门被用来实现异步IO操作<br>yield与yield from的区别：yield在生成器中有中断的功能，可以传出值，也可以从函数外部接收值，<strong>yield from的实现就是简化了yield操作。</strong><br>其中yield titles返回了titles完整列表<br>yield from titles等价于下面的这一小段代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> title <span class="keyword">in</span> titles:　<span class="comment"># 等价于yield from titles</span></span><br><span class="line">    <span class="keyword">yield</span> title　</span><br></pre></td></tr></table></figure>
<p> 用下面的例子来解释这种区别：代码比较简单，但是对于概念的理解非常有帮助</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generator_1</span>(<span class="params">titles</span>):</span><br><span class="line">    <span class="keyword">yield</span> titles</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generator_2</span>(<span class="params">titles</span>):</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> titles</span><br><span class="line"></span><br><span class="line">titles = [<span class="string">&#x27;Python&#x27;</span>,<span class="string">&#x27;Java&#x27;</span>,<span class="string">&#x27;C++&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> title <span class="keyword">in</span> generator_1(titles):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;生成器1:&#x27;</span>,title)</span><br><span class="line"><span class="keyword">for</span> title <span class="keyword">in</span> generator_2(titles):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;生成器2:&#x27;</span>,title)</span><br><span class="line"><span class="comment"># 打印结果如下：</span></span><br><span class="line">生成器<span class="number">1</span>: [<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>]</span><br><span class="line">生成器<span class="number">2</span>: Python</span><br><span class="line">生成器<span class="number">2</span>: Java</span><br><span class="line">生成器<span class="number">2</span>: C++</span><br></pre></td></tr></table></figure>
<p>于此同时，yield from还可以<strong>省去很多异常的处理，不需要我们去手动编写，内部已经实现了大部分的异常处理</strong><br>继续…<br>通过生成器来实现一个整数加和的程序，通过<strong>send()函数</strong>向生成器中传入<strong>要加和的数字</strong>，然后返回None结束，total保存最后加和的总数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generator_1</span>():</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x=<span class="keyword">yield</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;加&quot;</span>,x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total +=x</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generator_2</span>():  <span class="comment"># 委托生成器</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        total = <span class="keyword">yield</span> <span class="keyword">from</span> generator_1() <span class="comment"># 子生成器</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;加和总数是：&quot;</span>,total)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(): <span class="comment"># 调用方</span></span><br><span class="line">    g1=generator_1()</span><br><span class="line">    g1.send(<span class="literal">None</span>)</span><br><span class="line">    g1.send(<span class="number">2</span>)</span><br><span class="line">    g1.send(<span class="number">3</span>)</span><br><span class="line">    g1.send(<span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># g2 = generator_2()</span></span><br><span class="line">    <span class="comment"># g2.send(None)</span></span><br><span class="line">    <span class="comment"># g2.send(2)</span></span><br><span class="line">    <span class="comment"># g2.send(3)</span></span><br><span class="line">    <span class="comment"># g2.send(None)</span></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>如果是按照上述这么写的话，会报错，但是如果将main()函数的代码改过来，就不会出错，此时g2即使传入了None也不报异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(): <span class="comment"># 调用方</span></span><br><span class="line">    <span class="comment"># g1=generator_1()</span></span><br><span class="line">    <span class="comment"># g1.send(None)</span></span><br><span class="line">    <span class="comment"># g1.send(2)</span></span><br><span class="line">    <span class="comment"># g1.send(3)</span></span><br><span class="line">    <span class="comment"># g1.send(None)</span></span><br><span class="line">    g2 = generator_2()</span><br><span class="line">    g2.send(<span class="literal">None</span>)</span><br><span class="line">    g2.send(<span class="number">2</span>)</span><br><span class="line">    g2.send(<span class="number">3</span>)</span><br><span class="line">    g2.send(<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 最后打印结果</span></span><br><span class="line">加 <span class="number">2</span></span><br><span class="line">加 <span class="number">3</span></span><br><span class="line">加 <span class="literal">None</span></span><br><span class="line">加和总数是: <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>综合上面的几个例子做一点相应的梳理：</p>
<ol>
<li>子生成器：<strong>yield from后的</strong>generator_1()生成器函数是子生成器</li>
<li>委托生成器：也即上面的generator_2(),负责<strong>委托子生成器完成具体的任务</strong></li>
<li>调用方：main()是程序中的调用方，负责调用委托生成器</li>
</ol>
<p>由此引出了yield from的另外一个关键作用：<strong>建立调用方和子生成器的通道</strong></p>
<ol>
<li>main()每次在调用send(value)时，value不是传递给了委托生成器generator_2()，<strong>而是借助yield from传递给了子生成器generator_1中的yield</strong>(这几句话的概括通过代码的调试就能够大致的了解了。)</li>
<li>子生成器中的数据也是<strong>通过yield直接发送到调用方main()中</strong>（代码调试就能够清楚这样的一个过程）</li>
<li>也因此我们在写代码的时候依据：<em>调用方-子生成器-委托生成器</em>的规范形式来书写（现在可能还无法体会，后面接触的多了也许会有相应的了解。）</li>
</ol>
<h2 id="如何结合-asyncio-coroutine实现协程"><a href="#如何结合-asyncio-coroutine实现协程" class="headerlink" title="如何结合@asyncio.coroutine实现协程"></a>如何结合@asyncio.coroutine实现协程</h2><p>对初始的那个例子进行相应的更改（同步IO修改成协程的用法）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用同步方式编写异步功能</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="meta">@asyncio.coroutine </span><span class="comment"># 标志协程的装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">taskIO_1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始进行IO任务1...&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">2</span>) <span class="comment"># 假设该任务耗时2s</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO任务1已完成,耗时2s&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> taskIO_1.__name__</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine </span><span class="comment"># 标志协程的装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">taskIO_2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始进行IO任务2...&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">3</span>)  <span class="comment"># 假设该任务耗时3s</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO任务2已完成,耗时3s&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> taskIO_2.__name__</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine </span><span class="comment"># 标志协程的装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():  <span class="comment"># 调用方</span></span><br><span class="line">    tasks=[taskIO_1(),taskIO_2()]  <span class="comment"># 把所有任务添加到task中</span></span><br><span class="line">    done,pending = <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.wait(tasks) <span class="comment"># 子生成器</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> done: <span class="comment">#done和pending都是一个任务，所以返回结果需要逐个调用result()</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;协程无序返回值：&quot;</span>+r.result())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    loop=asyncio.get_event_loop() <span class="comment"># 创建一个事件循环对象loop</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        loop.run_until_complete(main())  <span class="comment"># 完成事件循环，直到最后一个任务结束</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        loop.close()  <span class="comment"># 结束事件循环</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有IO任务总耗时%.5f秒&quot;</span> % <span class="built_in">float</span>(time.time()-start))</span><br><span class="line"><span class="comment"># 打印结果如下：</span></span><br><span class="line">开始进行IO任务<span class="number">2.</span>..</span><br><span class="line">开始进行IO任务<span class="number">1.</span>..</span><br><span class="line">IO任务<span class="number">1</span>已完成,耗时2s</span><br><span class="line">IO任务<span class="number">2</span>已完成,耗时3s</span><br><span class="line">协程无序返回值：taskIO_1</span><br><span class="line">协程无序返回值：taskIO_2</span><br><span class="line">所有IO任务总耗时<span class="number">3.02165</span>秒</span><br></pre></td></tr></table></figure>
<p>对这段代码进行相应的分析：<br>使用方法：</p>
<ol>
<li>@asyncio.coroutine装饰器是<strong>协程函数的标志</strong>，我们需要在每一个任务函数前加这个装饰器，并在函数中<strong>使用yield from</strong></li>
<li>在同步IO任务的代码中使用的<strong>time.sleep(2)<strong>来假设任务执行了2秒，在</strong>协程中</strong>yield from后面必须是<strong>子生成器函数</strong>，time.sleep()并不是生成器，所以替换成使用内置模块提供的生成器函数<strong>asyncio.sleep()</strong><br>功能：<br>通过使用协议，极大的增大了多任务的执行效率，最后消耗的时间就是任务队列中耗时最多的时间，<strong>总耗时就是taskIO_2的耗时时间</strong><br>执行过程：（理解的关键，结合调试一起理解）</li>
<li>先通过get_event_loop()获取了一个<strong>标准事件循环loop</strong>（单线程）</li>
<li>通过run_until_complete(main())来运行协程：run_until_complete意思是直到循环事件的所有事件都处理完才能完整结束</li>
<li>进入<strong>调用方协程</strong>，我们把多个任务[taskIO_1()和taskIO_2()]放到一个task列表中，可理解为<strong>打包任务</strong>。</li>
<li>使用<strong>asyncio.wait(tasks)<strong>来获取一个awaitable objects即可等待对象的集合(此处的aws是协程的列表)，并发运行传入的aws，同时通过yield from</strong>返回一个包含(done, pending)的元组</strong>，done表示<strong>已完成的任务列表</strong>，pending<strong>表示未完成的任务列表</strong>；如果使用asyncio.as_completed(tasks)则会按完成顺序生成协程的迭代器(常用于for循环中)，因此当你用它迭代时，<strong>会尽快得到每个可用的结果</strong>。【此外，当轮询到某个事件时(如taskIO_1())，直到遇到该任务中的yield from中断，开始处理下一个事件(如taskIO_2()))，当yield from后面的子生成器完成任务时，该事件才再次被唤醒】</li>
<li>done里面有我们需要的返回结果，但它目前还是个<strong>任务列表</strong>，所以要取出返回的结果值，我们遍历它并逐个调用result()取出结果即可</li>
<li>通过loop.close()关闭事件循环</li>
</ol>
<p>总结：协程的完整实现是靠：事件循环+协程（这也是一开始在廖神的课程中总结的，要真正理解这句话真的是有点难呀）</p>
<h2 id="使用async和await实现协程"><a href="#使用async和await实现协程" class="headerlink" title="使用async和await实现协程"></a>使用async和await实现协程</h2><p>在python3.5后引入新的语法：async和await，可以简化并更好的标识异步IO，如果需要用需要做如下的替换：</p>
<ol>
<li>把@asyncio.coroutine替换为async</li>
<li>把yield from 替换为await</li>
</ol>
<p>将上面已经有的代码进行相应的更新：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重点要把上下两段代码做一下相应的比较就知道相应的修改的地方了</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">taskIO_1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始进行IO任务1...&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 假设该任务耗时2s</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO任务1已完成,耗时2s&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> taskIO_1.__name__</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">taskIO_2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始进行IO任务2...&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)  <span class="comment"># 假设该任务耗时3s</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO任务2已完成,耗时3s&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> taskIO_2.__name__</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():  <span class="comment"># 调用方</span></span><br><span class="line">    tasks=[taskIO_1(),taskIO_2()]  <span class="comment"># 把所有任务添加到task中</span></span><br><span class="line">    done,pending = <span class="keyword">await</span> asyncio.wait(tasks) <span class="comment"># 子生成器</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> done: <span class="comment">#done和pending都是一个任务，所以返回结果需要逐个调用result()</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;协程无序返回值：&quot;</span>+r.result())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    loop=asyncio.get_event_loop() <span class="comment"># 创建一个事件循环对象loop</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        loop.run_until_complete(main())  <span class="comment"># 完成事件循环，直到最后一个任务结束</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        loop.close()  <span class="comment"># 结束事件循环</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有IO任务总耗时%.5f秒&quot;</span> % <span class="built_in">float</span>(time.time()-start))</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>引出问题：</p>
<ol>
<li>同步编程的并发性不高</li>
<li>多进程编程受CPU核数限制，当任务数量远大于CPU核数时，执行效率会降低</li>
<li>多线程编程需要线程之间的通信，而且需要锁机制来防止共享变量被不同线程乱改（也是前面提到的提纲性的概念），由于python中的GIL（全局解释器锁），实际上无法做到正真的并行。（暂时没有接触到实际的项目，可能理解没有那么全面）<br>产生的需求：</li>
<li>可不可采用同步的方式来编写异步功能代码？（已经实现）</li>
<li>能不能只用一个单线程就能做到不同任务之间的切换？<strong>这样没有线程切换的时间消耗，也不用使用锁机制来削弱多任务并发效率</strong></li>
<li>对于IO密集型任务，可否有更高的处理方式来节省CPU的等待时间？</li>
</ol>
<p>针对以上的3点需求，就有了协程的出现，<strong>多进程核多线程是内核级别的程序，而协程是函数级别的程序，是可以通过程序员进行调试的</strong><br><img src="https://runnerxr.github.io/post-images/1655396352806.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/15/IO%E7%BC%96%E7%A8%8B-%E4%B8%8E%E5%BC%82%E6%AD%A5IO/" data-id="claquc6220004z0tk51b32120" data-title="IO编程-与异步IO" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Linux的的相关知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/15/Linux%E7%9A%84%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2022-06-15T11:41:25.000Z" itemprop="datePublished">2022-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/15/Linux%E7%9A%84%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/">Linux的的相关知识点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这一方面就当是做一个储备吧，后面保不准就会用到这方面的知识，算是一点积累吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/15/Linux%E7%9A%84%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="claquc6230005z0tk4w9wg2ej" data-title="Linux的的相关知识点" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-关于python框架的一些知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/12/%E5%85%B3%E4%BA%8Epython%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2022-06-12T13:49:05.000Z" itemprop="datePublished">2022-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/12/%E5%85%B3%E4%BA%8Epython%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/">关于python框架的一些知识点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>学习python不可避免的也要学习一些框架相关的知识点</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/12/%E5%85%B3%E4%BA%8Epython%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="claquc62t001kz0tkdqvz3dx5" data-title="关于python框架的一些知识点" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-单调栈以及单调队列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/30/%E5%8D%95%E8%B0%83%E6%A0%88%E4%BB%A5%E5%8F%8A%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2022-05-30T13:10:44.000Z" itemprop="datePublished">2022-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/30/%E5%8D%95%E8%B0%83%E6%A0%88%E4%BB%A5%E5%8F%8A%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/">单调栈以及单调队列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>单调递减栈：从<strong>栈底</strong>到<strong>栈顶</strong>是单调递减的<br>每次我们移动到数组中一个新的位置 iii，就将当前单调栈中所有<strong>小于 nums2[i]</strong> 的元素<strong>弹出</strong>单调栈，<br>对于单调队列解决问题的模板：for 循环要<strong>从后往前扫描元素</strong>，因为我们<strong>借助的是栈的结构</strong>，倒着入栈，其实是正着出栈。while 循环是把两个“<strong>高个</strong>”元素之间的<strong>元素排除</strong>，因为他们的存在没有意义，前面挡着个“更高”的元素，所以他们不可能被作为后续进来的元素的 Next Great Number 了。<br>这个算法的时间复杂度不是那么直观，如果你看到 for 循环嵌套 while 循环，可能认为这个算法的复杂度也是 O(n^2)，但是实际上这个算法的复杂度只有 O(n)。<br>分析它的时间复杂度，要从整体来看：总共有 n 个元素，每个元素都被 push 入栈了一次，而最多会被 pop 一次，没有任何冗余操作。所以总的计算规模是和元素规模 n 成正比的，也就是 O(n) 的复杂度。</p>
<h1 id="leetcoad496-下一个更大的元素I"><a href="#leetcoad496-下一个更大的元素I" class="headerlink" title="leetcoad496-下一个更大的元素I"></a>leetcoad496-下一个更大的元素I</h1><p>题目描述：<br>nums1 中数字 x 的 下一个更大元素 是指 x 在** nums2 中对应位置** 右侧 的 <strong>第一个 比 x 大</strong>的元素。<br>给你两个 <strong>没有重复元素</strong> 的数组 nums1 和 nums2 ，下标<strong>从 0 开始</strong>计数，其中nums1 是 nums2 的<strong>子集</strong>。<br>对于每个 0 &lt;&#x3D; i &lt; nums1.length ，找出满足 nums1[i] &#x3D;&#x3D; nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。<br>返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。<br>示例 1：<br>输入：nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].<br>输出：[-1,3,-1]<br>解释：（这里的解释算是比较的清楚的表述的）<br>  对于num1中的数字4，在num2中不存在下一个更大元素，所以答案是 -1 。<br>  对于num1中的数字1，在num2中存在下一个更大元素是 3 。<br>  对于num1中的数字2，在num2中不存在下一个更大元素，所以答案是 -1 。</p>
<p>示例 2：<br>输入：nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].<br>输出：[3,-1]<br>解释：nums1 中每个值的下一个更大元素如下所述：<br>对于num1中的数字2，在num2中存在下一个更大元素是 3 。<br>对于num1中的数字4，在num2中不存在下一个更大元素，所以答案是 -1 。</p>
<p>直接暴力解法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 采用暴力的解法来解题</span></span><br><span class="line">        <span class="comment"># 定义一个结果数组，用来存放最后的值</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums1)</span><br><span class="line">        res=[-<span class="number">1</span>]*n</span><br><span class="line">        <span class="comment"># 在nums1中进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 在nums2中遍历,找到与nums1[i]相同的值nums2[j]</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums2)):</span><br><span class="line">                <span class="keyword">if</span> nums2[j]==nums1[i]:</span><br><span class="line">                    <span class="comment"># 然后在nums2[j]右侧继续找，找到一个比他大的数出来</span></span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j+<span class="number">1</span>,<span class="built_in">len</span>(nums2)):</span><br><span class="line">                        <span class="keyword">if</span> nums2[k]&gt;=nums2[j]:</span><br><span class="line">                            res[i]=nums2[k]</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>思路分析：（借助栈来遍历分析）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 若数组为空，直接返回空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums1:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        n=<span class="built_in">len</span>(nums1)</span><br><span class="line">        ans=[-<span class="number">1</span>]*n</span><br><span class="line">        <span class="comment"># 倒着往栈里面放元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># nums2.index(nums1[i]) 表示当遍历的元素是nums1[i]的时候，此时的这个元素在nums2中的下标是多少,</span></span><br><span class="line">            <span class="comment"># 用temp_index存储，表示临时下标的意思</span></span><br><span class="line">            <span class="comment"># 由于我们需要寻找nums2中对应位置的右侧，也就需要在nums2的[temp_index:]这个区间里面去找是否有比nums1[i]大的数</span></span><br><span class="line">            temp_index=nums2.index(nums1[i])</span><br><span class="line">            s=nums2[temp_index:][::-<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 栈不为空，并且栈顶元素不超过当前遍历的元素</span></span><br><span class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> nums1[i]&gt;=s[-<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 把当前的栈顶元素弹开</span></span><br><span class="line">                s.pop()</span><br><span class="line">            <span class="comment"># while循环结束</span></span><br><span class="line">            <span class="comment"># 如果当前栈有值，直接将栈顶值赋给ans[i],表示存在</span></span><br><span class="line">            ans[i]=s[-<span class="number">1</span>] <span class="keyword">if</span> s <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>看到官方的题解尽然可以优化：单调栈+哈希表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="comment"># 对反转之后的nums2进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">reversed</span>(nums2):</span><br><span class="line">            <span class="comment"># 当栈顶元素不为空，并且栈顶元素小于当前遍历的元素的时候</span></span><br><span class="line">            <span class="comment"># 将栈顶的元素进行弹出</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> num &gt;= stack[-<span class="number">1</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="comment"># 内循环结束之后，如果如果栈不为空，那么哈希表中遍历的值为栈顶的元素，如果栈为空，说明此时=右侧没有比他更大的数，直接返回-1</span></span><br><span class="line">            hashmap[num] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            <span class="comment"># 将当前的num值加入栈中</span></span><br><span class="line">            stack.append(num)</span><br><span class="line">        <span class="comment"># 返回的值需要注意，遍历nums1,用相应的num值哈希表hashmap中去寻找</span></span><br><span class="line">        ans=[hashmap[num] <span class="keyword">for</span> num <span class="keyword">in</span> nums1]</span><br><span class="line">        <span class="comment"># 上面的是用的表达式求值，写起来要相对简洁一点；如果实际做题的时候不够熟练，可以用常规的方式来解题</span></span><br><span class="line">        <span class="comment"># ans=[]</span></span><br><span class="line">        <span class="comment"># for num in nums1:</span></span><br><span class="line">        <span class="comment">#     temp=hashmap.get(num)</span></span><br><span class="line">        <span class="comment">#     ans.append(temp)</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums1=[<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">    nums2=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">    res=Solution().nextGreaterElement(nums1,nums2)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<h1 id="leetcoad503-下一个更大的元素II"><a href="#leetcoad503-下一个更大的元素II" class="headerlink" title="leetcoad503-下一个更大的元素II"></a>leetcoad503-下一个更大的元素II</h1><p>题目描述：<br>给定一个<strong>循环数组</strong> nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中<strong>每个元素</strong>的 <strong>下一个更大</strong>元素 。<br>数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该<strong>循环地搜索</strong>它的下一个更大的数。如果不存在，则输出 -1 。</p>
<p>示例 1:<br>输入: nums &#x3D; [1,2,1]<br>输出: [2,-1,2]<br>解释: 第一个 1 的下一个更大的数是 2；<br>数字 2 找不到下一个更大的数；<br>第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</p>
<p>示例 2:<br>输入: nums &#x3D; [1,2,3,4,3]<br>输出: [2,3,4,-1,4]</p>
<p>思路分析：因为用到了最小栈与最小队列的思想</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/30/%E5%8D%95%E8%B0%83%E6%A0%88%E4%BB%A5%E5%8F%8A%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" data-id="claquc6310022z0tk7c0l54h4" data-title="单调栈以及单调队列" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python的网站开发知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/18/python%E7%9A%84%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2022-05-18T00:52:37.000Z" itemprop="datePublished">2022-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/18/python%E7%9A%84%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">python的网站开发知识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h1><p>CS框架：<br>最早的软件都是运行在大型机上的，后来随着PC机的兴起，<strong>软件开始主要运行在桌面上</strong>，而<strong>数据库</strong>这样的软件运行在<strong>服务器端</strong>，这种Client&#x2F;Server模式（客户&#x2F;服务器模式）简称CS架构。<br>BS框架：<br>随着时间推移，CS架构不适合Web，最大的原因是<strong>Web应用程序的修改和升级非常迅速</strong>，而CS架构需要每个客户端逐个升级桌面App，因此，<strong>Browser&#x2F;Server</strong>模式（浏览器&#x2F;服务器模式）开始流行，简称BS架构。<br>在BS架构下，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。<strong>浏览器只需要请求服务器</strong>，获取Web页面，并<strong>把Web页面展示给用户</strong>即可。</p>
<ol>
<li>具有极强的交互性：web页面是用HTML编写的，HTML具有超强的表现力，服务端升级后，客户端无需任何部署就可以使用到新的版本</li>
<li>除了office和photoshop等大型软件，大部分软件（新浪的新闻、博客、微博等服务都是Web应用）</li>
</ol>
<p>Web开发经历过的几个阶段：</p>
<ol>
<li>静态Web页面：由文本编辑器直接编辑并生成静态的HTML页面，如果要修改Web页面的内容，就需要再次编辑HTML源文件</li>
<li>CGI：由于静态Web页面无法与用户交互，要处理用户发送的动态数据，出现了<strong>Common Gateway Interface</strong>，简称CGI，用C&#x2F;C++编写。</li>
<li>ASP&#x2F;JSP&#x2F;PHP：由于Web应用特点是修改频繁，而脚本语言由于开发效率高，与HTML结合紧密，因此，迅速取代了CGI模式。ASP是微软推出的用VBScript脚本编程的Web开发技术，而JSP用Java来编写脚本，PHP本身则是开源的脚本语言。</li>
<li>MVC：为了解决直接用脚本语言嵌入HTML导致的可维护性差的问题，Web应用也引入了<strong>Model-View-Controller</strong>的模式，来简化Web开发。ASP发展为ASP.Net，JSP和PHP也有一大堆MVC框架。</li>
</ol>
<p>与python的结合：</p>
<ol>
<li>Python的诞生历史比Web还要早，由于Python是一种解释型的脚本语言，开发效率高，所以非常适合用来做Web开发。</li>
<li>Python有上百种<strong>Web开发框架</strong>，有很多成熟的模板技术，选择Python开发Web应用，不但开发效率高，而且运行速度快。</li>
</ol>
<h2 id="HTTP协议简介"><a href="#HTTP协议简介" class="headerlink" title="HTTP协议简介"></a>HTTP协议简介</h2><p>浏览器和服务器之间的传输协议是HTTP</p>
<ol>
<li>HTML是一种用来定义网页的文本，会HTML，就可以编写网页；</li>
<li>HTTP是在网络上<strong>传输HTML的协议</strong>，用于<strong>浏览器和服务器的通信</strong>。</li>
</ol>
<p>略….</p>
<h2 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h2><p>网页就是HTML,网页中不但包含文字，还有图片、视频、Flash小游戏，有复杂的排版、动画效果，所以，HTML定义了一套语法规则，来告诉浏览器如何把一个丰富多彩的页面显示出来。<br>最简单的HTML的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 用一系列的Tag组成的</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Hello&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>CSS简介：<br>CSS是Cascading Style Sheets（层叠样式表）的简称，CSS<strong>用来控制HTML里的所有元素如何展现</strong>，比如，给标题元素<h1>加一个样式，变成48号字体，灰色，带阴影：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Hello&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    h1 &#123;</span><br><span class="line">      color: #333333;</span><br><span class="line">      font-size: 48px;</span><br><span class="line">      text-shadow: 3px 3px 3px #666666;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>JavaScript简介:<br>JavaScript是<strong>为了让HTML具有交互性而作为脚本语言添加的</strong>，JavaScript既可以<strong>内嵌到HTML中</strong>，也可以从<strong>外部链接到HTML中</strong>。如果我们希望当用户点击标题时把标题变成红色，就必须通过JavaScript来实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="selector-tag">h1</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="attribute">color</span>: <span class="number">#333333</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="attribute">font-size</span>: <span class="number">48px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="attribute">text-shadow</span>: <span class="number">3px</span> <span class="number">3px</span> <span class="number">3px</span> <span class="number">#666666</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">change</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;h1&#x27;</span>)[<span class="number">0</span>].<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;#ff0000&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">onclick</span>=<span class="string">&quot;change()&quot;</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>小结：</p>
<ol>
<li>如果要学习Web开发，首先要对HTML、CSS和JavaScript作一定的了解。HTML定义了页面的内容，CSS来控制页面元素的样式，而JavaScript负责页面的交互逻辑</li>
<li>讲解HTML、CSS和JavaScript就可以写3本书，对于优秀的Web开发人员来说，精通HTML、CSS和JavaScript是必须的，参考网址：<ol>
<li><a target="_blank" rel="noopener" href="http://www.w3schools.com/">http://www.w3schools.com/</a>       </li>
<li><a target="_blank" rel="noopener" href="http://www.w3school.com.cn/">http://www.w3school.com.cn/</a></li>
</ol>
</li>
<li>当我们用Python或者其他语言开发Web应用时，我们就是要<strong>在服务器端动态创建出HTML</strong>，这样，浏览器就会向不同的用户显示出不同的Web页面。</li>
</ol>
<h2 id="WSGI接口"><a href="#WSGI接口" class="headerlink" title="WSGI接口"></a>WSGI接口</h2><p>Web应用的本质就是：</p>
<ol>
<li>浏览器发送一个HTTP请求；</li>
<li>服务器收到请求，生成一个HTML文档；</li>
<li>服务器把HTML文档作为HTTP响应的Body发送给浏览器；</li>
<li>浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示。</li>
</ol>
<p>如何动态的生成HTML：</p>
<ol>
<li>底层代码由专门的服务器软件实现</li>
<li>我们用Python专注于生成HTML文档</li>
<li>避免接触到TCP连接、HTTP原始请求和响应格式，需要一个统一的接口（Web Server Gateway Interface，简称<strong>WSGI</strong>），让我们专心用Python编写Web业务.</li>
</ol>
<p>详细的实施过程后续感兴趣再继续学就行</p>
<h2 id="使用Web框架"><a href="#使用Web框架" class="headerlink" title="使用Web框架"></a>使用Web框架</h2><h2 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h2><h1 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h1><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h2 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h2><h2 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h2><h2 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h2><h1 id="使用MicroPython"><a href="#使用MicroPython" class="headerlink" title="使用MicroPython"></a>使用MicroPython</h1><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><h2 id="控制小车"><a href="#控制小车" class="headerlink" title="控制小车"></a>控制小车</h2><h2 id="遥控小车"><a href="#遥控小车" class="headerlink" title="遥控小车"></a>遥控小车</h2><h2 id="遥控转向"><a href="#遥控转向" class="headerlink" title="遥控转向"></a>遥控转向</h2><p>实战这一块是重头戏，也不是一时半会就能整明白的<br>目标：<br>一个博客网站，包含日志、用户和评论三大部分<br>慢慢的积累一点，建立个人的博客，可以使用比较成熟的开发框架flask  Django，也可以从最底层的代码开始构建数据库，构建web框架、构建ORM、构建MVC 构建API，到构建前端的页面CSS&#x2F;HTML,Javascript,DOM操作再到服务器的部署</p>
<h1 id="Day1-搭建开发环境"><a href="#Day1-搭建开发环境" class="headerlink" title="Day1 - 搭建开发环境"></a>Day1 - 搭建开发环境</h1><p>创建好了一个项目的目录结构，并同时建立git仓库并同步至Github，保证代码修改的安全<br>开发Web APP需要的第三方库：</p>
<ol>
<li>异步框架：aiohttp</li>
<li>前端模板引擎jinja2</li>
<li>MySQL的python异步驱动程序aiomysql:</li>
<li>轻量级标记语言Markdown, 将文本转换为有效的HTML</li>
</ol>
<h1 id="Day2-编写Web-APP骨架"><a href="#Day2-编写Web-APP骨架" class="headerlink" title="Day2-编写Web APP骨架"></a>Day2-编写Web APP骨架</h1><p>Web App建立在<strong>asyncio的基础上</strong>，用<strong>aiohttp</strong>写一个基本的app.py<br>经过参考别人的代码之后，基本已经算是可以到处相应的网页了，没有什么其他的问题。<br>这里把相关的代码贴在这里</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging;logging.basicConfig(level=logging.INFO)</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义服务器响应请求的的返回为 &quot;Awesome Website&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> web.Response(body=<span class="string">b&#x27;&lt;h1&gt;Awesome Website&lt;/h1&gt;&#x27;</span>, content_type=<span class="string">&#x27;text/html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立服务器应用，持续监听本地9000端口的http请求，对首页&quot;/&quot;进行响应</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    app = web.Application()</span><br><span class="line">    app.router.add_get(<span class="string">&#x27;/&#x27;</span>, index)</span><br><span class="line">    web.run_app(app, host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">9000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    init()</span><br></pre></td></tr></table></figure>

<h1 id="编写ORM"><a href="#编写ORM" class="headerlink" title="编写ORM"></a>编写ORM</h1><p>刚开始看这一块，发现这里面需要学习的地方还是有很多的，有些地方是需要自己花时间去慢慢来领悟的，不是那么快就可以真正搞清楚的，一时半会。总之也是跟着一起学习的一个过程。<br>对关系映射（object Realational Mapping）,是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术：<strong>通过使用描述对象与数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中</strong></p>
<p>在一个Web App中，所有数据，包括用户信息、发布的日志、评论等，都存储在数据库中。在awesome-python3-webapp中，我们选择MySQL作为数据库。<br>首先把常用的<strong>SELECT</strong>、<strong>INSERT</strong>、<strong>UPDATE</strong>和<strong>DELETE</strong>操作用函数封装起来。<br>Web框架使用了基于<strong>asyncio</strong>的<strong>aiohttp</strong>，这是基于协程的异步模型。在协程中，不能调用普通的同步IO操作，因为所有用户都是由一个线程服务的，协程的执行速度必须非常快，才能处理大量用户的请求。而耗时的IO操作不能在协程中以同步的方式调用，否则，等待一个IO操作时，系统无法响应任何其他用户。[异步编程的原则：一旦决定使用异步，系统的每一层都必须是异步的，开弓没有回头箭]<br>aiomysql为MySQL数据库提供了异步IO的驱动。</p>
<h2 id="创建连接池"><a href="#创建连接池" class="headerlink" title="创建连接池"></a>创建连接池</h2><p>创建一个全局的连接池，每个http请求都可以从连接池中直接获取数据库连接，可以不用频繁的打开和关闭数据库，能复用就尽量的复用</p>
<p>连接池由全局变量__pool存储，缺省的情况下将编码设置为utf8 ，自动提交事务</p>
<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>要执行SELECT语句，用select函数执行，需要传入SQL语句和SQL参数</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/18/python%E7%9A%84%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" data-id="claquc62n0016z0tk6dmw4z9i" data-title="python的网站开发知识" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-前缀和" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/17/%E5%89%8D%E7%BC%80%E5%92%8C/" class="article-date">
  <time class="dt-published" datetime="2022-05-17T04:24:00.000Z" itemprop="datePublished">2022-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/17/%E5%89%8D%E7%BC%80%E5%92%8C/">前缀和</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前缀和："><a href="#前缀和：" class="headerlink" title="前缀和："></a>前缀和：</h1><p>参考链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/260739067">https://zhuanlan.zhihu.com/p/260739067</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/48t0y13XB7URrkSR5A20Iw">https://mp.weixin.qq.com/s/48t0y13XB7URrkSR5A20Iw</a><br>这里我在写的时候还是需要注意关于原数组于前缀和数组的关系，自己也是做了一部分题目出来的，也不是完全什么都不懂的人，前缀和正好是原数组多一个。</p>
<ol>
<li>presum[i]就是num[0:i]的和（这里这里因为是python的语言，<strong>所以是不包含nums[i]的值</strong>，就是nums[i]前面的元素之和</li>
<li>下标索引为i~j之间的区间和&#x3D;presum[j+1]-presum<a href="l%E7%90%86%E8%A7%A3%E8%BF%99%E4%B8%80%E5%B1%82%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E9%97%AE%E9%A2%98%E5%B0%B1%E4%B8%8D%E5%A4%A7%E4%BA%86%EF%BC%8C%E4%BB%A3%E7%A0%81%E4%B9%9F%E5%B0%B1%E5%BE%88%E5%A5%BD%E5%86%99%E5%87%BA%E6%9D%A5%E3%80%82">i</a><br>用在求子数组和子串的问题上，求数列的和就是前n项和，技巧并不难，可以很好的处理数组区间的问题。<br><img src="https://runnerxr.github.io/post-images/1651905310576.png"><br>通过前缀和数组保存前n位的和，可以轻松的得到每个区间的和（index从0开始），有点类似于字符串匹配算法BM KMP中的next数组和suffix数组的作用</li>
</ol>
<p>相关练习题：</p>
<ol>
<li>leetcode 724. 寻找数组的中心索引</li>
<li>leetcode 523 连续的子数组和</li>
<li>leetcoad 560 和为K的子数组</li>
<li>leetcoad974-和可被K整除的子数组；</li>
</ol>
<h1 id="leetcode-724-寻找数组的中心索引"><a href="#leetcode-724-寻找数组的中心索引" class="headerlink" title="leetcode 724. 寻找数组的中心索引"></a>leetcode 724. 寻找数组的中心索引</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己做的时候的思路如下，相对比较笨，先构建出前缀和数组，然后根据题目的意思找出相应的等量关系</span></span><br><span class="line"><span class="comment"># 这样做太浪费空间了，如果数值更大的话，会超出内存限制</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        presum=[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 创建出前缀和数组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="built_in">sum</span>+=nums[i]</span><br><span class="line">            presum.append(<span class="built_in">sum</span>)</span><br><span class="line">        <span class="built_in">print</span>(presum)</span><br><span class="line">        <span class="comment"># 对前缀和数组进行遍历</span></span><br><span class="line">        <span class="comment"># 如果发现抛开第一个数的所有和为0</span></span><br><span class="line">        <span class="keyword">if</span> presum[n]-nums[<span class="number">0</span>]==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 如果发现相邻两个前缀和等于最后一个前缀和</span></span><br><span class="line">            <span class="keyword">if</span> presum[i-<span class="number">1</span>]+presum[i]==presum[n]:</span><br><span class="line">                <span class="keyword">return</span> i-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>对该方法进行改进，可以优化很多空间，不需要每次计算左半部分和右半部分的和，可以根据上一次计算的做左半部分和右半部分的和，以及新增或删除元素来获得当前左半部分和右半部分的和。合理的利用了数组的切分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 第一个值</span></span><br><span class="line">        a=<span class="built_in">sum</span>(nums[:<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 对切开第一个数之后的数组求和</span></span><br><span class="line">        b=<span class="built_in">sum</span>(nums[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 如果发现a==b，直接返回对应的i</span></span><br><span class="line">            <span class="keyword">if</span> a==b:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="comment"># 继续向右移动，求左右两部分</span></span><br><span class="line">            <span class="comment"># 这里很容易忽略，a需要将nums[i]加入，b需要将nums[i+1]剔除</span></span><br><span class="line">            a+=nums[i]</span><br><span class="line">            b-=nums[i+<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 当遍历到最后一个元素，即循环结束</span></span><br><span class="line">        <span class="keyword">if</span> a==b:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="leetcode-523-连续的子数组和"><a href="#leetcode-523-连续的子数组和" class="headerlink" title="leetcode 523 连续的子数组和"></a>leetcode 523 连续的子数组和</h1><p><img src="https://runnerxr.github.io/post-images/1651980505027.png"><br>理清题目的要求：</p>
<ol>
<li>子数组的大小至少为2</li>
<li>子数组元素总和为k的倍数，如果存在返回true，如果不存在就返回false<br>首先想到的就是用暴力解法，发现果然是超时的，只能通过一部分的案例<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>: </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkSubarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 做题步骤</span></span><br><span class="line">        <span class="comment"># 1. 首先定义一个子数组</span></span><br><span class="line">        <span class="comment"># 2 .判断子数组的和是否等于k的整数倍</span></span><br><span class="line">        <span class="comment"># 3. 如果不是，就不停的添加新的元素重新计算</span></span><br><span class="line">        n= <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 外层固定数组的长度，内存表示子数组第一个下标</span></span><br><span class="line">        <span class="comment"># 外层循环是子数组的长度,最短有两个，最长有n个</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 内层循环时子数组的第一个值的下标,下标的范围从0~n-i-1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-i+<span class="number">1</span>):</span><br><span class="line">                a=<span class="built_in">sum</span>(nums[j:j+i])</span><br><span class="line">                <span class="comment"># 如果a除以k的余数为0</span></span><br><span class="line">                <span class="keyword">if</span> a%k==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 如果循环结束周仍然没有返回（没有找到和为k的倍数的）</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">2</span> <span class="keyword">and</span> <span class="built_in">sum</span>(nums)%k==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<strong>现在要对代码进行相应的优化，用到前缀和和哈希表的知识</strong><br>看到几项的和为条件的判断，考虑前缀和，同时引入同余定理（当两个数除以每个数的余数相等，两者相减之后肯定可以被该数整除，这里其实可以简单的知道一些证明的过程），采用前缀和方式进行判断，后面的数字总和必然包含它之前的内容，维护一个hash表，记录{余数：下标}，存在前n个数字恰好被k整除的情况，预制一个字典{0：-1}来规避这样的问题<br><img src="https://runnerxr.github.io/post-images/1651915864334.png"><br>在利用的时候，没有把列表全部更新一遍，只要更新列表每个字段为前缀和内容再二次判断（自己理解：如果全部循环必然会很费时间，更新presum遍历一遍，用的时候可能还要再遍历一遍），<strong>所以在需要多次循环列表的时候，我们只需要维护一个初始值为0的数字，每次加等就可以</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写出符合自己的方法</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkSubarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 创建字典</span></span><br><span class="line">        hashmap=<span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 添加一个初始值,添加初始值的原因保证和数组的索引同步（这里的构造方法和560题的思考方式是一致的，注意运用的情况）</span></span><br><span class="line">        hashmap[<span class="number">0</span>]=-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 一边构造前缀和一边用哈希表进行查找</span></span><br><span class="line">        presum=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> index,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            presum+=num</span><br><span class="line">            <span class="comment"># 取前缀和</span></span><br><span class="line">            <span class="comment"># 整除k的余数</span></span><br><span class="line">            rem=presum%k</span><br><span class="line">            <span class="comment"># 如果发现该余数不在哈希表中,就将余数与当前的索引作为键和值加入hashmap中</span></span><br><span class="line">            <span class="keyword">if</span> rem <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[rem]=index</span><br><span class="line">            <span class="comment"># 如果发现余数已经在哈希表中,这个时候就要看此时的索引与之前的索引的差值有没有大于等于2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 用get()函数获取之前的索引</span></span><br><span class="line">                i = hashmap.get(rem)</span><br><span class="line">                <span class="comment">#print(i)</span></span><br><span class="line">                <span class="comment"># 比较现在的索引与原索引的差值</span></span><br><span class="line">                <span class="keyword">if</span> index -i &gt;=<span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    res=Solution().checkSubarraySum(nums,<span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad-560-和为K的子数组"><a href="#leetcoad-560-和为K的子数组" class="headerlink" title="leetcoad 560 和为K的子数组"></a>leetcoad 560 和为K的子数组</h1><p>参考链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/python3-by-wu-qiong-sheng-gao-de-qia-non-w6jw/">https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/python3-by-wu-qiong-sheng-gao-de-qia-non-w6jw/</a><br>以下的解法都是在实操的层面不断的进行相应的优化的，其实也是十分的灵活的，所以自己要不断的敲才能认真的掌握。在平时的练习的时候确实是值得反复的思考，让自己的思维活跃起来，真正的把前缀和运用好。<br><strong>储备知识</strong>：怎么求一个数组的连续子数组（只是为了理解题意，也是为后面的代码做出一定的参考）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nums=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">n=<span class="built_in">len</span>(nums)</span><br><span class="line">subnums=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">        subnums.append(nums[i:j+<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(subnums)</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">[[<span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>]]</span><br></pre></td></tr></table></figure>
<p>暴力的解法，是有一些案例通不过的，并且是超时的（自己想的写法）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 90个案例通过61个</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 外层循环表示数组的长度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 内层循环，记录子数组第一个下标的变化范围</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n-i+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 统计子数组的和</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span>(nums[j:j+i])==k:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<p>仍然是暴力解法（可能也是最直接的理解层面上的东西）<br>时间复杂度O(n^3):两层循环还有一层求和的过程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                <span class="comment"># 充分利用了nums切片的性质</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span>(nums[i:j+<span class="number">1</span>])==k:</span><br><span class="line">                    count +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<p>在上面的基础上继续进行优化：将时间复杂度优化为O(n^2)<br>这里优化的点在于：在求nums[i:j+1]的下一次nums[i:j+1+1]的时候，不需要哉从i开始算了，直接哉上一次的结果上+nums[j+1],但是记住内层循环结束的时候需要将sum置0（如果不置0，会一直累加，这样并不是区间的和）<br>双循环，仍然是超出时间限制,90个案例通过72个</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                <span class="built_in">sum</span>+=nums[j]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span>==k:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">            <span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<p>要计算i和j之间的和：nums[i]+nums[i+1]+⋯+nums[j]<br>可以看作是nums[0]+nums[1]+⋯+nums[i]+nums[i+1]+⋯+nums[j]   减去   nums[0]+nums[1]+⋯+nums[i−1]<br>也即：preSum[j]−preSum[i−1]<br>操作如下：先遍历一次数组，求出前缀和数组，用这个数组代替最开始的暴力解法的sum函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        subnums=[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 求前缀和数组的过程</span></span><br><span class="line">        temp=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            temp+=nums[i]</span><br><span class="line">            subnums.append(temp)</span><br><span class="line">        <span class="comment"># print(subnums)</span></span><br><span class="line">        <span class="comment"># 求和为k的连续子数组出现的次数</span></span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 这里要注意相应的下标,subnums的长度为n+1,下标从1开始</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> subnums[j]-subnums[i-<span class="number">1</span>]==k:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">    res=Solution().subarraySum(nums,<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<p>再进一步优化，边计算前缀和边统计这个过程，只关心次数，不关心具体的解，用哈希表加速运算，由于保存了之前相同前缀和的数目，计算区间总数的时候不是一个个加的，时间复杂度减低到O(N)<br>优化的过程也要采用<strong>前缀和+hashmap的思路</strong>，<strong>有点两数之和的味道</strong>，将所有的<strong>前缀和</strong>和该<strong>前缀出现的次数</strong>存放到字典中，用下面的这张图来进行辅助理解(这种思路也就是在做题的时候才会认认真真的想的到的方式，也是一种很巧妙的方式，主要在于理解哈希表的存放数据)<br><img src="https://runnerxr.github.io/post-images/1651941152655.png"><br>计算到i位置的前缀和（包含i）-目标k在字典中出现的次数，假设出现过m次，代表<strong>第i位以前</strong>（不含i）<strong>有m个连续子数组的和为presum-k</strong>。每一个都可以和presum组成为presum-(presum-k)&#x3D;k<br>备注：自己实操的时候才发现有几个大坑，自己可能平时都没有怎么注意到这个问题，对if else语句的理解并不是特别的到位，特别是一些关键的位置，这里贴两份代码，其中一份是错的（用图片的形式），另一份是正确的。这种错误错误坚决不能够再犯了。<br><img src="https://runnerxr.github.io/post-images/1651979391370.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确的代码</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 采用前缀和+哈希表</span></span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 创建字典，字典存储的是前缀和以及前缀和出现的次数，并将0：1加入字典中</span></span><br><span class="line">        <span class="comment"># 加入的原因：在开始的时候，和为0的情况发生了一次（这是比较容易忽略的地方）</span></span><br><span class="line">        hashmap=&#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line">        <span class="comment"># 统计前缀和</span></span><br><span class="line">        presum=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 对nums进行遍历，并统计相应的前缀和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            presum+=nums[i]</span><br><span class="line">            <span class="comment"># 查看presum-k是否在hashmap中存在，如果存在的话，那么presum-k出现的次数就是连续子数组为k出现的次数</span></span><br><span class="line">            <span class="keyword">if</span> presum-k <span class="keyword">in</span> hashmap:</span><br><span class="line">                count+=hashmap[presum-k]</span><br><span class="line">            hashmap[presum]=hashmap.get(presum,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    res=Solution().subarraySum(nums,<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<h1 id="leetcoad974-和可被K整除的子数组"><a href="#leetcoad974-和可被K整除的子数组" class="headerlink" title="leetcoad974-和可被K整除的子数组"></a>leetcoad974-和可被K整除的子数组</h1><p>还是一样，先是常规思路</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraysDivByK</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                <span class="built_in">sum</span>+=nums[j]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span>%k==<span class="number">0</span>:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">            <span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<p>先将前缀和处理，然后计算子数组和能够被k整除的情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraysDivByK</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        presum=[<span class="number">0</span>]</span><br><span class="line">        temp=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            temp+=nums[i]</span><br><span class="line">            presum.append(temp)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 在前缀和数组中找子数组的和可以被k整除的情况，在区间[i:j+1]的范围内presum[j]-presum[i]</span></span><br><span class="line">        <span class="comment"># 外层循环是前缀和数组的下标，从下标0开始,总共有n+1个数，n个下标</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 内层循环时，下标从i+1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 计算子数组的和是否可以被k整除</span></span><br><span class="line">                <span class="keyword">if</span> (presum[j]-presum[i])%k==<span class="number">0</span>:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">                    <span class="comment"># 这里多加了一行满足条件的子数组的打印，可以更好的理解这里的过程</span></span><br><span class="line">                    <span class="built_in">print</span>(nums[i:j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,-<span class="number">2</span>,-<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">    res=Solution().subarraysDivByK(nums,<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对分步的输出结果</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, -<span class="number">2</span>, -<span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">0</span>, -<span class="number">2</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">0</span>, -<span class="number">2</span>, -<span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">0</span>, -<span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, -<span class="number">2</span>, -<span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">[-<span class="number">2</span>, -<span class="number">3</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>采用前缀和+哈希表的方式<br>这里贴一张自己的理解过程，终于在理解的基础上通过了这道题，并且可以说对哈希表有了一个比较深的认识<br><img src="https://runnerxr.github.io/post-images/1651996690685.png"><br><img src="https://runnerxr.github.io/post-images/1651996705610.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraysDivByK</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 采用前缀和+哈希表的知识</span></span><br><span class="line">        <span class="comment"># 构建一个哈希表，并传入0：1</span></span><br><span class="line">        <span class="comment"># 其中哈希表中存入的是余数：余数出现的次数</span></span><br><span class="line">        hashmap=&#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line">        <span class="comment"># 统计能够被k整除的数目</span></span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 统计前缀和</span></span><br><span class="line">        presum=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 开始进行遍历并统计，采用边遍历，边哈希查找的方式</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 更新前缀和</span></span><br><span class="line">            presum+=num</span><br><span class="line">            <span class="comment"># 取前缀和与k除的余数</span></span><br><span class="line">            rem=presum%k</span><br><span class="line">            <span class="comment"># 采用同余定理，并用哈希表进行查找</span></span><br><span class="line">            <span class="keyword">if</span> rem <span class="keyword">in</span> hashmap:</span><br><span class="line">                count+=hashmap[rem]</span><br><span class="line">            hashmap[rem]=hashmap.get(rem,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/17/%E5%89%8D%E7%BC%80%E5%92%8C/" data-id="claquc62x001sz0tk4rfx45bk" data-title="前缀和" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-收集几道考过的题目" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/11/%E6%94%B6%E9%9B%86%E5%87%A0%E9%81%93%E8%80%83%E8%BF%87%E7%9A%84%E9%A2%98%E7%9B%AE/" class="article-date">
  <time class="dt-published" datetime="2022-05-10T17:14:09.000Z" itemprop="datePublished">2022-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/11/%E6%94%B6%E9%9B%86%E5%87%A0%E9%81%93%E8%80%83%E8%BF%87%E7%9A%84%E9%A2%98%E7%9B%AE/">收集几道考过的题目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="整理题目一："><a href="#整理题目一：" class="headerlink" title="整理题目一："></a>整理题目一：</h1><p>幼儿园两个班的小朋友在排队时混在了一起，每位小朋友都知道自己是否与前面一位小朋友同班，<strong>请你帮忙把同班的小朋友找出来</strong>。<br>小朋友的编号是整数，与前一位小朋友同班用Y表示，不同班用N表示。<br><strong>输入描述：</strong><br>输入为空格分开的小朋友编号和是否同班标志。<br><strong>输出描述：</strong><br>输出为两行，每一行记录一个班小朋友的编号，编号用空格分开，且：<br>1.编号需按照升序排列。<br>2.若只有一个班的小朋友，第二行为空行。</p>
<p>比如：<br>输入 ：<br>1&#x2F;N 2&#x2F;Y 3&#x2F;N 4&#x2F;Y</p>
<p>输出 ：<br>1 2<br>3 4<br><strong>考察知识点</strong>：并查集</p>
<h1 id="破解保险箱密码"><a href="#破解保险箱密码" class="headerlink" title="破解保险箱密码"></a>破解保险箱密码</h1><p>小明拥有一个保险箱，但是忘记了密码。已知密码在范围在0~9中，且每位数字仅出现一次。现小明只记得密码是由序列s[]里的数字组成(s[i] ∈ [0, 9], s.length ∈ [1, 10]s[i]∈[0,9],s.length∈[1,10]),密码最少为N位(N ∈ [0, 10]N∈[0,10])，且密码各位上的数字，是<strong>从左到右依次递增的</strong>。<br>已知密码不会为空，请输出所有可能出现的密码。</p>
<p>输出结果要求: 输出结果需要按位数数字从小到大排列(即字典序)。</p>
<h1 id="给你一个数字让你把他拆分成两个素数的乘积"><a href="#给你一个数字让你把他拆分成两个素数的乘积" class="headerlink" title="给你一个数字让你把他拆分成两个素数的乘积"></a>给你一个数字让你把他拆分成两个素数的乘积</h1><p>作者：牛客861261412号<br>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/952553?toCommentIpt=1">https://www.nowcoder.com/discuss/952553?toCommentIpt=1</a><br>来源：牛客网</p>
<p>第一题数组去重排序，就是把一个数组重复的全删除，然后每个数组只出现一次然后从高到低排序。<br>第二题停车场车辆统计，也是数组相关的问题，就是，三种车，大车中车小车，占3，2，1个地方，然后判定最少可以停多少辆车。<br>第三题叠级木，大概就是用数组堆叠组成一道墙。然后用给定的数组堆墙。<br>三道题都遇到了原题，很简单。 </p>
<h1 id="大侠疗伤"><a href="#大侠疗伤" class="headerlink" title="大侠疗伤"></a>大侠疗伤</h1><p>大侠受了伤，医生开了m (m &gt;&#x3D; 3 &amp;&amp; m &lt;&#x3D; 37)个药（1…m)，要全部服用才能完全康复，大侠每天最多吃n个药，每个药之间存在约束关系 例如[1, 2]表示吃药2之前必须先吃药1，并且存在约束关系的药禁止在同一天服用，不存在循环约束</p>
<p>输入：</p>
<p>m<br>n<br>k &#x2F;&#x2F;约束数量<br>[a, b]… &#x2F;&#x2F; k个约束项</p>
<p>输出：</p>
<p>一个整数，表示大侠至少需要服药几天才能完全康复</p>
<p>第一行输入二维数组的行数和列数，以空格区分。然后输入矩阵，矩阵元素之间 同样以空格作为分隔符。<br>求矩阵中和最大的矩阵。例如<br>输入： 3 3<br>-1 3 -1<br>-3 2 3<br>4 5 3<br>输出<br>2 3<br>5 3</p>
<p>二维前缀和</p>
<p>0-1背包问题</p>
<p>分割等和子集</p>
<p>描述: 给定二维数组 jobs[n][2] 表示需要完成的n个工作,<br>其中第一维表示该工作最多等待的时间,<br>第二维表示在等待时间内完成该工作可以获得的积分,<br>每个工作完成需要单位1的时间, 超过等待时间则不能获得该积分, 但是该任务也需要完成<br>求从0时刻开始, 一次只能干一个工作, 完成这些工作最多能获得多少积分</p>
<p>描述: 给定长度为n的数组nums, 1 &lt;&#x3D; n &lt;&#x3D; 100,<br>求把nums均分成两组的方案, 若无则输出-1, 否则输出均分数和任意一种方案<br>例如 nums &#x3D; [3,3,4,5,7]<br>输入:<br>5<br>3 3 4 5 7<br>输出:<br>11<br>4 7<br>3 3 5</p>
<p>有三个团队共同完成M个项目 给定三个团队的人力总和值 对于某个项目需要多个团队共同投入完成<br>每个项目有预估价值 在人力允许的范围内 求价值最大<br>输入<br>项目个数：m(0&lt;m&lt;&#x3D;20)<br>三个团队人力总和:s1,s2,s3(0&lt;si&lt;&#x3D;1000)<br>每个项目预估价值:v1v2..vn(0&lt;vi&lt;&#x3D;1000000)<br>每个项目需要人力:<br>输出<br>最大价值</p>
<p>样例1<br>输入:2 (2个项目)<br>100 100 100 (三个团队各自人力总和)<br>10000 8000 (每个项目预估价值)<br>60 60 60 (第一个项目对于三个团队人力需求)<br>60 60 60 (第二个…..)<br>输出：10000</p>
<p>后来想起来好像是个三维的0-1背包 三个用例都过了 不知道这样写有问题没 大佬帮忙看看</p>
<p>计算礼品发放的最小分组数目</p>
<p>又到了一年的末尾，项目组让小明负责新年晚会的小礼品发放工作。为使得参加晚会的同时所获得的小礼品价值相对平衡，需要把小礼品根据价格进行分组，但每组最多只能包括两件小礼品，并且每个分组的价格总和不能超过一个价格上限。为了保证发放小礼品的效率，小明需要找到分组数目最少的方案。</p>
<p>你的任务是写一个程序，找出分组数最少的分组方案，并输出最少的分组数目。<br>输入</p>
<p>第一行数据为分组礼品价格之和的上限<br>第二行数据为每个小礼品的价格，按照空格隔开，每个礼品价格不超过分组价格和的上限<br>输出</p>
<p>输出最小分组数量</p>
<p>样例</p>
<p>输入： 5<br>1 2 5<br>输出： 2</p>
<p>&#x2F;&#x2F; 疫情期间，需要大家保证一定的社交距离，公司组织开交流会议，座位有一排共N个座位，编号分别为[0…N-1]，要求员工一个接着一个进入会议室，<br>&#x2F;&#x2F; 并且可以在任何时候离开会议室。<br>&#x2F;&#x2F; 满足：每当一个员工进入时，需要坐到最大社交距离（最大化自己和最近其他人的距离）的座位；如果有多个这样的座位，则坐在索引最小的那个位置。<br>&#x2F;&#x2F; 输入描述：<br>&#x2F;&#x2F; 会议座位总数seatNum,(1&lt;&#x3D;seatNum&lt;&#x3D;500)<br>&#x2F;&#x2F; 员工的进出顺序seatOrLeave数组，元素值为1；表示进场，元素值为负数，表示出场（特殊：位置0的员工不会离开），例如-4表示坐在位置4的员工离<br>&#x2F;&#x2F; 开（保证有员工坐在该座位上）<br>&#x2F;&#x2F; 输出描述：<br>&#x2F;&#x2F; 最后进来员工，他会坐在第几个位置，如果位置已满，则输出-1<br>&#x2F;&#x2F; 示例1 输入输出实例仅供调试，后台判题数据一般不包含实例<br>&#x2F;&#x2F; 输入<br>&#x2F;&#x2F; 10<br>&#x2F;&#x2F; [1,1,1,1,-4,1]<br>&#x2F;&#x2F; 输出<br>&#x2F;&#x2F; 5<br>&#x2F;&#x2F; 说明<br>&#x2F;&#x2F; seat -&gt; 0,坐在任何位置都行，但是要给他安排索引最小的位置，也就是座位0。<br>&#x2F;&#x2F; seat -&gt; 9,要和旁边的人距离最远，也就是座位9。<br>&#x2F;&#x2F; seat -&gt; 4,要和旁边的人距离最远，应该做到中间，也就是座位4。<br>&#x2F;&#x2F; seat -&gt; 2,员工最后坐在2号座位上。<br>&#x2F;&#x2F; leave(4),4号座位的员工离开。<br>&#x2F;&#x2F; seat -&gt; 5,员工最后坐在5号座位上。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/11/%E6%94%B6%E9%9B%86%E5%87%A0%E9%81%93%E8%80%83%E8%BF%87%E7%9A%84%E9%A2%98%E7%9B%AE/" data-id="claquc63d002mz0tk5iw3dwn1" data-title="收集几道考过的题目" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-滑动窗口" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/10/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-09T16:32:05.000Z" itemprop="datePublished">2022-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/10/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">滑动窗口</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>滑动窗口的思路要把它的内涵给摸透，摸清楚，才是最重要的，遇到做题会举一反三<br>滑动窗口也是属于双指针的范畴，也是比较难得掌握的一点的部分，必须自己有十分清晰的做题套路。<br>滑动问题包含一个滑动窗口，它是一个运行在一个大数组上的子列表，该数组是一个底层元素集合。一般情况下就是<strong>使用这个窗口在数组的 合法区间 内进行滑动</strong>，同时 <strong>动态地</strong> 记录一些有用的数据，很多情况下，减少while的循环，<strong>能够极大地提高算法地效率</strong>。<br>自己在练习的基础上，多多的总结与刷题，一些常用的技巧要能够真正掌握清楚才行。<br>参考链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1V44y1s7zJ?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1V44y1s7zJ?spm_id_from=333.337.search-card.all.click</a><br>这些题目有一个共同点：<br>关键字：<br><strong>满足XXX条件</strong>（计算结果，出现次数，同时包含等）<br>最长&#x2F;最短的<br>子串、子数组、子序列、最长、最小、长度最小等<br><strong>滑动窗口的使用思路（寻找最长）：</strong></p>
<ol>
<li>核心：左右双指针（L和R）在起始点，R向右逐位滑动循环</li>
<li>每次滑动的过程中<ol>
<li>如果窗口的元素满足要求，R向右扩大窗口，并更新最优结果</li>
<li>窗口内不满足要求，L向右缩小窗口</li>
</ol>
</li>
<li>R到达结尾的地方<br><strong>寻找最短:</strong></li>
<li>核心：左右双指针（L和R）在起始点，R向右逐位滑动循环</li>
<li>每次滑动的过程中<ol>
<li>如果窗口元素满足条件，<strong>L向右缩小窗口</strong>，并更新最优结果</li>
<li>如果：窗内的元素不满足要求，R向右扩大窗口</li>
</ol>
</li>
<li>R达到结尾<br><strong>做题的答题框架</strong><br>直接模板化，两者在内层循环中不太一样，一旦是想用滑动窗口的话就要想到这个模板，后期这个模板要成为自己的做题的一个常用套路<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最长的情况：</span></span><br><span class="line">初始化left right result bestResult</span><br><span class="line"><span class="keyword">while</span> 右指针没有到结尾:</span><br><span class="line">    窗口扩大，加入right对应的元素，更新当前result</span><br><span class="line">    <span class="keyword">while</span> result不满足要求:</span><br><span class="line">        窗口缩小，移除left对应的元素，left右移</span><br><span class="line">    更新最优结果bestResult</span><br><span class="line">    right+=<span class="number">1</span></span><br><span class="line">返回bestResult</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最短的情况：</span></span><br><span class="line">初始化left right result bestResult</span><br><span class="line"><span class="keyword">while</span> 右指针没有到结尾:</span><br><span class="line">    窗口扩大，加入right对应的元素，更新当前result</span><br><span class="line">    <span class="keyword">while</span> result满足要求:</span><br><span class="line">        更新最优结果bestResult</span><br><span class="line">        窗口缩小，移除left对应的元素，left右移</span><br><span class="line">    right+=<span class="number">1</span></span><br><span class="line">返回bestResult</span><br></pre></td></tr></table></figure>
<p>结合labuladong的模板，也做一点相应的理解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">left,right=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> right &lt;s.size:</span><br><span class="line">    <span class="comment"># 增大窗口</span></span><br><span class="line">    window.add(s[right])</span><br><span class="line">    right+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> window needs shrink:</span><br><span class="line">        <span class="comment"># 缩小窗口</span></span><br><span class="line">        window.remove(s[left])</span><br><span class="line">        left+=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>难点：细节的处理，</p>
<ol>
<li>何时向窗口中添加新元素</li>
<li>如何缩小窗口</li>
<li>在滑动窗口的哪个阶段更新结果</li>
</ol>
<h1 id="主要解决以下的一些题目："><a href="#主要解决以下的一些题目：" class="headerlink" title="主要解决以下的一些题目："></a>主要解决以下的一些题目：</h1><ol>
<li><strong>leetcoad3：无重复字符的最长子串</strong>(middle)</li>
<li><strong>leetcoad209：长度最小的子数组</strong>(middle)</li>
<li>** leetcoad219 存在重复元素II**（middle）</li>
<li><strong>leetcoad76-最小覆盖子串</strong>（hard）</li>
<li><strong>leetcoad438:找到字符串中所有字母异位词</strong>(middle)</li>
<li><strong>leetcoad567:字符串的排列</strong>(middle)</li>
<li><strong>leetcoad239:滑动窗口的最大值</strong>（hard）</li>
<li>leetcoad30-串联所有单词的子串（hard）</li>
<li>leetcoad187-重复的DNA序列</li>
<li>leetcoad643：子数组最大平均数（之前没有通过的）</li>
<li>leetcaod1456：定长子串中元音的最大数组</li>
</ol>
<h1 id="leetcoad-3：无重复字符的最长子串"><a href="#leetcoad-3：无重复字符的最长子串" class="headerlink" title="leetcoad-3：无重复字符的最长子串"></a>leetcoad-3：无重复字符的最长子串</h1><p>题目描述：给定一个字符串 s ，请你找出其中<strong>不含有重复字符的 最长子串</strong> 的长度。<br>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p>输入: s &#x3D; “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p>输入: s &#x3D; “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p>滑动窗口也是属于双指针的范畴，也是比较难得掌握的一点的部分。<br>滑动问题包含一个滑动窗口，它是一个运行在一个大数组上的子列表，该数组是一个底层元素集合。一般情况下就是<strong>使用这个窗口在数组的 合法区间 内进行滑动</strong>，同时 <strong>动态地</strong> 记录一些有用的数据，很多情况下，<strong>能够极大地提高算法地效率</strong>。自己在练习的基础上，多多的总结与刷题，一些常用的技巧要能够真正掌握清楚才行。<br>参考链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1V44y1s7zJ?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1V44y1s7zJ?spm_id_from=333.337.search-card.all.click</a><br><strong>一些关键的字眼</strong>：</p>
<ol>
<li>满足XXX条件（计算结果，出现次数，同时包含等）</li>
<li>最长&#x2F;最短的</li>
<li>子串、子数组、子序列、最长、最小、长度最小等</li>
</ol>
<p><strong>滑动窗口的使用思路（寻找最长）：</strong></p>
<ol>
<li>核心：左右双指针（L和R）在起始点，R向右逐位滑动循环</li>
<li>每次滑动的过程中<ul>
<li>如果窗口的元素满足要求，R向右扩大窗口，并更新最优结果</li>
<li>窗口内不满足要求，L向右缩小窗口</li>
</ul>
</li>
<li>R到达结尾的地方</li>
</ol>
<p><strong>寻找最短:</strong></p>
<ol>
<li>核心：左右双指针（L和R）在起始点，R向右逐位滑动循环</li>
<li>每次滑动的过程中<ol>
<li>如果窗口元素满足条件，<strong>L向右缩小窗口</strong>，并更新最优结果</li>
<li>如果窗内的元素不满足要求，R向右扩大窗口</li>
</ol>
</li>
<li>R达到结尾</li>
</ol>
<p><strong>做题的答题框架</strong><br>直接模板化，两者在内层循环中不太一样，一旦是想用滑动窗口的话就要想到这个模板，后期这个模板要成为自己的做题的一个常用套路</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最长的情况：</span></span><br><span class="line">初始化left right result bestResult</span><br><span class="line"><span class="keyword">while</span> 右指针没有到结尾:</span><br><span class="line">    窗口扩大，加入right对应的元素，更新当前result</span><br><span class="line">    <span class="keyword">while</span> result不满足要求:</span><br><span class="line">        窗口缩小，移除left对应的元素，left右移</span><br><span class="line">    更新最优结果bestResult</span><br><span class="line">    right+=<span class="number">1</span></span><br><span class="line">返回bestResult</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最短的情况：</span></span><br><span class="line">初始化left right result bestResult</span><br><span class="line"><span class="keyword">while</span> 右指针没有到结尾:</span><br><span class="line">    窗口扩大，加入right对应的元素，更新当前result</span><br><span class="line">    <span class="keyword">while</span> result满足要求:</span><br><span class="line">        更新最优结果bestResult</span><br><span class="line">        窗口缩小，移除left对应的元素，left右移</span><br><span class="line">    right+=<span class="number">1</span></span><br><span class="line">返回bestResult</span><br></pre></td></tr></table></figure>
<p><strong>难点：细节的处理</strong></p>
<ol>
<li>何时向窗口中添加新元素</li>
<li>如何缩小窗口</li>
<li>在滑动窗口的哪个阶段更新结果</li>
<li>如何进行结果的调试（特别是做题的时候）</li>
</ol>
<p><strong>以无重复字符的最长子串为例子</strong><br>题目描述：给定一个字符串 s ，请你找出其中<strong>不含有重复字符的 最长子串</strong> 的长度。<br>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p>输入: s &#x3D; “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p>输入: s &#x3D; “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p>回顾过最长回文子串的题目，发现和这题很像，这里简单回顾一下那道题的做法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果是采用暴力的解法：<br>遍历字符串，然后找到所有的子串（长度从1~该字符串的长度），判断每一个”子串”是否有重复字符，最终得到无重复最长子串。计算所有的子串的时间复杂度是O(n^2),然后<strong>再判断一个字符串中是否有重复的字符</strong>，又要从头遍历一遍该字符串，最终的时间复杂度为O(n^3).<br>相应的复杂度比较的高。<br>比如光是要求出字符串的子串，这种方式，这里演示一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写一个函数，用于找出一个字符串的所有子串</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="comment"># 定义一个数组用来</span></span><br><span class="line">    result=[]</span><br><span class="line">    <span class="comment"># 外层循环表示子串的起始位置</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="comment"># 内层循环表示子串的长度</span></span><br><span class="line">        <span class="keyword">for</span> length <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-start):</span><br><span class="line">            result.append(s[start:start+length+<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 循环结束，返回所有的结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">s=<span class="string">&#x27;abcde&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(sub(s))</span><br><span class="line"><span class="comment"># 打印结果如下：</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;abcd&#x27;</span>, <span class="string">&#x27;abcde&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;bc&#x27;</span>, <span class="string">&#x27;bcd&#x27;</span>, <span class="string">&#x27;bcde&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;cd&#x27;</span>, <span class="string">&#x27;cde&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;de&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>如果是按照先求子串，再求不重复的子串，最后求最长的，这样的复杂度太高了。<br>这里再提供了一种暴力解法的思路（可以通过）：<br>通过比较相邻的元素，在不相等情况下保证新加入的元素和之前的字符串里面的元素没有重复，用count数组来记录无重复字符的子串的长度，循环找出所有的无重复字符的子串，找出其中最大的返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="comment"># count记录的是无重复字符的子串长度，初始值为1</span></span><br><span class="line">        count=<span class="number">1</span></span><br><span class="line">        subnum=[]</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;<span class="built_in">len</span>(s)-<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 如果相邻的元素不相等，并且新加入的元素不在前面的字符串里面</span></span><br><span class="line">            <span class="keyword">if</span> s[i]!=s[i+<span class="number">1</span>] <span class="keyword">and</span> s[i+<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> s[i+<span class="number">1</span>-count:i+<span class="number">1</span>]:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 将当前的子串的长度加入到subnum数组中</span></span><br><span class="line">                subnum.append(count)</span><br><span class="line">                <span class="comment"># 同时要重新开始计算无重复字符的子串的长度</span></span><br><span class="line">                count=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 字符的索引值也要重新开始计算</span></span><br><span class="line">                <span class="comment"># 这里索引值的更新很巧妙，更新的索引值都是从无重复字符的子串的长度开始的</span></span><br><span class="line">                i=<span class="built_in">len</span>(subnum)</span><br><span class="line">        <span class="comment"># 循环结束后输出最大的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(subnum)       </span><br></pre></td></tr></table></figure>

<p>下面采用滑动窗口的思路来解题（因为这种思路广泛用于字符中的，所以也是必须要掌握的）<br>分析题目是求最长的情况，直接套用最长时候的模板，以下的这个版本可能不是那么直观</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 套用最长的情况的模板</span></span><br><span class="line">        <span class="comment"># 初始化左右指针，过程结果以及最优结果</span></span><br><span class="line">        left,right,length,max_length=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="comment"># 定义一个哈希set,用于储存</span></span><br><span class="line">        hashset=<span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># 外层的while循环右指针没有达到结尾</span></span><br><span class="line">        <span class="keyword">while</span> right &lt;<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="comment"># 窗口扩大，加入right对应的元素，更新过程结果以及当前的最优结果</span></span><br><span class="line">             <span class="keyword">if</span> s[right] <span class="keyword">not</span> <span class="keyword">in</span> hashset:</span><br><span class="line">                hashset.add(s[right])</span><br><span class="line">                length+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> length &gt;max_length:</span><br><span class="line">                    max_length=length</span><br><span class="line">                <span class="comment"># 右指针往右移动</span></span><br><span class="line">                right+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 内层循环，while的条件是过程结果不满足要求</span></span><br><span class="line">                <span class="comment"># 右边的元素重复出现在了hashset中</span></span><br><span class="line">                <span class="keyword">while</span> s[right] <span class="keyword">in</span> hashset:</span><br><span class="line">                    <span class="comment"># 窗口缩小，移除left对应的元素，left右移,同时过程结果-1</span></span><br><span class="line">                    hashset.remove(s[left])</span><br><span class="line">                    left+=<span class="number">1</span></span><br><span class="line">                    length-=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 内层循环结束，更新过程结果</span></span><br><span class="line">                <span class="comment"># 右边的元素又可以重新放入窗口</span></span><br><span class="line">                hashset.add(s[right])</span><br><span class="line">                right+=<span class="number">1</span></span><br><span class="line">                length+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 返回最优结果</span></span><br><span class="line">        <span class="keyword">return</span> max_length</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">    res=Solution().lengthOfLongestSubstring(s)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<p>这里还看到一个更加好理解的版本，也作为学习的记录写在这里,这一版虽然思路差不多，但是写法上却又有细微差别，上一个用到了元组，这里用到了字典，都可以进行判重处理，两者在更新结果的位置也不同。两者都用到了两层循环来解题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化左右指针以及最优结果</span></span><br><span class="line">        left,right,max_length=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="comment"># 建立一个哈希表,表示一个滑动的窗口</span></span><br><span class="line">        window=&#123;&#125;</span><br><span class="line">        <span class="comment"># 指针没有走到末尾</span></span><br><span class="line">        <span class="keyword">while</span> right &lt;<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="comment"># 思考当right向右移动的时候，即加入字符，应该更新哪些数据</span></span><br><span class="line">            <span class="comment"># 元素c是要加入的元素</span></span><br><span class="line">            c=s[right]</span><br><span class="line">            <span class="comment"># window中需要加入键值对</span></span><br><span class="line">            window[c]=window.get(c,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">            <span class="comment"># 窗口右移</span></span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 现在思考：什么条件下窗口应该停止扩大，开始移动left,缩小窗口</span></span><br><span class="line">            <span class="comment"># 满足的条件是：新加入的元素在哈希表中出现了（用代码表示就是对应的哈希值&gt;1）</span></span><br><span class="line">            <span class="keyword">while</span> window[c]&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 现在要思考：当移动left缩小窗口（即移除字符），需要更新哪些数据</span></span><br><span class="line">                <span class="comment"># d为需要移除的字符</span></span><br><span class="line">                d=s[left]</span><br><span class="line">                <span class="comment"># 移除字符的哈希值要-1</span></span><br><span class="line">                window[d]-=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 同时左侧窗口右移</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 思考何时应该更新结果</span></span><br><span class="line">            <span class="comment"># 内层循环都是不满足条件，要想满足条件并且要最大，就在内层循环结束后进行结果的更新</span></span><br><span class="line">            max_length=<span class="built_in">max</span>(max_length,right-left)</span><br><span class="line">        <span class="keyword">return</span> max_length</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">    res=Solution().lengthOfLongestSubstring(s)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h1 id="leetcoad209：长度最小的子数组"><a href="#leetcoad209：长度最小的子数组" class="headerlink" title="leetcoad209：长度最小的子数组"></a>leetcoad209：长度最小的子数组</h1><p>题目描述：给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度<strong>最小的连续子数组</strong>。如果不存在符合条件的连续子数组，返回 0。</p>
<p>输入: s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]<br>输出: 2<br>解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。<br>第一次自己写，失败<br>失败原因如下：</p>
<p>1. </p>
<h2 id="采用滑动窗口的思路"><a href="#采用滑动窗口的思路" class="headerlink" title="采用滑动窗口的思路"></a>采用滑动窗口的思路</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        left,right,result,minlength=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="comment"># while 右指针没有到结尾</span></span><br><span class="line">        <span class="keyword">while</span> right&lt;<span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="comment"># 窗口扩大，加入right对应的元素，更新当前的result</span></span><br><span class="line">            result+=nums[right]</span><br><span class="line">            <span class="comment"># while result 满足要求：</span></span><br><span class="line">            <span class="keyword">while</span> result&gt;=target:</span><br><span class="line">                <span class="comment"># 更新最优结果besrResult</span></span><br><span class="line">                <span class="keyword">if</span> right-left+<span class="number">1</span>&lt;minlength <span class="keyword">or</span> minlength==<span class="number">0</span>:</span><br><span class="line">                    minlength=right-left+<span class="number">1</span></span><br><span class="line">                <span class="comment"># 窗口缩小，移除left对应的元素，left右移</span></span><br><span class="line">                result-=nums[left]</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 更新最优结果minlength</span></span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> minlength</span><br></pre></td></tr></table></figure>
<p>后面自己有用滑动窗口写了一版</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 要求长度最小的子数组</span></span><br><span class="line">        <span class="comment"># 分析题意，要连续的子数组满足之和大于一个目标值，并且在这些符合条件的基础上再找出一个长度最小的</span></span><br><span class="line">        <span class="comment"># 采用滑动窗口的思路，并套用最短的模板</span></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        left,right=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="comment"># 定义记录连续子数组的长度以及最小长度的</span></span><br><span class="line">        length=<span class="number">0</span></span><br><span class="line">        min_length=<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="comment"># 定义一个哈希表，用来存放当前窗口的元素</span></span><br><span class="line">        <span class="comment"># window=&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 下面开始两个窗口的移动</span></span><br><span class="line">        <span class="comment"># 由于是要求长度最小的，所以应该是内层循环中更新最小的结果</span></span><br><span class="line">        <span class="keyword">while</span> right &lt;<span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="comment"># 窗口右移，同时长度+1</span></span><br><span class="line">            length+=<span class="number">1</span></span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 下面开始对左侧的窗口进行移动</span></span><br><span class="line">            <span class="comment"># while循环中应该写满足的条件</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">sum</span>(nums[left:right])&gt;=target:</span><br><span class="line">                <span class="comment"># d=nums[right]</span></span><br><span class="line">                <span class="comment"># 左侧的窗口右移，同时更新一些数据</span></span><br><span class="line">                length=right-left</span><br><span class="line">                <span class="comment"># 更新最优结果</span></span><br><span class="line">                <span class="keyword">if</span> length &lt; min_length:</span><br><span class="line">                    min_length=length</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 返回最优结果</span></span><br><span class="line">        <span class="keyword">return</span> min_length</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums= [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">    target=<span class="number">7</span></span><br><span class="line">    res=Solution().minSubArrayLen(target,nums)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>


<h1 id="leetcoad219-存在重复元素II（easy）"><a href="#leetcoad219-存在重复元素II（easy）" class="headerlink" title="leetcoad219-存在重复元素II（easy）"></a>leetcoad219-存在重复元素II（easy）</h1><p>理解题意：<br>给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] &#x3D;&#x3D; nums[j] 且 abs(i - j) &lt;&#x3D; k 。如果存在，返回 true ；否则，返回 false 。<br>暴力解题，只能通过40%的算例</p>
<ol>
<li>我们可以从前往后遍历 numsnumsnums，同时使用 Set 记录遍历当前滑窗内出现过的元素。</li>
<li>假设当前遍历的元素为 nums[i]：<ol>
<li>下标小于等于 k（起始滑窗长度还不足 k+1）：直接往滑窗加数，即将当前元素加入 Set 中；</li>
<li>下标大于 k：将上一滑窗的左端点元素 nums[i−k−1] 移除，判断当前滑窗的右端点元素 nums[i] 是否存在 Set 中，若存在，返回 True，否则将当前元素 nums[i] 加入 Set 中。</li>
</ol>
</li>
</ol>
<p>重复上述过程，若整个 numsnumsnums 处理完后仍未找到，返回 False。<br>解题思路有两种：</p>
<ol>
<li>暴力解法（通不过全部实例）</li>
<li>哈希表</li>
<li>滑动窗口</li>
</ol>
<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 直接暴力解法，思路没有错</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 另一个数字与当前数字的索引差值小于等于k</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> j-i&lt;=k <span class="keyword">and</span> nums[i]==nums[j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="哈希表的解法："><a href="#哈希表的解法：" class="headerlink" title="哈希表的解法："></a>哈希表的解法：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 建立一个hashmap</span></span><br><span class="line">        <span class="comment"># key:存储元素，value：储存下标</span></span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        <span class="comment"># 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 如果发现元素是在哈希表里面，并且当前的下标与哈希表中另一个相同值的下标的索引值相差小于等于k</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> hashmap <span class="keyword">and</span> i-hashmap[num]&lt;=k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将nums[i]和i存入hashmap中</span></span><br><span class="line">            <span class="comment"># 使用hashmap记录每个元素的最大下标</span></span><br><span class="line">            hashmap[num]=i</span><br><span class="line">        <span class="comment"># 循环结束之后还是没有找到两个元素相等并且下标只差小于等于k的，直接返回False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">    k=<span class="number">3</span></span><br><span class="line">    res=Solution().containsNearbyDuplicate(nums,k)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h2 id="采用滑动窗口的解法一："><a href="#采用滑动窗口的解法一：" class="headerlink" title="采用滑动窗口的解法一："></a>采用滑动窗口的解法一：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 建立一个hashset</span></span><br><span class="line">        hashset=<span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 如果发现下标大于k,即不满足要求</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;k:</span><br><span class="line">                <span class="comment"># 移除左边的元素</span></span><br><span class="line">                hashset.remove(nums[i-k-<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 如果发现元素已经在hashset中存在的话,表明是符合题目的要求的</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> hashset:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 继续往hashset中添加值</span></span><br><span class="line">            hashset.add(num)</span><br><span class="line">        <span class="comment"># 当循环结束的时候，还是没有找到符合条件的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">    k=<span class="number">3</span></span><br><span class="line">    res=Solution().containsNearbyDuplicate(nums,k)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h2 id="滑动窗口解法二："><a href="#滑动窗口解法二：" class="headerlink" title="滑动窗口解法二："></a>滑动窗口解法二：</h2><p>想用到模板的，有助于理解模板,其实还可以写一个版本的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 分析题目的意思：索引不同，并且相应的索引差值的绝对值不超过K，同时这两个数要相等</span></span><br><span class="line">        <span class="comment"># 现在采用滑动窗口的思路</span></span><br><span class="line">        left,right=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        hashset=<span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># 用两层循环不断地加入新元素和移除新的元素</span></span><br><span class="line">        <span class="keyword">while</span> right&lt;<span class="built_in">len</span>(nums):</span><br><span class="line">            c=nums[right]</span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> hashset:</span><br><span class="line">                hashset.add(c)</span><br><span class="line">            <span class="comment"># 当该元素在哈希表中的时候，可以直接返回True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">while</span> right-left&gt;k:</span><br><span class="line">                d=nums[left]</span><br><span class="line">                <span class="comment"># 将左侧的元素移除</span></span><br><span class="line">                hashset.remove(d)</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 两层循环结束之后都没有找到符合要求的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">    k=<span class="number">3</span></span><br><span class="line">    res=Solution().containsNearbyDuplicate(nums,k)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<p>但是用这种方式属实是有点不太好理解，单纯是为了熟悉模板，所以自己也圈出了需要注意的点如下：<br><img src="https://runnerxr.github.io/post-images/1653122374784.png"></p>
<h1 id="leetcoad220-存在重复元素-搁置"><a href="#leetcoad220-存在重复元素-搁置" class="headerlink" title="leetcoad220-存在重复元素(搁置)"></a>leetcoad220-存在重复元素(搁置)</h1><p>题目要求如下：<br>给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) &lt;&#x3D; t ，同时又满足 abs(i - j) &lt;&#x3D; k 。<br>如果存在则返回 true，不存在返回 false<br>相比上一题，这一题的话有<strong>多加入了一个条件</strong>：两者数值的绝对值只差不超过t值<br>暴力解题，通过95%的算例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力解法，实际不能这样写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 直接暴力解法，思路没有错</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 另一个数字与当前数字的索引差值小于等于k</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> j-i&lt;=k <span class="keyword">and</span> <span class="built_in">abs</span>(nums[i]-nums[j])&lt;=t:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="采用滑动窗口的思路来解题"><a href="#采用滑动窗口的思路来解题" class="headerlink" title="采用滑动窗口的思路来解题"></a>采用滑动窗口的思路来解题</h2><p>会超时，有时间整理这里的代码<br>对于任意一个位置 i（假设其值为 u），我们其实是希望在下标范围为 [max(0,i−k),i)内找到值范围在 [u−t,u+t]的数。<br>最基础的想法：每次遍历到任意位置i的时候，<strong>往后检查k个元素</strong>，需要优化<strong>检查后面k个元素的过程</strong><br>进一步的思路：用一个<strong>有序的集合去维护长度为k的滑动窗口</strong>的数，能够<strong>支持高效查询与插入和删除</strong>的操作</p>
<h1 id="leetcoad76-最小覆盖子串（hard）"><a href="#leetcoad76-最小覆盖子串（hard）" class="headerlink" title="leetcoad76-最小覆盖子串（hard）"></a>leetcoad76-最小覆盖子串（hard）</h1><p>备注：说实话这道题<strong>对于初学者</strong>来说真的是有点难，而且<strong>思路很离奇</strong>，只要是没有做过的，也是一定想不出来,可能刚开始看题目都没有看懂，或者是完全一脸懵逼，所以还是得死磕<br>题目解读：<br>给你一个字符串 s 、一个字符串 t 。返回 <strong>s 中涵盖 t 所有字符的最小子串</strong>。如果 s 中不存在涵盖 t 所有字符的子串，则返回<strong>空字符串</strong> “” 。<br>注意：<br>    1. 对于 <strong>t 中重复字符</strong>，我们寻找的<strong>子字符串中该字符数量</strong>必须不少于 t 中该字符数量。<br>    2. 如果 s 中存在这样的子串，我们保证它是<strong>唯一的答案</strong>。<br>示例1：<br>输入：s &#x3D; “ADOBECODEBANC”, t &#x3D; “ABC”<br>输出：”BANC”<br>示例2：<br>输入：s &#x3D; “a”, t &#x3D; “a”<br>输出：”a”<br>示例3：<br>输入: s &#x3D; “a”, t &#x3D; “aa”<br>输出: “”<br>解释: <strong>t 中两个字符 ‘a’ 均应包含在 s 的子串中</strong>，<br>因此没有符合条件的子字符串，返回空字符串。</p>
<h2 id="使用暴力解法"><a href="#使用暴力解法" class="headerlink" title="使用暴力解法"></a>使用暴力解法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i:j] 包含t的所有字母：</span><br><span class="line">            更新答案</span><br></pre></td></tr></table></figure>
<h2 id="采用滑动窗口的思路-1"><a href="#采用滑动窗口的思路-1" class="headerlink" title="采用滑动窗口的思路"></a>采用滑动窗口的思路</h2><ol>
<li>在s中使用左右指针的技巧，[left,right)为一个滑动窗口,是一个左闭右开的区间</li>
<li>先不断地增加right指针<strong>扩大窗口</strong>[left,right),直到窗口的字符串符合要求（包含 t中所有的字符：<strong>这里的转换关系很重要</strong>）【<strong>寻找一个可行解</strong>】</li>
<li>停止增加right，转而不断地增加left，缩小窗口，[left,right),直到<strong>窗口地字符串不再符合要求</strong>（不包含t中的所有字符：同样的也是转换关系），每次增加left，都要更新一轮结果【<strong>优化一个可行解</strong>】</li>
<li>重复2 3 步直到right达到字符串的尽头【<strong>最终找到最优解</strong>】<br>理解：这里面的<strong>左右指针轮流前进</strong>，<strong>窗口大小增增减减</strong>，<strong>窗口不断地向右滑动</strong>，也即滑动窗口地来历。（这里面的思维十分的到位，不光是理解，更要到应用的层面上来，即如何去实现它）<br><strong>想象</strong>：一个窗口在字符串上游走，当这个窗口包含的元素满足条件（包含字符串t的所有元素），记录这个滑动窗口的长度（right-left+1），这些长度中的最小的值就要求的结果。<br>need和window相当于计数器，分别记录<strong>T中字符出现的次数</strong>和<strong>窗口中相应字符出现的次数</strong><br>初始状态：<br><img src="https://runnerxr.github.io/post-images/1652953919734.png"><br>增加right，直到窗口[left,right]包含了T的所有字符<br><img src="https://runnerxr.github.io/post-images/1652954142170.png"><br>然后增加left，缩小窗口[left,right]<br><img src="https://runnerxr.github.io/post-images/1652954210165.png"><br>直到窗口中的字符串不在符合要求，left不再继续移动<br><img src="https://runnerxr.github.io/post-images/1652954271241.png"><br>之后重复上诉的过程，<strong>先移动right，再移动left</strong>……，<strong>直到right指针达到字符串s的末端</strong>，算法结束（这个过程是一个动态的过程，很考验自己的抽象思维能力！！！）</li>
</ol>
<h2 id="框架如何使用"><a href="#框架如何使用" class="headerlink" title="框架如何使用"></a>框架如何使用</h2><p>step1:初始化window和need两个哈希表，记录窗口中的字符和需要凑齐的字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">need,,window=&#123;&#125;,&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>step2:使用left和right变量初始化窗口的两端，初始情况下，窗口没有包含任何字符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">left,right=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">count =<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> right&lt;<span class="built_in">len</span>(s):</span><br><span class="line">    <span class="comment"># 开始滑动</span></span><br></pre></td></tr></table></figure>
<p>count表示窗口中<strong>满足need条件的字符个数</strong>（条件满足，但是个数不一定满足），如果count和need.size的<strong>大小相同</strong>，则说明窗口已经满足条件，<strong>已经完全覆盖了串t</strong><br>以下是模板的过程，需要思考以下的四个问题：（仔细地揣摩和理解）</p>
<ol>
<li>当移动right扩大窗口，即加入字符时，应该更新哪些数据？（每道题的特色变化）</li>
<li><strong>什么条件下，窗口应该停止扩大</strong>，开始移动left来缩小窗口？（思维盲点）</li>
<li>当移动left缩小窗口，即移除字符的时候，应该更新哪些数据？（每道题的特色变化）</li>
<li>我们<strong>要的结果</strong>应该在<strong>扩大窗口还是缩小窗口</strong>时进行更新？</li>
</ol>
<p>如果一个字符<strong>进入窗口</strong>，应该<strong>增加</strong>window计数器；相反，如果一个字符<strong>移除</strong>窗的时候，应该<strong>减少</strong>window计数器，当<strong>count满足need时</strong>应该收缩窗口，应该<strong>在收缩窗口</strong>的时候<strong>更新</strong>最终的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 构建两个哈希表，分别存储需要凑齐的字符和窗口的字符</span></span><br><span class="line">        need=<span class="built_in">dict</span>((c,t.count(c)) <span class="keyword">for</span> c <span class="keyword">in</span> t)</span><br><span class="line">        window=&#123;&#125;</span><br><span class="line">        <span class="comment"># 使用left和right变量初始化窗口的两端</span></span><br><span class="line">        <span class="comment"># 等右指针所在的位置之前的字符串包含t以后，左指针开始移动</span></span><br><span class="line">        left,right=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="comment"># 用于记录满足need条件的子串的长度</span></span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 记录最小覆盖子串的起始索引及长度</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        min_length=np.inf</span><br><span class="line">        <span class="keyword">while</span> right&lt;<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="comment"># 将字符c移入窗口</span></span><br><span class="line">            c=s[right]</span><br><span class="line">            <span class="comment"># 右移窗口</span></span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 进行窗口内一系类数据的更新</span></span><br><span class="line">            <span class="comment"># 如果c在need的关键字中</span></span><br><span class="line">            <span class="keyword">if</span>  c <span class="keyword">in</span> need.keys():</span><br><span class="line">                window[c]=window.get(c,<span class="number">0</span>) +<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span>  window[c]==need[c]:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># debug输出的位置一：表明此时的窗口</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;window向右扩充:&quot;</span>, left, right)</span><br><span class="line">            <span class="comment"># 判断左边的窗口是否需要收缩</span></span><br><span class="line">            <span class="comment"># while的条件是满足要求：有效的计数个数=需要的长度，此时循环结束</span></span><br><span class="line">            <span class="keyword">while</span> count ==<span class="built_in">len</span>(need):</span><br><span class="line">                <span class="comment"># 在这里更新最小的覆盖子串</span></span><br><span class="line">                <span class="keyword">if</span> right - left &lt;min_length:</span><br><span class="line">                    start = left</span><br><span class="line">                    min_length=right-left</span><br><span class="line">                <span class="comment"># d是将移除窗口的字符</span></span><br><span class="line">                d=s[left]</span><br><span class="line">                <span class="comment"># 左移窗口</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 进行窗口内一系列数据的更新</span></span><br><span class="line">                <span class="keyword">if</span> d <span class="keyword">in</span> need.keys():</span><br><span class="line">                    window[d]-=<span class="number">1</span></span><br><span class="line">                    <span class="comment"># 这里的判断是非常有必要的，而且往往是被忽略的，也就是说这个count-1是有一定的条件的。</span></span><br><span class="line">                    <span class="keyword">if</span> window[d] &lt;need[d]:</span><br><span class="line">                        count-=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 返回最小的覆盖子串</span></span><br><span class="line">        <span class="keyword">if</span> min_length==np.inf:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> s[start:start+min_length]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s= <span class="string">&quot;EBBANCF&quot;</span></span><br><span class="line">    t= <span class="string">&quot;ABC&quot;</span></span><br><span class="line">    res=Solution().minWindow(s,t)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<p>自己第二次写的时候有以下几点没有把握住：</p>
<ol>
<li>因为加入的元素可能会有相同的情况，所以在count更新之前必须要加入判断</li>
<li>移除元素的时候同理，也要加入判断，而且判断要合理：在一个调试出错的例子中：s&#x3D;’aa’,t&#x3D;’aa’,如果判断写成<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果判断条件写成这样，就会出现问题</span></span><br><span class="line"><span class="keyword">if</span> window[d]&lt;<span class="number">1</span> :</span><br><span class="line">    counyt-=<span class="number">1</span></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="comment"># 而实际正确的结果应为&#x27;aa&#x27;</span></span><br></pre></td></tr></table></figure>
<img src="https://runnerxr.github.io/post-images/1653061795029.png"></li>
</ol>
<h1 id="leetcoad438-找到字符串中所有字母异位词"><a href="#leetcoad438-找到字符串中所有字母异位词" class="headerlink" title="leetcoad438:找到字符串中所有字母异位词"></a>leetcoad438:找到字符串中所有字母异位词</h1><p>题目解读：<br>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。<br>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。<br>输入: s &#x3D; “cbaebabacd”, p &#x3D; “abc”<br>输出: [0,6]<br>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>另类的解释：相当于，输入一个串 S，一个串 T，<strong>找到 S 中所有 T 的排列</strong>，<strong>返回它们的起始索引</strong>。<br>第一写，存在问题<br>存在问题的原因：自己是用的暴力的解法，想用哈希表来更新符合条件的索引值，但是无论是符合还是不符合，索引值都会更新（这个不太符合要求！！！！！！）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 构建两个哈希表</span></span><br><span class="line">        need=<span class="built_in">dict</span>((c,p.count(c)) <span class="keyword">for</span> c <span class="keyword">in</span> p)</span><br><span class="line">        window=&#123;&#125;</span><br><span class="line">        left,right=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="comment"># 创建一个结果数组，用于存放所有满足条件的起始索引</span></span><br><span class="line">        res=[]</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="comment"># right指针没有走到末尾</span></span><br><span class="line">        <span class="keyword">while</span> right&lt;<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="comment"># 加入c字符，同时窗口向右</span></span><br><span class="line">            c=s[right]</span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 进行窗口的一系列更新</span></span><br><span class="line">            <span class="comment"># 如果发现遍历的元素出现在need的key值里面，将该键值对加入window哈希表中，其中计数右默认的0再增加1（后面再次出现再+1）</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> need.keys():</span><br><span class="line">                window[c]=window.get(c,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">                <span class="comment"># 查看当前两个哈希表中对应的计数值是否相等，如果相等，则有效的子串长度+1</span></span><br><span class="line">                <span class="keyword">if</span> window[c]==need[c]:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 加入一段调试代码</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;window:&#x27;</span>,left,right)</span><br><span class="line">            <span class="comment"># 判断左侧的窗口是否要收缩</span></span><br><span class="line">            <span class="comment"># while循环里面要写结果不满足要求的情况</span></span><br><span class="line">            <span class="comment">#while right - left &gt;len(p):</span></span><br><span class="line">            <span class="keyword">while</span> count==<span class="built_in">len</span>(need):</span><br><span class="line">                <span class="comment"># 当窗口符合条件时，把起始索引加入res中（此时子串的计数等于need的长度）</span></span><br><span class="line">                <span class="comment">#if count==len(need):</span></span><br><span class="line">                <span class="keyword">if</span> right-left==<span class="built_in">len</span>(p):</span><br><span class="line">                    res.append(left)</span><br><span class="line">                <span class="comment"># 字符d为左边将要移除的元素</span></span><br><span class="line">                d=s[left]</span><br><span class="line">                <span class="comment"># 左侧的窗口右移</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 进行窗口内一系列数据的更新</span></span><br><span class="line">                <span class="comment"># 如果d出现在need哈希表的key值中</span></span><br><span class="line">                <span class="keyword">if</span> d <span class="keyword">in</span> need.keys():</span><br><span class="line">                    <span class="comment"># 判断两个哈希表中d的计数是否相等</span></span><br><span class="line">                    <span class="comment"># 如果相等的化，就需要把子串计数-1</span></span><br><span class="line">                    <span class="keyword">if</span> window[d]==need[d]:</span><br><span class="line">                        count-=<span class="number">1</span></span><br><span class="line">                    <span class="comment"># 把window中d的计数-1</span></span><br><span class="line">                    window[d]-=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 循环结束</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>再次做的时候，发现有以下的几个小点需要特别注意（好像都是这些题目的共性问题）<br>后面从纵向把这些题目拿来一起进行比较分析就可以得出一些规律以及哪些坑是可以避免的。<br><img src="https://runnerxr.github.io/post-images/1653105815119.png"></p>
<h1 id="leetcoad567-字符串的排列"><a href="#leetcoad567-字符串的排列" class="headerlink" title="leetcoad567:字符串的排列"></a>leetcoad567:字符串的排列</h1><p>题目解读：<br>给你两个字符串 s1 和 s2 ，<strong>写一个函数</strong>来判断 s2 <strong>是否包含 <strong>s1 的</strong>排列</strong>。如果是，返回 true ；否则，返回 false 。<br>换句话说，<strong>s1 的排列之一是 s2 的 子串</strong> 。<br>输入：s1 &#x3D; “ab” s2 &#x3D; “eidbaooo”<br>输出：true<br>解释：s2 包含 s1 的排列之一 (“ba”).<br><strong>初步分析：</strong></p>
<ol>
<li>输入的 s1 是可以<strong>包含重复字符</strong>的，所以这个题难度不小。</li>
<li>这种题目，是明显的滑动窗口算法，相当给你一个 S 和一个 T，请**问你 S 中是否存在一个子串，包含 T **</li>
</ol>
<p><strong>题解思路</strong>：<br>对于这道题的解法代码，基本上和<strong>最小覆盖子串</strong>一模一样，只需要改变两个地方：</p>
<ol>
<li><strong>本题移动 left 缩小窗口的时机是窗口大小大于 t.size() 时</strong>，应为排列嘛，显然长度应该是一样的。</li>
<li>当发现 valid &#x3D;&#x3D; need.size() 时，就说明窗口中就是一个合法的排列，所以<strong>立即返回 true</strong>。<br>至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。<br><strong>自己做的感受</strong>：思维卡壳，通不过呀！！！，而且写的是没有一点灵魂，而且里面有一些很细节部分。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkInclusion</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s2)&lt;<span class="built_in">len</span>(s1):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 仍然采用滑动窗口的思路来解题</span></span><br><span class="line">        <span class="comment"># 具体的思维如下：</span></span><br><span class="line">        <span class="comment"># 1. 在向右滑动的过程中不断往window加入碰到的need哈希表中的值，并且还要计数</span></span><br><span class="line">        <span class="comment"># 2. 在左侧窗口向右滑动的过程中始终保持计数值和need的长度相等，并且需要在此时窗口的长度等于需要匹配的字符的长度的时候更新结果</span></span><br><span class="line">        left,right=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="comment"># 构建一个need哈希表，表中存放的是s1中的每个元素以及计数（1）</span></span><br><span class="line">        need=<span class="built_in">dict</span>((i,s1.count(i)) <span class="keyword">for</span> i <span class="keyword">in</span> s1)</span><br><span class="line">        window=&#123;&#125;</span><br><span class="line">        <span class="comment"># 定义一个变量用来记录次数</span></span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s2):</span><br><span class="line">            <span class="comment"># 字符c是即将要向右加入的元素</span></span><br><span class="line">            c=s2[right]</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> need.keys():</span><br><span class="line">                window[c]=window.get(c,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> window[c]==need[c]:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 现在进入内循环，注意思考while 循环的条件以及何时对结果进行更新</span></span><br><span class="line">            <span class="keyword">while</span> count==<span class="built_in">len</span>(need):</span><br><span class="line">                <span class="comment"># 如果发现此时的两个左右指针间的差值正好等于s1的长度</span></span><br><span class="line">                <span class="comment"># 能够进入内层循环，说明，说明当前窗口有目标字符，再加入这个条件的限制就正好是输出的结果</span></span><br><span class="line">                <span class="keyword">if</span> right- left ==<span class="built_in">len</span>(s1):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="comment"># d是即将要从左侧窗口移除的元素</span></span><br><span class="line">                d=s2[left]</span><br><span class="line">                <span class="comment"># 和外层的循环对称使用</span></span><br><span class="line">                <span class="keyword">if</span> d <span class="keyword">in</span> need.keys():</span><br><span class="line">                    window[d]=window.get(d,<span class="number">0</span>)-<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> window[d]&lt;need[d]:</span><br><span class="line">                        count-=<span class="number">1</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 循环结束之后仍没有找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<strong>做题之后的反思</strong>：很容易就想错的几个点<br><img src="https://runnerxr.github.io/post-images/1653126687822.png"><ol>
<li>假如存在相同的多个元素的情况，比如：s1&#x3D;”abc”,s2&#x3D;”ccccbbbbaaaa”</li>
<li>还有一个需要注意的点就是，内存循环更新count时的判断语句能否和外层的一样？这样写有什么问题if window[d]&#x3D;&#x3D;need[d]:,这里用另外的一个例子来说明： s1&#x3D;”ab”,s2&#x3D;”eidboaoo”<br>这里我也做了一个调试的情况写在这里了<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对第一种易错点</span></span><br><span class="line"><span class="comment"># 举的例子是 s1=&quot;abc&quot;,s2=&quot;ccccbbbbaaaa&quot;</span></span><br><span class="line"><span class="comment"># 如果外层循环是这样写的</span></span><br><span class="line"><span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s2):</span><br><span class="line">            <span class="comment"># 字符c是即将要向右加入的元素</span></span><br><span class="line">            c=s2[right]</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> need.keys():</span><br><span class="line">                window[c]=window.get(c,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                <span class="comment"># if window[c]==need[c]:</span></span><br><span class="line">                <span class="comment">#     count+=1</span></span><br><span class="line">            right+=<span class="number">1</span></span><br></pre></td></tr></table></figure>
直接三个c进入，程序直接结束，这肯定是不对的，同样的对于s1&#x3D;”ab”,s2&#x3D;”eidboaoo”，也有类似的情况<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对第二种错误，为什么这样写就是有问题的</span></span><br><span class="line"><span class="comment"># 举的例子是s1=&quot;ab&quot;,s2=&quot;eidboaoo&quot;</span></span><br><span class="line"><span class="keyword">while</span> count==<span class="built_in">len</span>(need):</span><br><span class="line">                <span class="comment"># 如果发现此时的两个左右指针间的差值正好等于s1的长度</span></span><br><span class="line">                <span class="comment"># 能够进入内层循环，说明，说明当前窗口有目标字符，再加入这个条件的限制就正好是输出的结果</span></span><br><span class="line">                <span class="keyword">if</span> right- left ==<span class="built_in">len</span>(s1):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="comment"># d是即将要从左侧窗口移除的元素</span></span><br><span class="line">                d=s2[left]</span><br><span class="line">                <span class="comment"># 和外层的循环对称使用</span></span><br><span class="line">                <span class="keyword">if</span> d <span class="keyword">in</span> need.keys():</span><br><span class="line">                    window[d]=window.get(d,<span class="number">0</span>)-<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> window[d]==need[d]:</span><br><span class="line">                    <span class="comment"># if window[d]&lt;need[d]:</span></span><br><span class="line">                        count-=<span class="number">1</span></span><br><span class="line">                left+=<span class="number">1</span></span><br></pre></td></tr></table></figure>
用这组例子的时候我们发现结果应该是False，结果返回的却是True.应为”boa”这种情况是不对的，题目的要求是子串，这个只是含有ab组合，却不是真的ab的组合，本来有一个限制条件：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> right- left ==<span class="built_in">len</span>(s1):</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
原因就在于，当我将判断条件设定为”if window[d]&#x3D;&#x3D;need[d]:”的时候，在向左滑动窗口的时候发现，当b被移除窗口的时候，此时因为window[d]!&#x3D;need[d]:所以判断直接跳过，并没有执行coun-&#x3D;1,导致此时居然是满足内层循环的条件，紧接着又满足了”if right- left &#x3D;&#x3D;len(s1):”,直接返回了True.<br>正确的做法：将此时的判断条件改为：<code> if window[d]&lt;need[d]:</code>，那么当b从左侧窗口移除的同时，相应的 <code>count-=1</code>,这样内层循环的条件就不满足，于此再次跳到外层循环，右侧窗口继续扩大，继续循环。</li>
</ol>
</li>
</ol>
<h1 id="三道题的总结与反思"><a href="#三道题的总结与反思" class="headerlink" title="三道题的总结与反思"></a>三道题的总结与反思</h1><p>上面的最小覆盖子串、字符串的排列  以及找出所有字符串的异位词，解题的代码十分的相似，差别的点不是太多，只是需要稍微的改动一下就可以通用，关键还是要理清楚更新结果的位置，在哪里更新以及怎么更新，这三道题我认为已经体现得淋漓尽致了，是一个很好的值得记录和后面牢牢掌握的点，相信自己对滑动窗口的题目又有了新的认识，之后碰到这样的题目能够把框架思维给利用上去。</p>
<h1 id="leetcoad239-滑动窗口的最大值"><a href="#leetcoad239-滑动窗口的最大值" class="headerlink" title="leetcoad239-滑动窗口的最大值"></a>leetcoad239-滑动窗口的最大值</h1><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回 滑动窗口中的最大值 。<br><a target="_blank" rel="noopener" href="https://www.algomooc.com/635.html">https://www.algomooc.com/635.html</a><br><strong>解题的本质：</strong><br>将处于窗口的第一个数字删除，同时在窗口的末尾添加一个新的数字，可以用双端队列来模拟，每次把尾部的数字弹出，再把新的数字压入到头部，然后找栈队列中最大的元素。<br>如果队列中进来一个较大的数字，那么队列中比这个数字更小的数字就不可能再成为窗口中最大的元素了（这个大的数字是后进来的，一定会比之前早进入窗口的小的数字要后离开窗口，先进入且比较小的数字必然不可能成为最大的元素，可以弹出队列）</p>
<p><strong>注意事项：</strong><br>python中队列保留的是索引，而其他的像java和C++中队列保存的是元素</p>
<p><strong>解题步骤如下:</strong><br>    * 获取数组长度<br>    * 构建双端队列<br>    * 创建一个存储最大值的数组<br>    * 定义好相应的边界情况<br>    * <strong>一开始滑动窗口不包含K个元素，不是合格的滑动窗口</strong></p>
<pre><code>        * 在滑动的过程中，维护好deque,确保是单调递减队列
        * 反复判断，如果队列不为空且当前考察元素大于等于队尾元素，则将元队尾素移除（为什么要移除队尾元素：因为前面已经进行递减的操作了）。
        * 直到考察元素可以放入到队列中（此处采用while循环进行相应的判断：满足条件就不断的执行队首元素的弹出，不满足：即考察的元素小与队列的队尾元素就加入进去）

* **当滑动的窗口正好有k个元素的时候，那么最大值就是对应的队首元素**

    * **向右移动会把窗口最左边的给舍弃**
    * 加入判断语句，如果队首元素与窗口最左边的元素相等，需要将队首元素抛出
    * 反复判断，如果队列不为空且当前考察元素大于等于队尾元素，则将队尾元素移除（采用while循环进行相应的判断，与上面的判断相同，相等的情况也要进行弹出）
    * 直到考察元素可以放入到队列中
* 最后返回res
</code></pre>
<p><strong>代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n ==<span class="number">0</span> <span class="keyword">or</span> k ==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,k):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[q[-<span class="number">1</span>]] &lt;= nums[i]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line">        res.append(nums[q[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,n):</span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> q[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">                    q.popleft()</span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[q[-<span class="number">1</span>]] &lt;=nums[i]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line">            res.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<p><strong>第一种写法：</strong><br>while q and nums[q[-1]] &lt;&#x3D; nums[i]:<br>        q.pop()<br>q.append(i)<br><strong>第二种写法：</strong><br>while q and q[-1] &lt; nums[i]:<br>        q.pop()<br>q.append(nums[i])</p>
<p><strong>第二种代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (k):</span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> q[-<span class="number">1</span>] &lt; nums[i]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(nums[i])</span><br><span class="line">        res.append(q[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (k, n):</span><br><span class="line">            <span class="keyword">if</span> q[<span class="number">0</span>] == nums[i-k]:</span><br><span class="line">                q.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> q[-<span class="number">1</span>] &lt; nums[i]: </span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(nums[i])</span><br><span class="line">            res.append(q[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<pre><code>    这里既然讲到了双端队列的问题，就做一点相应的知识整理：
    https://www.jb51.net/article/183382.htm  这里面讲的也很清楚明白
    **创建双向对队列：**
    import collections
    d = collections.deque()
    append(往右边添加一个元素)
    appendleft（往左边添加一个元素）
    clear(清空队列)
    copy(浅拷贝)
    count(返回指定元素的出现次数)
    ......
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/10/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" data-id="claquc63f002qz0tk1lhggeuy" data-title="滑动窗口" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gridea/" rel="tag">Gridea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" rel="tag">python知识小记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99%E7%9A%84%E5%B0%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/" rel="tag">工作之余的小的编程小知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" rel="tag">算法专栏（用python注写）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0/" rel="tag">读书摘记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Gridea/" style="font-size: 10px;">Gridea</a> <a href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" style="font-size: 13.33px;">python知识小记</a> <a href="/tags/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99%E7%9A%84%E5%B0%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/" style="font-size: 16.67px;">工作之余的小的编程小知识</a> <a href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" style="font-size: 20px;">算法专栏（用python注写）</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0/" style="font-size: 10px;">读书摘记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/21/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2022/11/12/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%BA%94%E7%9A%84%E5%90%8C%E6%AD%A5/">搭建自己的博客并进行相应的同步</a>
          </li>
        
          <li>
            <a href="/2022/10/03/vs%20code%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%B7%A5%E5%85%B7%E5%8C%85/">关于vs code导入本地工具包和消除&#39;import [module] could not be resolved in pylance&#39;</a>
          </li>
        
          <li>
            <a href="/2022/09/25/%E5%85%B3%E4%BA%8Ematalab%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">关于matalab的数据分析</a>
          </li>
        
          <li>
            <a href="/2022/07/30/%E5%85%B3%E4%BA%8Epython%E7%88%AC%E8%99%AB%E4%B8%80%E7%82%B9%E5%B0%8F%E7%9A%84%E6%95%B4%E7%90%86/">关于python爬虫一点小的整理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>