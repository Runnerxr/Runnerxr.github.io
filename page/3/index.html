<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-TopK问题的汇总" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/05/TopK%E9%97%AE%E9%A2%98%E7%9A%84%E6%B1%87%E6%80%BB/" class="article-date">
  <time class="dt-published" datetime="2022-05-05T06:36:05.000Z" itemprop="datePublished">2022-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/05/TopK%E9%97%AE%E9%A2%98%E7%9A%84%E6%B1%87%E6%80%BB/">TopK问题的汇总</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>对TopK问题汇总，总体来说也是想把这类问题弄清楚，还有就是排序的问题再复习一遍，以上问题都是以快速排序为核心的，这三种类型必须要牢牢地掌握清楚，透过现象看本质，代码的每一行理解清楚。</p>
<ol>
<li>获得前K小的数：剑指offer40</li>
<li>获得第K小的数:</li>
<li>获得第K大的数(数组中第k个最大元素)：leetcoad215</li>
</ol>
<h1 id="获得前K小的数"><a href="#获得前K小的数" class="headerlink" title="获得前K小的数"></a>获得前K小的数</h1><p>只有自己写的时候，才会发现有很多的细节没有注意，导致自己的代码运行不下去，所以一些代码的细节是需要推敲和琢磨的。对运行的结果要负责。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下代码经过调试时正确的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLeastNumbers</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># if k&gt;=len(arr):</span></span><br><span class="line">        <span class="comment">#     return arr</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr,left,right</span>):</span><br><span class="line">            <span class="comment"># 递归终止条件</span></span><br><span class="line">            <span class="comment"># left=right 证明要处理的数据只有一个</span></span><br><span class="line">            <span class="comment"># left &gt;right 证明右边没有数据</span></span><br><span class="line">            <span class="keyword">if</span> left &gt;=right:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 定义两个游标分别指向0和末尾的位置，选择基准点为调整范围的第一个值</span></span><br><span class="line">            start=left</span><br><span class="line">            end = right</span><br><span class="line">            pivot = arr[left]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 循环判断，直到遍历全部，left和right两个变量一直在变，直到两个相遇，说明遍历完全部的数据</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;right:</span><br><span class="line">                <span class="comment"># 从右向左，arr[right]&gt;pivot(从右开始查找大于基准点的值)</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[right]&gt;=pivot:</span><br><span class="line">                    right-=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 将right索引对应的元素赋值给left</span></span><br><span class="line">                arr[left]=arr[right]</span><br><span class="line">                <span class="comment"># 从左向右的过程中（从左开始查找小于基准点的数）</span></span><br><span class="line">                <span class="keyword">while</span> left &lt;right <span class="keyword">and</span> arr[left]&lt;pivot:</span><br><span class="line">                    left +=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 将left索引对应的值赋值为right</span></span><br><span class="line">                arr[right] =arr[left]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将基准数放置到对应的位置</span></span><br><span class="line">            arr[left]=pivot</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 比基准数小的即左边的数 要重复的调用快速排序函数</span></span><br><span class="line">            <span class="keyword">if</span> k&lt;left:</span><br><span class="line">                quick_sort(arr,start,left-<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 比基准数大的即右边的数，要重复调用快速排序函数</span></span><br><span class="line">            <span class="keyword">if</span> k&gt;left:</span><br><span class="line">                quick_sort(arr,left+<span class="number">1</span>,end)</span><br><span class="line">            <span class="comment"># 返回前k小的数</span></span><br><span class="line">            <span class="keyword">return</span> arr[:k]</span><br><span class="line">        <span class="keyword">return</span> quick_sort(arr,<span class="number">0</span>,<span class="built_in">len</span>(arr)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr=[<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">6</span>,-<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">    res=Solution().getLeastNumbers(arr,<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后面几行代码稍微有点区别，本质区别不是特别大</span></span><br><span class="line"><span class="comment"># 以下代码经过调试是正确的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLeastNumbers</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># if k&gt;=len(arr):</span></span><br><span class="line">        <span class="comment">#     return arr</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr,left,right</span>):</span><br><span class="line">            <span class="comment"># 递归终止条件</span></span><br><span class="line">            <span class="comment"># left=right 证明要处理的数据只有一个</span></span><br><span class="line">            <span class="comment"># left &gt;right 证明右边没有数据</span></span><br><span class="line">            <span class="keyword">if</span> left &gt;=right:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 定义两个游标分别指向0和末尾的位置，选择基准点为调整范围的第一个值</span></span><br><span class="line">            start=left</span><br><span class="line">            end = right</span><br><span class="line">            pivot = arr[left]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 循环判断，直到遍历全部，left和right两个变量一直在变，直到两个相遇，说明遍历完全部的数据</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;right:</span><br><span class="line">                <span class="comment"># 从右向左，arr[right]&gt;pivot(从右开始查找大于基准点的值)</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[right]&gt;=pivot:</span><br><span class="line">                    right-=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 将right索引对应的元素赋值给left</span></span><br><span class="line">                arr[left]=arr[right]</span><br><span class="line">                <span class="comment"># 从左向右的过程中（从左开始查找小于基准点的数）</span></span><br><span class="line">                <span class="keyword">while</span> left &lt;right <span class="keyword">and</span> arr[left]&lt;pivot:</span><br><span class="line">                    left +=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 将left索引对应的值赋值为right</span></span><br><span class="line">                arr[right] =arr[left]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将基准数放置到对应的位置</span></span><br><span class="line">            arr[left]=pivot</span><br><span class="line">            quick_sort(arr,start,left-<span class="number">1</span>)</span><br><span class="line">            quick_sort(arr,left+<span class="number">1</span>,end)</span><br><span class="line"></span><br><span class="line">        quick_sort(arr,<span class="number">0</span>,<span class="built_in">len</span>(arr)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> arr[:k]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr=[<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">6</span>,-<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">    res=Solution().getLeastNumbers(arr,<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h2 id="对函数进行封装"><a href="#对函数进行封装" class="headerlink" title="对函数进行封装"></a>对函数进行封装</h2><p>好处：这样的代码层次更加的清晰，方便后续检查与修改，要注意这样的书写方式，值得学习。<br>用三个函数：Partition()、quick_sort()和topk_split()  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLeastNumbers</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr,left,right</span>):</span><br><span class="line">            pivot=arr[left]</span><br><span class="line">            i = left</span><br><span class="line">            j = right</span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[j] &gt;= pivot:</span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                arr[i] = arr[j]</span><br><span class="line">                <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[i] &lt;pivot:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                arr[j] = arr[i]</span><br><span class="line">            arr[i]=pivot</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr,left,right</span>):</span><br><span class="line">            <span class="comment"># 递归的终止条件</span></span><br><span class="line">            <span class="keyword">if</span> left &lt;right:</span><br><span class="line">                mid=partition(arr,left,right)</span><br><span class="line">                quick_sort(arr,left,mid-<span class="number">1</span>)</span><br><span class="line">                quick_sort(arr,mid+<span class="number">1</span>,right)</span><br><span class="line"></span><br><span class="line">        quick_sort(arr,<span class="number">0</span>,<span class="built_in">len</span>(arr)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> arr[:k]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr=[<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">6</span>,-<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">    res=Solution().getLeastNumbers(arr,<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLeastNumbers</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr,left,right</span>):</span><br><span class="line">            pivot=arr[left]</span><br><span class="line">            i = left</span><br><span class="line">            j = right</span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[j] &gt;= pivot:</span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                arr[i] = arr[j]</span><br><span class="line">                <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[i] &lt;pivot:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                arr[j] = arr[i]</span><br><span class="line">            arr[i]=pivot</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr,left,right,k</span>):</span><br><span class="line">            <span class="comment"># 递归的终止条件</span></span><br><span class="line">            <span class="keyword">if</span> left &lt;right:</span><br><span class="line">                mid=partition(arr,left,right)</span><br><span class="line">                <span class="keyword">if</span> k&lt;mid:</span><br><span class="line">                    quick_sort(arr,left,mid-<span class="number">1</span>,k)</span><br><span class="line">                <span class="keyword">if</span> k&gt;mid:</span><br><span class="line">                    quick_sort(arr,mid+<span class="number">1</span>,right,k)</span><br><span class="line">        quick_sort(arr,<span class="number">0</span>,<span class="built_in">len</span>(arr)-<span class="number">1</span>,k)</span><br><span class="line">        <span class="keyword">return</span> arr[:k]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr=[<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">6</span>,-<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">    res=Solution().getLeastNumbers(arr,<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<p>再进一步进行封装</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这种做法貌似有点蠢的样子</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLeastNumbers</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr,left,right</span>):</span><br><span class="line">            pivot=arr[left]</span><br><span class="line">            i = left</span><br><span class="line">            j = right</span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[j] &gt;= pivot:</span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                arr[i] = arr[j]</span><br><span class="line">                <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[i] &lt;pivot:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                arr[j] = arr[i]</span><br><span class="line">            arr[i]=pivot</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr,left,right</span>):</span><br><span class="line">            <span class="comment"># 递归的终止条件</span></span><br><span class="line">            <span class="keyword">if</span> left &lt;right:</span><br><span class="line">                mid=partition(arr,left,right)</span><br><span class="line">                quick_sort(arr,left,mid-<span class="number">1</span>)</span><br><span class="line">                quick_sort(arr,mid+<span class="number">1</span>,right)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">topk_split</span>(<span class="params">nums, k, left, right</span>):</span><br><span class="line">            <span class="comment">#寻找到第k个数停止递归，使得nums数组中index左边是前k个小的数，index右边是后面n-k个大的数</span></span><br><span class="line">            <span class="keyword">if</span> (left&lt;right):</span><br><span class="line">                index = partition(nums, left, right)</span><br><span class="line">                <span class="keyword">if</span> index==k:</span><br><span class="line">                    <span class="keyword">return</span> </span><br><span class="line">                <span class="keyword">elif</span> index &lt; k:</span><br><span class="line">                    topk_split(nums, k, index+<span class="number">1</span>, right)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    topk_split(nums, k, left, index-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        quick_sort(arr,<span class="number">0</span>,<span class="built_in">len</span>(arr)-<span class="number">1</span>)</span><br><span class="line">        topk_split(arr, k, <span class="number">0</span>, <span class="built_in">len</span>(arr)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> arr[:k]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr=[<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">6</span>,-<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">    res=Solution().getLeastNumbers(arr,<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<h1 id="获得第k小的数"><a href="#获得第k小的数" class="headerlink" title="获得第k小的数"></a>获得第k小的数</h1><p>做法类似，只是在取k过程中不同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调试通过，没有问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getleastKth</span>(<span class="params">self,arr,k</span>):</span><br><span class="line">        <span class="comment"># 直接写快速排序的函数（模板）</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr,left,right</span>):</span><br><span class="line">            <span class="comment"># 判断边界条件</span></span><br><span class="line">            <span class="comment"># left=right说明此时只有一个数据</span></span><br><span class="line">            <span class="comment"># left &gt;right说明右边已经没有数据了</span></span><br><span class="line">            <span class="keyword">if</span> left &gt;=right:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 定义两个游标</span></span><br><span class="line">            start,end=left,right</span><br><span class="line">            <span class="comment"># 定义排序范围的起始位置</span></span><br><span class="line">            pivot=arr[left]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 开始进行循环</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;right:</span><br><span class="line">                <span class="comment"># 当left指针指向的数值小于pivot的值的情况的时候</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[left]&lt;pivot:</span><br><span class="line">                    left +=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 一旦发现left&gt;=pivot的时候，需要将此时left位置的值赋予给right位置</span></span><br><span class="line">                arr[right]=arr[left]</span><br><span class="line">                <span class="comment"># 当right指针指向的数值大于pivot的时候，需要将right指向向中间靠拢</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[right]&gt;=pivot:</span><br><span class="line">                    right-=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 一旦发现right&lt;pivot的时候，将此时right位置的值赋予给left对应的位置</span></span><br><span class="line">                arr[left] = arr[right]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 循环结束（left &gt;=right）</span></span><br><span class="line">            <span class="comment"># 将pivot的值放在中间的位置</span></span><br><span class="line">            arr[left]=pivot</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 对左右两个区间进行相应的排序操作</span></span><br><span class="line">            quick_sort(arr,start,left-<span class="number">1</span>)</span><br><span class="line">            quick_sort(arr,left+<span class="number">1</span>,end)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 由于是求第k小的数</span></span><br><span class="line">        quick_sort(arr,<span class="number">0</span>,<span class="built_in">len</span>(arr)-<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#print(arr)</span></span><br><span class="line">        <span class="keyword">return</span> arr[k]</span><br><span class="line"><span class="comment"># 写主函数</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr=[<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">6</span>]</span><br><span class="line">    res=Solution().getleastKth(arr,<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h2 id="采用封装的方式来写"><a href="#采用封装的方式来写" class="headerlink" title="采用封装的方式来写"></a>采用封装的方式来写</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码存在问题，后续补充</span></span><br></pre></td></tr></table></figure>
<h1 id="获得第k大的数"><a href="#获得第k大的数" class="headerlink" title="获得第k大的数"></a>获得第k大的数</h1><p>其实题目的这个条件挺苛刻的，要保证复杂度的要求，这也是我一直在纠结的地方，不过先整理把，这些问题就不管了。<br>得到答案并不难，但是在不断优化的过程就是挺难的<br>全局排序：如果是采用python内置的排序，当然时最简单的,当然这种方式打不到训练的目的是一种全局排序的方式，时间复杂度取决于排序的算法<br>局部排序：只排序TopK个数，O(n*k)，冒泡、直接选择、直接插入都可以，但k的取值趋近n时，时间复杂度又趋近与O(n^2)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKth</span>(<span class="params">self , a: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span>, K: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 对a进行快速排序</span></span><br><span class="line">        a.sort()</span><br><span class="line">        <span class="keyword">return</span> a[-K]</span><br></pre></td></tr></table></figure>
<p>采用快速排序的方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 采用这样的一种方式会超时（针对牛客网上）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKth</span>(<span class="params">self , a: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span>, K: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.quick_sort(a,<span class="number">0</span>,n-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> a[-K]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">self,arr,left,right</span>):</span><br><span class="line">        <span class="keyword">if</span> left &gt;=right:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        start=left</span><br><span class="line">        end = right</span><br><span class="line">        pivot = arr[left]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> arr[right]&gt;=pivot:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            arr[left] = arr[right]</span><br><span class="line">            <span class="keyword">while</span> left &lt;right <span class="keyword">and</span> arr[left] &lt;pivot:</span><br><span class="line">                left +=<span class="number">1</span></span><br><span class="line">            arr[right] =arr[left]</span><br><span class="line">        arr[left]=pivot</span><br><span class="line">        self.quick_sort(arr,start,left-<span class="number">1</span>)</span><br><span class="line">        self.quick_sort(arr,left+<span class="number">1</span>,end)</span><br></pre></td></tr></table></figure>
<p>对这种方法进行相应的改进操作（暂时没有找到比较好的方法，先放着再说把）</p>
<p>采用堆排序（维护小顶堆或大顶堆大方式：复杂度：O(nlog(n))）：没有时间暂时不看了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/05/TopK%E9%97%AE%E9%A2%98%E7%9A%84%E6%B1%87%E6%80%BB/" data-id="claqum2dd000ch0tk1zhi3ard" data-title="TopK问题的汇总" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Git相关知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/29/Git%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2022-04-29T00:26:42.000Z" itemprop="datePublished">2022-04-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/29/Git%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/">GIT相关知识点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>参考链接1:<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1FE411P7B3?p=2&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1FE411P7B3?p=2&amp;spm_id_from=pageDriver</a><br>参考链接2:<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU0Nzc5MDQxNw==&amp;mid=2247489688&amp;idx=1&amp;sn=04f844db1bd6de22bb15267b9e71716a&amp;chksm=fb4853a6cc3fdab08930dd06a6419850189fab72e754825d48adf39a390aa20765601c65dfc4&amp;cur_album_id=1323908580084449280&amp;scene=190#rd">https://mp.weixin.qq.com/s?__biz=MzU0Nzc5MDQxNw==&amp;mid=2247489688&amp;idx=1&amp;sn=04f844db1bd6de22bb15267b9e71716a&amp;chksm=fb4853a6cc3fdab08930dd06a6419850189fab72e754825d48adf39a390aa20765601c65dfc4&amp;cur_album_id=1323908580084449280&amp;scene=190#rd</a><br>版本控制：管理所有的文件，方便查看历史记录。备份以及恢复，多人开发的作用很大<br>当下最流行的<br>所有的版本数据都保存在<strong>服务器上</strong>，协同开发人员<strong>从服务器上同步更新</strong>或上传自己的修改<br>每个人都有全部的代码，不会因为网络或服务器坏了原因<br>存储在多个电脑上的不同版本的代码文件进行版本管理。类似于一个<strong>协同的办公软件</strong>，github能够提供对版本管理服务支持的一个<strong>服务器供应商</strong>（git类似于微信这款软件，github类似于微信服务器端，用来交换每个微信软件端的信息，微信只能用官方服务器，git允许任何电脑成为服务器），当然能够提供git服务器的还有码云（Gitee）、腾讯开发者平台（dev.tencent.com）<br>所有下载慢的话都可以找镜像</p>
<p>会卸载：要删除环境变量，然后用卸载<br>安装完毕直接启动<br>GIT Bash<br>GIT CMD：windows<br>GIT GUI  :无用</p>
<h1 id="常见的一些命令"><a href="#常见的一些命令" class="headerlink" title="常见的一些命令"></a>常见的一些命令</h1><p>cd    ：  改变目录<br>cd ..    回退到上一个目录，直接cd进入默认目录<br>pwd   ： 显示当前所在的目录路径<br>ls    ： 都是列出当前目录中的所有文件<br>touch :新建一个文件  如touch index.js就会在当前目录下新建一个index.js<br>rm  ：删除一个文件， rm index.js就会把index.js文件删除<br>mkdir  :新建一个目录，就是新建一个文件夹<br>rm -r 删除一个文件夹，rm -r src 删除src目录<br>mv  移动文件， mv index.html src        index.html 是我们要移动的文件，src是目标文件夹<br>reset 重新初始化终端&#x2F;清屏<br>clear 清屏<br>history 查看命令历史<br>help 帮助<br>exit 退出</p>
<h1 id="表示注释"><a href="#表示注释" class="headerlink" title="表示注释"></a>表示注释</h1><p>查看配置：git config -1<br>查看系统配置：git config –system –list<br>查看本地的全局配置：git config –global –list<br>用户名和密码是必须要配置的，告诉服务器，表明你是谁<br>所有的配置文件都是保存在本地</p>
<h1 id="创建仓库的版本："><a href="#创建仓库的版本：" class="headerlink" title="创建仓库的版本："></a>创建仓库的版本：</h1><p>还比较好懂，这里的大致步骤都是廖雪峰网站上的，所以整理的还是比较清晰的<br>自己已经创建好了一个仓库了（在对应的为位置上），多了一个.git的目录，用来跟踪管理版本库的，不要手动的去修改目录里面的文件（修改会破坏仓库）</p>
<ol>
<li>编写一个readme.txt文件<br> Git is a version control system.<br> Git is free software.</li>
<li>git add readme.txt（第一步）</li>
<li>git commit -m “wrote a readme file” （第二步）<ol>
<li>-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</li>
<li>嫌麻烦不想输入-m “xxx”行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</li>
<li>1 file changed：1个文件被改动（我们新添加的readme.txt文件）</li>
<li>2 insertions：插入了两行内容（readme.txt有两行内容）</li>
</ol>
</li>
</ol>
<p>注意事项：<br>commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p>
<ol>
<li>git add file1.txt</li>
<li>git add file2.txt file3.txt</li>
<li>git commit -m “add 3 files.”</li>
</ol>
<p>git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。<br>git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。<br>以下为第二次的一些命令：</p>
<ol>
<li>git status</li>
<li>git diff readme.txt </li>
<li>git add readme.txt</li>
<li>git status</li>
<li>git commit -m “add distributed”</li>
<li>git status<br>小结：</li>
<li>需要随时掌握工作区的状态，使用git status</li>
<li>如果git status告诉文件被修改过，用git diff可以查看修改的内容</li>
</ol>
<h1 id="工作区和暂缓区"><a href="#工作区和暂缓区" class="headerlink" title="工作区和暂缓区"></a>工作区和暂缓区</h1><p>工作区：working directory<br>版本库：repository<br>git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br>直观的理解如下：<br>Git管理的文件分为：工作区，版本库，版本库又分为暂存区stage和暂存区分支master(仓库)<br>工作区&gt;&gt;&gt;&gt;暂存区&gt;&gt;&gt;&gt;仓库<br>git add把文件从工作区&gt;&gt;&gt;&gt;暂存区，git commit把文件从暂存区&gt;&gt;&gt;&gt;仓库，<br>git diff查看工作区和暂存区差异，<br>git diff –cached查看暂存区和仓库差异，<br>git diff HEAD 查看工作区和仓库的差异，<br>git add的反向命令git checkout，撤销工作区修改，即把暂存区最新版本转移到工作区，<br>git commit的反向命令git reset HEAD，就是把仓库最新版本转移到暂存区。</p>
<h1 id="管理和修改"><a href="#管理和修改" class="headerlink" title="管理和修改"></a>管理和修改</h1><p>git跟踪管理的是修改，而非文件</p>
<h1 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h1><h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>为了学习GIT搭建服务器是小题大做，可以用github提供的git仓库的托管服务，免费获取git的远程仓库<br>由于你的<strong>本地Git仓库和GitHub仓库之间的传输是通过SSH加密的</strong>，所以，需要一点设置：<br>第1步：<strong>创建SSH Key</strong>：在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xiongrui1690347341@163.com&quot;</span><br></pre></td></tr></table></figure>
<p>放在了用户的主目录里面.ssh目录，找到id_rsa和id_rsa.pub    这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。<br>一路回车之后就会创建一个.ssh目录<br>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：<br>点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：<br>    1. 设置SHH Key的原因：github需要识别你推送的提交确实是你推送的，不是别人冒充的，git支持SSH协议，github只要知道了你的公钥，就可以确认只有你自己可以推送<br>        2. GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。<br>        3. 在GitHub上免费托管的Git仓库，任何人都可以看到<br>        4. 不想让别人看到Git库：<br>        1. 让GitHub把公开的仓库变成私有的：不可读更不可写<br>        2. 自己动手，搭建一个git服务器，别人看不见，用于公司内部的开发必备</p>
<h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><p>在本地创建了一个git仓库，又想在GitHub创建一个Git仓库，<strong>并且让这两个仓库进行远程同步</strong>，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作<br>自己已经关联了一个仓库learngit，仓库是空的，<strong>从这个仓库克隆出新的仓库</strong>，也可以把一个<strong>已有的本地仓库与之关联</strong>，之后就可以把本地的内容推送到Github仓库了：命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:Runnerxr/learngit.git</span><br></pre></td></tr></table></figure>
<p>添加之后，远程仓库的名称就是origin(Git的默认叫法，很直观的就能看出是远程库)<br>把本地库的内容推送到远程库上面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol>
<li>用git push命令，实际上是把当前的分支master推送到远程</li>
<li>原先仓库是空的，第一次推送master分支，加上-u参数，git不但会<strong>把本地的master分支内容推送到远程新的master</strong>,还会<strong>把本地的master分支和远程的master分支关联起来</strong>，在以后的推送或者拉取时可以简化命令</li>
</ol>
<p>推送成功之后，只要本地做了提交，就可以通过命令,把本地的master分支的最新修改推送至Github,就有了 真正的分布式版本库。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>


<p>从现在起，只要本地做了提交，就可以通过命令<br>git push origin master<br>把本地的master 分支的最新修改推送至Github，拥有了真正的分布式版本库！</p>
<p>小结如下：</p>
<ol>
<li>要关联一个远程库，使用命令git remote add origin git@server-name:path&#x2F;repo-name.git；</li>
<li>关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名；</li>
<li>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；</li>
<li>每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</li>
</ol>
<p>分布式版本的好处：在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，当有网络的时候，再把本地提交推送一下就完成了同步</p>
<h2 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h2><p>现在是从零开始，先创建远程库，然后从远程库克隆</p>
<ol>
<li>创建一个仓库，名字叫：gitskills</li>
<li>勾选“Initialize this repository with a README”，自动创建一个README<br>.md文件</li>
<li>远程仓库准备好了，然后用git clone  克隆一个本地库：”git clone <a href="mailto:&#x67;&#105;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;">&#x67;&#105;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;</a>:Runnerxr&#x2F;gitskills.git”</li>
<li>如果有多人协同开发，每个人各自从远程克隆一份就行</li>
<li>Github给的地址：（Git支持多种协议）<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/Runnerxr/gitskills.git%EF%BC%88%E9%BB%98%E8%AE%A4%E7%9A%84git://%E4%BD%BF%E7%94%A8%E7%9A%84ssh,%E6%98%AF%E6%9C%80%E5%BF%AB%E7%9A%84%EF%BC%89">https://github.com/Runnerxr/gitskills.git（默认的git://使用的ssh,是最快的）</a></li>
<li>也可以使用https等其他的协议（很慢，而且每次推送都需要输入口令，但是有些公司只开放http端口）</li>
</ol>
</li>
</ol>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>作用：</p>
<ol>
<li>创建一个属于自己的分支，<strong>别人看不到</strong>，还继续在原来的分支上正常工作，而自己在自己的分支上干活，<strong>想提交就提交，直到开发完毕</strong>，再一次性合并到原来的分支上，既安全，又不影响别人工作。</li>
<li>git的分支无论创建、切换和删除分支，git能快速完成</li>
</ol>
<h1 id="目前自己已经有的几个远程仓库"><a href="#目前自己已经有的几个远程仓库" class="headerlink" title="目前自己已经有的几个远程仓库"></a>目前自己已经有的几个远程仓库</h1><p>1、Runnerxr.github.io（主要想用于记录和更新Gridea里面的一些内容，但是前提是Gridea这个博客能够正常完整的使用下去）</p>
<p>2、bear-blog（Hexo + github + vercel 静态博客免费部署方案）</p>
<p>3、learngit（学习git的时候特意建立的学习的仓库）</p>
<p>4、VS-（平时线下的VScode上的一些代码的上传）</p>
        
          <p class="article-more-link">
            <a href="/2022/04/29/Git%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/29/Git%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="claqum2d70004h0tk07fjeaxr" data-title="GIT相关知识点" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Gridea/" rel="tag">Gridea</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-SQL数据库的相关知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/29/SQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2022-04-29T00:05:28.000Z" itemprop="datePublished">2022-04-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/29/SQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/">SQL数据库的相关知识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>数据库的知识就暂时整理到这里，后面有能力和需求再继续补充</p>
<p>76条经典的数据库语言<br>自带的字符客户端MySQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">-- 删除已经创建的表</span><br><span class="line">drop table dept;</span><br><span class="line">drop table employees;</span><br><span class="line">drop table managers;</span><br><span class="line">-- 创建部门表</span><br><span class="line">create table dept(</span><br><span class="line">deptno int primary key,</span><br><span class="line">dname varchar(9),</span><br><span class="line">loc varchar(10));</span><br><span class="line"></span><br><span class="line">-- 创建员工表</span><br><span class="line">create table employees(</span><br><span class="line">empno int primary key ,</span><br><span class="line">name char(10) not null,</span><br><span class="line">deptno int,</span><br><span class="line">manager int,</span><br><span class="line">hiredate date,</span><br><span class="line">salary numeric(7, 2)) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 创建经理表</span><br><span class="line">create table managers(</span><br><span class="line">empno int primary key,</span><br><span class="line">title varchar(16));</span><br><span class="line"></span><br><span class="line">-- insert 语句向员工表中插入记录，包括所有字段的值</span><br><span class="line">insert into employees values(1,&#x27;张三&#x27;,1,2,&#x27;2011-03-03&#x27;,4400.00);</span><br><span class="line">insert into employees values(2,&#x27;王五&#x27;,1,2,&#x27;2013-01-03&#x27;,4100.00);</span><br><span class="line">insert into employees values(3,&#x27;李四&#x27;,2,4,&#x27;2021-02-10&#x27;,3900.00);</span><br><span class="line">insert into employees values(5,&#x27;李明&#x27;,3,5,&#x27;2004-09-11&#x27;,5200.00);</span><br><span class="line">insert into employees values(6,&#x27;孙军&#x27;,3,5,&#x27;2016-05-22&#x27;,4700.00);</span><br><span class="line">insert into employees values(7,&#x27;钱杰&#x27;,3,5,&#x27;2013-07-22&#x27;,4900.00);</span><br><span class="line">insert into employees values(8,&#x27;李爱国&#x27;,3,5,&#x27;2013-07-22&#x27;,4900.00);</span><br><span class="line">-- 向员工表中插入记录，只包括部分字段的值</span><br><span class="line">insert into employees(empno,name,salary) values(4,&#x27;赵六&#x27;,5000.00);</span><br><span class="line">insert into employees(empno,name,hiredate,salary) values(9,&#x27;刘国强&#x27;,&#x27;2010-04-12&#x27;,5000.00);</span><br><span class="line">-- 向部门表中插入记录</span><br><span class="line">insert into dept values(1,&#x27;技术部&#x27;,&#x27;一楼a 区&#x27;);</span><br><span class="line">insert into dept values(2,&#x27;销售部&#x27;,&#x27;二楼a 区&#x27;);</span><br><span class="line">insert into dept values(3,&#x27;行政部&#x27;,&#x27;一楼b 区&#x27;);</span><br><span class="line"></span><br><span class="line">-- 向经理表中插入记录</span><br><span class="line">insert into managers values(2,&#x27;技术部经理&#x27;);</span><br><span class="line">insert into managers values(4,&#x27;销售部经理&#x27;);</span><br><span class="line">insert into managers values(5,&#x27;行政部经理&#x27;);</span><br><span class="line">insert into managers values(99,&#x27;总裁&#x27;);</span><br><span class="line"></span><br><span class="line">-- 主键重复的记录无法插入</span><br><span class="line">insert into employees values(1,&#x27;郭君声&#x27;,1,2,&#x27;2010-04-11&#x27;,6100.00);</span><br><span class="line">insert into dept values(3,&#x27;市场部&#x27;,&#x27;一楼a 区&#x27;);</span><br><span class="line">-- 不能将现有的记录修改成违反主键约束的记录</span><br><span class="line">update managers set empno=2 where empno=4;</span><br><span class="line"></span><br><span class="line">-- select 语句查询员工表的所有记录的所有字段</span><br><span class="line">select * from employees;</span><br><span class="line">-- select 语句查询员工表的所有记录的姓名和工资字段</span><br><span class="line">select name,salary from employees;</span><br><span class="line"></span><br><span class="line">-- distinct 去重复值查询员工表中的所有经理号</span><br><span class="line">select manager from employees;</span><br><span class="line">-- 查询员工表中的不重复的经理号</span><br><span class="line">select distinct manager from employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- where 条件过滤查询在3 部门的员工的员工的姓名和工资：</span><br><span class="line">select name,salary from employees where deptno=3;</span><br><span class="line">-- 查询2010 年前入职的员工的姓名和工资：</span><br><span class="line">select name,salary from employees where hiredate&lt;&#x27;2010-01-01&#x27;;</span><br><span class="line"></span><br><span class="line">-- and 和or 运算符查询出第3 部门里工资大于等于5 千的员工</span><br><span class="line">select * from employees where deptno=3 and salary&gt;=5000;</span><br><span class="line"></span><br><span class="line">-- 查询出第3 部门或者工资大于等于5 千的员工：</span><br><span class="line">select * from employees where deptno=3 or salary&gt;=5000;</span><br><span class="line">-- 查询出第3 部门或者第1 部门中工资大于等于5 千的员工：</span><br><span class="line">select * from employees where (deptno=3 or deptno=1) and salary&lt;5000;</span><br><span class="line"></span><br><span class="line">-- like 搜索匹配的字符串找出在一楼办公的部门：</span><br><span class="line">select * from dept where loc like &#x27;一楼%&#x27;;</span><br><span class="line">-- 找出姓李的员工</span><br><span class="line">select * from employees where name like &#x27;李%&#x27;;</span><br><span class="line"></span><br><span class="line">-- in 匹配多个值列出员工号为3 和5 的员工：</span><br><span class="line">select name from employees where empno in (3,5);</span><br><span class="line">-- 前面的SQL 语句相当于</span><br><span class="line">select name from employees where empno=3 or empno=5;</span><br><span class="line">-- 找出不在部门3 和部门5 的员工的姓名</span><br><span class="line">select name from employees where empno not in (3,5);</span><br><span class="line">-- 找出在一楼办公的员工的姓名：</span><br><span class="line">select name from employees where deptno in (select deptno from dept where loc like &#x27;一楼%&#x27;);</span><br><span class="line"></span><br><span class="line">-- between 查询出在2013 年之间入职的员工的姓名：</span><br><span class="line">select name from employees where hiredate between &#x27;2013-01-01&#x27; and &#x27;2013-12-31&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询出不在2013 年入职的员工：</span><br><span class="line">select name from employees where hiredate not between &#x27;2013-01-01&#x27; and &#x27;2013-12-31&#x27;;</span><br><span class="line"></span><br><span class="line">-- 按工资从低到高列出员工姓名和工资：</span><br><span class="line">select name,salary from employees order by salary;</span><br><span class="line">-- 如果要按从高到低输出，加上desc 的关键字：</span><br><span class="line">select name,salary from employees order by salary desc;</span><br><span class="line"></span><br><span class="line">-- 下面的命令按照员工的入职顺序列出员工：</span><br><span class="line">select name,hiredate from employees order by hiredate;</span><br><span class="line">-- update 修改数据先查询一下员工号为4 的员工信息：</span><br><span class="line">select * from employees where empno=4;</span><br><span class="line">-- 下面的sql 语句将这个员工所属的部门改成2，经理改成4:</span><br><span class="line">update employees set deptno=2, manager=4 where empno=4;</span><br><span class="line">-- 修改完成后再次查询这个员工的记录如下：</span><br><span class="line">select * from employees where empno=4;</span><br><span class="line"></span><br><span class="line">-- delete 删除记录查询9 号员工的记录：</span><br><span class="line">select * from employees where empno=9;</span><br><span class="line">-- 删除9 号员工的记录：</span><br><span class="line">delete from employees where empno=9;</span><br><span class="line">-- 再次查询9 号员工的记录：</span><br><span class="line">select * from employees where empno=9;</span><br><span class="line">-- create index 创建索引在表employees 的name 字段上创建索引</span><br><span class="line">create index in_name on employees(name);</span><br><span class="line"></span><br><span class="line">-- create view 创建视图创建一个视图名为employees_2015 的视图，包括2015 年之前入</span><br><span class="line">职的员工的姓名和工资。</span><br><span class="line">create view employees_2015 as select name,salary from employees where hiredate &lt;&#x27;2015-01-01&#x27;;</span><br><span class="line">-- 查询这个视图</span><br><span class="line">select * from employees_2015;</span><br><span class="line">-- 更新这个视图，把张三的工资增加400 元：</span><br><span class="line">update employees_2015 set salary=salary+400 where name=&#x27;张三&#x27;;</span><br><span class="line">-- 再次查询这个视图，发现已经更新成功：</span><br><span class="line">select * from employees_2015;</span><br><span class="line"></span><br><span class="line">-- 检查底层表，发现也已经更新成功：</span><br><span class="line">select name,salary from employees where name=&#x27;张三&#x27;;</span><br><span class="line"></span><br><span class="line">-- 删除视图</span><br><span class="line">drop view employees_2015;</span><br><span class="line">-- null 值查询不属于任何部门的员工的信息</span><br><span class="line">select * from employees where deptno is null;</span><br><span class="line"></span><br><span class="line">-- 查询有经理的员工的信息：</span><br><span class="line">select * from employees where manager is not null;</span><br><span class="line">-- 字段或表的别名把字段名换成中文，表意更明确；把表名换成简短的字符串，写起</span><br><span class="line">来更方便</span><br><span class="line"></span><br><span class="line">select name 姓名, salary 工资from employees e;</span><br><span class="line">-- 把count(*)的字段用汉字“总人数”代替，表意更清楚</span><br><span class="line">select count(*) 总人数from employees;</span><br><span class="line"></span><br><span class="line">-- join 连接表inner join 内连接，内连接查询出员工表和经理表中都存在的员工的姓名</span><br><span class="line">和头衔</span><br><span class="line">select name,title from employees inner join managers on employees.empno=managers.empno;</span><br><span class="line"></span><br><span class="line">-- left join 左连接查询员工表中的所有记录，并列出他们在经理表中的头衔，如果在经</span><br><span class="line">理表中没有记录头衔用null 代替</span><br><span class="line">select name,title from employees left join managers on employees.empno=managers.empno;</span><br><span class="line"></span><br><span class="line">-- right join 右连接查询经理表中的所有记录，并列出他们在员工表中的姓名，如果在员</span><br><span class="line">工表中没有记录姓名用null 代替</span><br><span class="line">select name,title from employees right join managers on</span><br><span class="line">employees.empno=managers.empno;</span><br><span class="line"></span><br><span class="line">-- 子查询查询在二楼办公的员工的姓名</span><br><span class="line">select name from employees where deptno in (select deptno from dept where loc like &#x27;二楼%&#x27;);</span><br><span class="line"></span><br><span class="line">-- 查询不在员工表中的经理</span><br><span class="line">select * from managers where empno not in (select empno from employees);</span><br><span class="line"></span><br><span class="line">--常用的函数</span><br><span class="line">-- count 函数count(*)统计统计员工表中的所有员工</span><br><span class="line">select count(*) from employees ;</span><br><span class="line"></span><br><span class="line">-- 统计员工表中所有部门号不为null 的员工</span><br><span class="line">select count(deptno) from employees ;</span><br><span class="line"></span><br><span class="line">-- 查询员工表中部门号为null 的员工</span><br><span class="line">select * from employees where deptno is null;</span><br><span class="line"></span><br><span class="line">-- max 函数查询员工表中工资最高的员工</span><br><span class="line">select max(salary) from employees;</span><br><span class="line"></span><br><span class="line">-- min 函数查询员工表中最早入职的员工</span><br><span class="line">select min(hiredate) from employees;</span><br><span class="line"></span><br><span class="line">-- avg 函数查询员工表中员工的平均工资</span><br><span class="line">select avg(salary) from employees;</span><br><span class="line"></span><br><span class="line">-- sum 函数查询员工表中员工的工资合计</span><br><span class="line">select sum(salary) from employees;</span><br><span class="line"></span><br><span class="line">-- group by 分组统计按部门统计员工的平均工资</span><br><span class="line">select deptno,avg(salary) from employees group by deptno;</span><br><span class="line"></span><br><span class="line">-- having 过滤分组统计查询部门员工平均工资小于4500 的部门</span><br><span class="line">select deptno,avg(salary) from employees group by deptno having avg(salary)&lt;4500;</span><br></pre></td></tr></table></figure>
<p>数据存放在数据库库中,SQL是用于访问和处理数据库的标准计算机语言，是指结构化查询语言，机会所有的关系数据库都可以用，不需要区分大小写。</p>
<h1 id="访问数据库"><a href="#访问数据库" class="headerlink" title="访问数据库"></a>访问数据库</h1><h2 id="如何定义数据的存储格式"><a href="#如何定义数据的存储格式" class="headerlink" title="如何定义数据的存储格式"></a>如何定义数据的存储格式</h2><p><strong>为了便于程序保存和读取数据</strong>，而且，能直<strong>接通过条件快速查询到指定的数据</strong>，就出现了数据库（Database）这种专门用于集中存储和查询的软件。<br>数据库软件诞生的历史非常久远，早在1950年数据库就诞生了。经历了<strong>网状数据库</strong>，<strong>层次数据库</strong>，<strong>关系数据库</strong>，我们现在广泛使用的关系数据库是20世纪70年代基于关系模型的基础上诞生的。</p>
<h2 id="数据库的类型"><a href="#数据库的类型" class="headerlink" title="数据库的类型"></a>数据库的类型</h2><pre><code>* MySQL，大家都在用，一般错不了；
* PostgreSQL，学术气息有点重，其实挺不错，但知名度没有MySQL高；
* sqlite，嵌入式数据库，适合桌面和移动应用。
</code></pre>
<p>作为Python开发工程师，选择哪个免费数据库呢？当然是MySQL。因为MySQL普及率最高，出了错，可以很容易找到解决方法。而且，<strong>围绕MySQL有一大堆监控和运维的工具，安装和使用很方便</strong>。</p>
<h1 id="关于python3中默认的数据库：SQLite"><a href="#关于python3中默认的数据库：SQLite" class="headerlink" title="关于python3中默认的数据库：SQLite"></a>关于python3中默认的数据库：SQLite</h1><p>SQLite是一种嵌入式数据库，它的数据库就是<strong>一个文件</strong>。由于SQLite本身是C写的，而且体积很小，所以，经常被集成到各种应用程序中，甚至在iOS和Android的App中都可以集成。</p>
<p>Python就内置了SQLite3，所以，在Python中使用SQLite，不需要安装任何东西，直接使用。</p>
<ol>
<li>表是数据库中存放关系数据的集合，一个数据库里面通常都包含多个表，比如学生的表，班级的表，学校的表，等等。表和表之间通过外键关联。</li>
<li>要操作关系数据库，首先需要<strong>连接到数据库</strong>，一个数据库连接称为Connection；</li>
<li>连接到数据库后，需要打开游标，称之为Cursor，<strong>通过Cursor执行SQL语句</strong>，然后，获得执行结果。</li>
<li>Python定义了一套操作数据库的<strong>API接口</strong>，任何数据库要连接到Python，只需要提供符合Python标准的数据库驱动即可。</li>
<li>由于SQLite的驱动内置在Python标准库中，所以我们可以直接来操作SQLite数据库。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入SQLite驱动:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="comment"># 连接到SQLite数据库</span></span><br><span class="line"><span class="comment"># 数据库文件是test.db</span></span><br><span class="line"><span class="comment"># 如果文件不存在，会自动在当前目录创建:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn = sqlite3.connect(<span class="string">&#x27;test.db&#x27;</span>)</span><br><span class="line"><span class="comment"># 创建一个Cursor:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor = conn.cursor()</span><br><span class="line"><span class="comment"># 执行一条SQL语句，创建user表:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor.execute(<span class="string">&#x27;create table user (id varchar(20) primary key, name varchar(20))&#x27;</span>)</span><br><span class="line">&lt;sqlite3.Cursor <span class="built_in">object</span> at <span class="number">0x10f8aa260</span>&gt;</span><br><span class="line"><span class="comment"># 继续执行一条SQL语句，插入一条记录:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor.execute(<span class="string">&#x27;insert into user (id, name) values (\&#x27;1\&#x27;, \&#x27;Michael\&#x27;)&#x27;</span>)</span><br><span class="line">&lt;sqlite3.Cursor <span class="built_in">object</span> at <span class="number">0x10f8aa260</span>&gt;</span><br><span class="line"><span class="comment"># 通过rowcount获得插入的行数:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor.rowcount</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment"># 提交事务:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.commit()</span><br><span class="line"><span class="comment"># 关闭Cursor:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor.close()</span><br><span class="line"><span class="comment"># 关闭Connection:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.close()</span><br></pre></td></tr></table></figure>
查询记录<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn = sqlite3.connect(<span class="string">&#x27;test.db&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor = conn.cursor()</span><br><span class="line"><span class="comment"># 执行查询语句:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor.execute(<span class="string">&#x27;select * from user where id=?&#x27;</span>, (<span class="string">&#x27;1&#x27;</span>,))</span><br><span class="line">&lt;sqlite3.Cursor <span class="built_in">object</span> at <span class="number">0x10f8aa340</span>&gt;</span><br><span class="line"><span class="comment"># 获得查询结果集:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values = cursor.fetchall()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values</span><br><span class="line">[(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;Michael&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.close()</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h2><ol>
<li>使用Python的DB-API时，只要搞清楚<strong>Connection和Cursor对象</strong>，打开后一定记得关闭（否则会出现资源的泄露），就可以放心地使用。</li>
<li>使用Cursor对象执行insert，update，delete语句时，执行结果由<strong>rowcount</strong>返回影响的行数，就可以拿到执行结果。</li>
<li>使用Cursor对象执行select语句时，通过fetchall()可以拿到结果集。结果集是一个list，每个元素都是一个tuple，对应一行记录。</li>
<li>如果SQL语句带有参数，那么需要把参数按照位置传递给execute()方法，有几个?占位符就必须对应几个参数</li>
</ol>
<h1 id="在python中连接MySQL"><a href="#在python中连接MySQL" class="headerlink" title="在python中连接MySQL:"></a>在python中连接MySQL:</h1><p>使用MySQL的原因：MySQL是Web世界中使用最广泛的数据库服务器。<strong>SQLite的特点是轻量级</strong>、<strong>可嵌入</strong>，<strong>但不能承受高并发访问</strong>，<strong>适合桌面和移动应用</strong>。而MySQL是为服务器端设计的数据库，<strong>能承受高并发访问</strong>，同时<strong>占用的内存也远远大于SQLite</strong>。<br>为什么要连接？（这一步可以跳过，自己已经连接好了）<br>由于MySQL服务器以独立的进程运行，并通过网络对外服务，所以，需要支持Python的MySQL驱动来连接到MySQL服务器。MySQL官方提供了mysql-connector-python驱动，但是安装的时候需要给pip命令加上参数–allow-external：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 自己已经试验成功的，没有啥问题</span><br><span class="line"># 以下为如何连接到MySQL服务器的test数据库：</span><br><span class="line"># 由于Pythonde DB-API定义都是以通用的，操作MySQL的数据库代码和SQLite类似。</span><br><span class="line">&gt;&gt;&gt; import mysql.connector</span><br><span class="line">&gt;&gt;&gt; conn = mysql.connector.connect(user=&#x27;root&#x27;, password=&#x27;xr1806144220092&#x27;,database=&#x27;test&#x27;)</span><br><span class="line">&gt;&gt;&gt; cursor = conn.cursor()</span><br><span class="line">&gt;&gt;&gt; cursor.execute(&#x27;create table user (id varchar(20) primary key, name varchar(20))&#x27;)</span><br><span class="line">&gt;&gt;&gt; cursor.execute(&#x27;insert into user (id, name) values (%s, %s)&#x27;, [&#x27;1&#x27;, &#x27;Michael&#x27;])</span><br><span class="line">&gt;&gt;&gt; cursor.rowcount</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; conn.commit()</span><br><span class="line">&gt;&gt;&gt; cursor.close()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; cursor = conn.cursor()</span><br><span class="line">&gt;&gt;&gt; cursor.execute(&#x27;select * from user where id = %s&#x27;, (&#x27;1&#x27;,))</span><br><span class="line">&gt;&gt;&gt; values = cursor.fetchall()</span><br><span class="line">&gt;&gt;&gt; values</span><br><span class="line">[(&#x27;1&#x27;, &#x27;Michael&#x27;)]</span><br><span class="line">&gt;&gt;&gt; cursor.close()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; conn.close()</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="使用SQLAlchemy"><a href="#使用SQLAlchemy" class="headerlink" title="使用SQLAlchemy"></a>使用SQLAlchemy</h2><p>可以用Python的数据结构表示出来，用list表示多行，list的每一个元素是tuple,但是用tuple表示一行很难看出表的结构。如果<strong>把一个tuple用class实例来表示</strong>，就可以更容易地看出表的结构来：<br>更多关于ORM框架的知识可以后面去学习</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也即ORM技术：把关系数据库的表映射到对象上</span></span><br><span class="line"><span class="comment"># 用ORM框架来做转换（SQLAlchemy）</span></span><br><span class="line"><span class="comment"># ORM就是把数据库表的行与列相应的对象建立关联，互相转换</span></span><br><span class="line"><span class="comment"># 由于关系数据库的多个表还可以用外键实现一对多、多对多等关联，相应地，ORM框架也可以提供两个对象之间的一对多、多对多等功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">id</span>, name</span>):</span><br><span class="line">        self.<span class="built_in">id</span> = <span class="built_in">id</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    User(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;Michael&#x27;</span>),</span><br><span class="line">    User(<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>),</span><br><span class="line">    User(<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="数据模型："><a href="#数据模型：" class="headerlink" title="数据模型："></a>数据模型：</h1><p>按照数据结构来组织、存储和管理数据，一共有三种模型：</p>
<ol>
<li>层次模型：上下级的层次关系来组织数据的方式，像一颗树</li>
<li>网状模型：把每个数据节点和其他的很多节点连接起来，像很多城市的路网</li>
<li>关系模型：二维表格，像一个excel表格<br><img src="https://runnerxr.github.io//post-images/1651190998091.png"><br><img src="https://runnerxr.github.io//post-images/1651191007546.png"><br><img src="https://runnerxr.github.io//post-images/1651191015075.png"><br>主流的关系数据库：</li>
<li>商用数据库：Oracle，SQL Server，DB2</li>
<li>开源数据库：MySQL，PostgreSQL等</li>
<li>桌面数据库：以微软Access为代表，适合桌面应用程序使用</li>
<li>嵌入式数据库：以Sqlite为代表，适合手机应用和桌面程序</li>
</ol>
<p>SQL语言定义了几种操作数据库的能力：</p>
<ol>
<li><p>DDL(Data Definition Language):允许用户定义数据，创建表、删除表、修改表结构等</p>
</li>
<li><p>DML(Data Manipulation Language):为用户提供添加、删除、更新数据的能力（应用程序对数据库的日常操作）</p>
</li>
<li><p>DQL(Data Query Language):允许用户查询数据，这也是通常最频繁的数据库日常操作</p>
</li>
<li><p>表的每一行称为记录（Record），记录是一个逻辑意义上的数据。</p>
</li>
<li><p>表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。</p>
</li>
<li><p>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为NULL。注意NULL表示字段数据不存在。一个整型字段如果为NULL不表示它的值为0，同样的，一个字符串型字段为NULL也不表示它的值为空串’’。</p>
</li>
<li><p>关系数据库的表和表之间需要建立“一对多”，“多对一”以及“一对一”的关系（<strong>按照应用程序的逻辑来组织和存储数据</strong>）</p>
</li>
<li><p>在关系数据库中，关系通过主键和外键来维护</p>
</li>
</ol>
<h1 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h1><ol>
<li><strong>主键是关系表中记录的唯一标识</strong>。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。<strong>主键也不应该允许NULL</strong>。</li>
<li>可以使用多个列作为联合主键（允许通过多个字段唯一标识记录，用两个或更多的字段都设置为主键），但联合主键并不常用。</li>
</ol>
<h1 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h1><ol>
<li>外键就可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证</li>
<li>多对多：通过一个表的外键关联到另一个表，我们可以定义出一对多的关系，同时也有多对多的关系(多对多的关系是通过两个一对多关系实现的，通过一个中间表，关联两个一对多关系，就形成了多对多关系)<br><img src="https://runnerxr.github.io//post-images/1651798689687.png"><br><img src="https://runnerxr.github.io//post-images/1651798696639.png"><br><img src="https://runnerxr.github.io//post-images/1651798703145.png"><br>通过中间表teacher_class知道teachers和class的关系</li>
<li>id&#x3D;1的张老师对应id&#x3D;1,2的一班和二班</li>
<li>id&#x3D;2的王老师对应id&#x3D;1,2的一班和二班</li>
<li>id&#x3D;3的李老师对应id&#x3D;1的一班</li>
<li>id&#x3D;4的赵老师对应id&#x3D;2的二班<br>也可以知道classes到teachers的关系</li>
<li>id&#x3D;1的一班对应id&#x3D;1,2,3的张老师、王老师和李老师</li>
<li>id&#x3D;2的二班对应id&#x3D;1,2,4的张老师、王老师和赵老师<br><strong>相关的一些代码：</strong><br>外键不是通过列名实现的，而是通过定义外键约束来实现的<br>ALTER TABLE students<br>ADD CONSTRAINT fk_class_id<br>FOREIGN KEY (class_id)<br>REFERENCES classes (id);<br>要删除一个外键约束，通过ALTER TABLE实现的：<br>ALTER TABLE students<br>DROP FOREIGN KEY fk_class_id;</li>
</ol>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p>
<ol>
<li>通过堆数据库表创建索引，可以提高查询速度</li>
<li>通过创建唯一索引，可以保证，某一列的值具有唯一性</li>
<li>数据库索引对于用户和应用程序都是透明的</li>
</ol>
<h1 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h1><p>练习：自动创建test数据库，并在test数据库下创建students表和classes表，以及必要的初始化数据步骤如下：<br><img src="https://runnerxr.github.io//post-images/1651885146959.png"><br>mysql -u root -p<br>输入密码：xr1806144220092<br><img src="https://runnerxr.github.io//post-images/1651885162682.png"><br>把sql的文件上传到服务器上面去：source E:\init-test-data.sql  (文件放在了E盘下面)<br>回车之后就会发现已经成功了，之后就是<br><img src="https://runnerxr.github.io//post-images/1651885205646.png"><br>show databases;（实现数据库）<br>show tables from test;</p>
<h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><p>SELECT * FROM &lt;表名&gt;  （可以查询一个表的所有行和所有列的数据）<br><img src="https://runnerxr.github.io//post-images/1651969510813.png"><br>其中SELECT是关键字，表示将要执行一个查询，*表示“所有列”，FROM表示将要从哪个表查询，本例中是students表。该SQL将查询出students表的所有数据，查询的结果是一个二维表，它包含列名和每一行的数据。<br>SELECT * FROM classes;  （查询所有表的数据）<br><img src="https://runnerxr.github.io//post-images/1651969531524.png"><br>SELECT 1;（来测试数据库连接）<br><img src="https://runnerxr.github.io//post-images/1651969568520.png"><br>use test;（切换到数据库）<br>还有一个问题亟待解决：文字乱码的问题（后面解决）</p>
<ol>
<li>内容替换：把文件里的charset&#x3D;utf-8字样改为charset&#x3D;gb2312</li>
<li>编码转换：把记事本中：格式-字体 保存成gb2312，文件保存时设置成ansi的编码方式。</li>
</ol>
<h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>使用背景：很多时候，我们并不希望获得所有记录，而是根据条件选择性地获取指定条件的记录，例如，查询分数在80分以上的学生记录。在一张表有数百万记录的情况下，获取所有记录不仅费时，还费内存和网络带宽。<br>语句：SELECT * FROM students WHERE score &gt;&#x3D; 80;<br>公式化：SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;<br><img src="https://runnerxr.github.io//post-images/1651970004534.png"><br>如果是存在两个条件的，需要把两个条件都写出来<br>条件表达式可以用&lt;条件1&gt; AND &lt;条件2&gt;表达满足条件1并且满足条件2。例如，符合条件“分数在80分或以上”，并且还符合条件“男生”，把这两个条件写出来：</p>
<ol>
<li>条件1：根据score列的数据判断：score &gt;&#x3D; 80；</li>
<li>条件2：根据gender列的数据判断：gender &#x3D; ‘M’，注意gender列存储的是字符串，需要用单引号括起来。</li>
<li>WHILE条件为：score &gt;&#x3D; 80 AND gender &#x3D; ‘M’<br>按照AND条件查询students:<br>SELECT * FROM students WHILE score &gt;&#x3D;80 ANDgender &#x3D; ‘M’;<br><img src="https://runnerxr.github.io//post-images/1651970261734.png"><br>第二种条件：&lt;条件1&gt;OR&lt;条件2&gt;，表示满足条件1或条件2，以下的结果是查询“分数在80分或以上或男生”，满足任意之一的条件就可以选出该记录。OR比AN要宽松很多<br>SELECT * FROM students WHERE score &gt;&#x3D; 80 OR gender &#x3D; ‘M’;<br><img src="https://runnerxr.github.io//post-images/1651970861524.png"><br>第三种条件：NOT&lt;条件&gt;，表示不符合该条件的记录<br>SELECT * FROM students WHERE NOT class_id &#x3D; 2;（不是二班的学生）<br><img src="https://runnerxr.github.io//post-images/1651971815585.png"><br>要组合三个或更多的条件，需要用（）表示如何进行条件运算<br>SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender &#x3D; ‘M’;<br><img src="https://runnerxr.github.io//post-images/1651972039858.png"><br>常用的一些表达式<br><img src="https://runnerxr.github.io//post-images/1651972118574.png"></li>
</ol>
<h2 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h2><p>使用SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;可以选出表中的若干条记录。我们注意到返回的二维表结构和原表是相同的，即结果集的所有列与原表的所有列都一一对应。<br>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用SELECT 列1, 列2, 列3 FROM …，让结果集仅包含指定列。这种操作称为投影查询。<br>例子一：SELECT id, score, name FROM students;（从学生中查询序号、分数、姓名 ）<br><img src="https://runnerxr.github.io//post-images/1652407572995.png"><br>SELECT 列1, 列2, 列3 FROM …，可以给每一个列取一个别名，这样结果集的列名就可以与原表的列名不同，语法是：SELECT  列1 别名1，列2 别名2，列3 别名3 FROM…<br>例子二：SELECT id, score points, name FROM students;(用SELECT语句将列名score重命名为point,而且id和name列名保持不变)<br><img src="https://runnerxr.github.io//post-images/1652408057875.png"><br>可以接WHILE条件，实现复杂的查询<br>例子三：SELECT id,score points,name FROM students WHERE gender &#x3D; ‘M’;<br><img src="https://runnerxr.github.io//post-images/1652408275502.png"><br>小结如下：</p>
<ol>
<li>使用SELECT *表示查询表的所有列，使用SELECT 列1, 列2, 列3则可以仅返回指定列，这种操作称为投影。</li>
<li>SELECT语句可以对结果集的列进行重命名。</li>
</ol>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>对于使用SELECT查询的时候，查询的结果通常是按照id排序的（根据主键排序），这是大部分数据库的做法，如果想要根据其他的条件排序的话，可以用ORDER BY子句<br>例子一：SELECT id,name,gender,score FROM students order by score;(按照score从低到高)<br><img src="https://runnerxr.github.io//post-images/1652409136146.png"><br>如果score列有相同的数据，要进一步排序，可以继续添加列名，使用ORDER BY score DESC,gender表示先按score列排序，如果有相同的分数，再按照gender列排序<br>例子二：SELECT id,name,gender, score FROM students ORDER BY score DESC,gender;(按照score,gender排序)<br><img src="https://runnerxr.github.io//post-images/1652409078094.png"><br>默认的排序规则是ASC:升序，即从小到大，ASC可以省略，ORDER BY score ASC 和ORDER BY score效果一样，如果有WHERE子句，那么ORDER BY 子句要放到WHERE子句后面<br>例子三：带WHERE条件的ORDER BY:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查询一班的学生成绩，并按照倒序排序</span><br><span class="line"># 结果集合仅包含符合WHERE条件的记录，并按照ORDER BY的设定排序</span><br><span class="line">SELECT id ,name,gender,score</span><br><span class="line">FROM students</span><br><span class="line">WHERE class_id = 1</span><br><span class="line">ORDER BY score DESC;</span><br></pre></td></tr></table></figure>
<p><img src="https://runnerxr.github.io//post-images/1652409830358.png"></p>
<h3 id="小结如下："><a href="#小结如下：" class="headerlink" title="小结如下："></a>小结如下：</h3><ol>
<li>使用ORDER BY可以对结果集进行排序</li>
<li>可以对多列升序、倒序排序</li>
</ol>
<h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>使用SELECT查询时，数据量很大的时候，放在一个页面显示数据量太大，可以分页显示每次显示100条。<br>如何实现分页功能：</p>
<ol>
<li>从结果集中显示第1<del>100条记录作为第一页，显示101</del>200条记录作为第二页</li>
<li>归纳如下：从结果集中’截取’出第M~N条记录，查询可以通过LIMIT <N-M> OFFSET <M>子句实现<br>以下为一些实现的过程：<br>第一步：SELECT id ,name,gender, score FROM students ORDER BY score DESC;<br><img src="https://runnerxr.github.io//post-images/1652410994899.png"><br>第二步：把结果集分页，每页3条记录，要获取第一页的记录，可以使用LIMIT 3 OFFSET 0:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查询第一页</span><br><span class="line">SELECT id, name,gender,score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 0;   # 对结果集从0号记录开始，最多取3条，注意SQL记录集的索引从0开始</span><br></pre></td></tr></table></figure>
<img src="https://runnerxr.github.io//post-images/1652411073802.png"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查询第2页，将OFFSET  3(跳过前3条)</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 3;</span><br></pre></td></tr></table></figure>
<img src="https://runnerxr.github.io//post-images/1652411195906.png"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查询第3页，将OFFSET  6(跳过前6条)</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 6;</span><br></pre></td></tr></table></figure>
<img src="https://runnerxr.github.io//post-images/1652411370903.png"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查询第4页，将OFFSET  9(跳过前9条)</span><br><span class="line"># 最后一页只有一条记录</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 9;</span><br></pre></td></tr></table></figure>
<img src="https://runnerxr.github.io//post-images/1652411454402.png"></li>
</ol>
<h3 id="总结如下："><a href="#总结如下：" class="headerlink" title="总结如下："></a>总结如下：</h3><p>分页的关键在于首先要确定每页需要显示的结果数量pageSize(3),然后根据当前页的索引pageindex（从1开始），确定LIMIT和OFFSET应该设定的值，然后就能正确的查询出第N页的记录集</p>
<ol>
<li>LIMIT总是设定为pageSize</li>
<li>OFFSET计算公式为pageSize *(pageIndex -1)</li>
<li>如果OFFSET超过了查询的最大的数量并不会报错，会得到一个空的结果集（例如最多有10条的，但是我编写LIMIT 3 OFFSET 20, 只能得到一个空的结果集）</li>
<li>OFFSE是可选的，如果只写LIMIT 15，相当于LIMIT 15 OFFSET 0</li>
<li>LIMIT 15 OFFSET 30 可以简写为LIMIT 30,15（OFFSET就是截取的意思，截取（30，30+15]之间的）</li>
<li>使用LIMIT <M> OFFSET <N>,N越大，查询的效率也会越来的越低</li>
</ol>
<h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><p>对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。<br>仍然以查询students表一共有多少条记录为例，我们可以使用SQL内置的COUNT()函数查询：<br>例子一：SELECT COUNT(*) FROM students;    (使用聚合查询学生总数)<br><img src="https://runnerxr.github.io//post-images/1652423682028.png"></p>
<p>COUNT(<em>):<br>表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但**查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT(</em>)*<em>。<br>通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果：<br>SELECT COUNT(</em>) num FROM students;<br>COUNT(<em>)和COUNT(id)实际上是一样的效果，聚合查询同样可以使用WHERE条件，我们可以方便的统计出有多少男生、多少女生、多少80分以上的学生等<br>例子：SELECT COUNT(</em>)  boys FROM students WHERE gender &#x3D; ‘M’;<br><img src="https://runnerxr.github.io//post-images/1652424175061.png"><br>除了COUNT()函数外，SQL还提供了如下的聚合函数：<br>SUM:  计算某一列的合计值，该列必须为数值类型<br>AVG:  计算某一列的平均值 ，且必须为数值类型<br>MAX:  …(不限数值类型，会返回排序最后的字符)<br>MIN:   ….(不限数值类型，会返回排序最前的字符)<br>例子：SELECT AVG(score) average FROM students WHERE gender &#x3D; ‘M’;(使用聚合查询计算男生平均的成绩)<br><img src="https://runnerxr.github.io//post-images/1652424541717.png"><br><strong>注意点</strong>：如果聚合查询WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM() 、AVG()  MAX()  MIN()会返回NULL<br><strong>question</strong>:每页三条记录，如何通过聚合查询获得总页数：SELECT CEILING(COUNT(*)&#x2F;3) FROM students;</p>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>SELECT COUNT(<em>) num FROM students WHERE class_id &#x3D; 1;可以用来查询1班的学生数量，<br>如果像继续统计二班、三班的学生数量的话，SQL提供了一个<strong>分组聚合</strong>的功能<br>按照class_id进行分组：SELECT COUNT(</em>) num FROM students GROUP BY class_id;<br><img src="https://runnerxr.github.io//post-images/1652425662691.png"><br>GROUP BY 子句指定了按class_id分组，因此，在执行SELECT语句的时，会把class_id相同的列先分组，再分别计算，得到3行结果，但是有一个缺陷，无法看出分别时哪三个班级，我们可以把class_id列的结果放入结果集合中：<br>SELECT class_id, COUNT(<em>) num FROM students GROUP BY class_id;(可以十分清晰的看出各个班级的学生人数)<br><img src="https://runnerxr.github.io//post-images/1652426009213.png"><br>也可以使用多个列进行分组，比如想统计各班的男生和女生人数：<br>SELECT class_id , gender ,COUNT(</em>) num FROM students GROUP BY class_id, gender;(按照class_id和gender进行分组，以下的6条记录分别对应3个班的男生和女生的人数)<br><img src="https://runnerxr.github.io//post-images/1652426546777.png"><br><strong>questions</strong>:使用一条select查询出每个班级的平均分：SELECT class_id,AVG(score) average FROM students GROUP BY class_id;<br><strong>questions</strong>:使用一条select查询出每个班级男生和女生的平均分：SELECT class_id,gender, AVG(score) average FROM students GROUP BY class_id, gender;</p>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>SELECT查询不仅可以从一张表查询数据，还可以从多张表中同时查询数据，语法如下：SELECT *FROM &lt;表1&gt; &lt;表2&gt;<br>SELECT * FROM students,classes;  (同时从students和classes表的乘积，即查询数据)<br>一次查询两个表的数据，查询的结果也是一个二维表，是students表和classes表的乘积，即students表的每一行与classes表的每一行都两两拼在一起返回，<strong>结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积</strong>，其中有两列id（分别是students表和class表的id）和两列name(分别是students表和class表的name),<strong>但是在结果集中却无法区分</strong><br><strong>解决的方法</strong>：利用投影查询的’设置列的别名’来给两个表各自的id和name起别名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">        students.id sid,</span><br><span class="line">        students.name,</span><br><span class="line">        students.gender,</span><br><span class="line">        students.score,</span><br><span class="line">        classes.id cid,</span><br><span class="line">        classes.name cname</span><br><span class="line">FROM students, classes;</span><br></pre></td></tr></table></figure>
<p>注意点：多表查询时，要<strong>使用表名.列名这样的方式来引用列和设置别名</strong>，这样就避免了结果集的列名重复的问题，但是当每个表的列数很多的时候就会很麻烦，<br><strong>解决办法</strong>：SQL允许给表设置一个别名，让在投影查询中引用起来稍微简洁一点:<strong>用别名s和c分别表示students表和classes表。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">        s.id sid,</span><br><span class="line">        s.name,</span><br><span class="line">        s.gender,</span><br><span class="line">        c.score,</span><br><span class="line">        c.id cid,</span><br><span class="line">        c.name cname</span><br><span class="line">FROM students s, classes c;</span><br></pre></td></tr></table></figure>
<p>多表查询也可以添加WHERE条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">        s.id sid,</span><br><span class="line">        s.name,</span><br><span class="line">        s.gender,</span><br><span class="line">        s.score,</span><br><span class="line">        c.id cid,</span><br><span class="line">        c.name cname</span><br><span class="line">FROM students s, classes c</span><br><span class="line">WHERE s.gender = &#x27;M&#x27; AND c.id = 1;</span><br></pre></td></tr></table></figure>
<p>这个表的特点：结果集每行记录都满足条件s.gender &#x3D; ‘M’和c.id &#x3D; 1,<strong>添加WHERE条件后结果集的数量大大减少</strong>。</p>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>连接查询是另一种类型的多表查询，连接查询对多个表进行JOIN运算：先确定一个主表作为结果集，<strong>然后把其他表的行有选择性的“连接”在主表结果集上</strong>。<br>举例说明：<br>SELECT s.id, s.name, s.class_id, s.gender, s.score FROM students s;<br>运行的结果如下：<br><img src="https://runnerxr.github.io//post-images/1652431502891.png"><br>增加需求：我们希望结果集合中包含所在班级的名称，上面的结果集只有class_id列，缺少name列<br>解决办法：根据students表的class_id，找到classes表对应的行，再取出name列就可以获得班级名称，<strong>使用最常用的内部连接——INNER JOIN来实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.id, s.name, s.class_id,c.name class_name, s.gender,s.score</span><br><span class="line">FROM students s</span><br><span class="line">INNER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure>
<p><img src="https://runnerxr.github.io//post-images/1652432970173.png"><br>INNER JOIN查询的写法的注意事项：</p>
<ol>
<li>先确定主表：FROM&lt;表1&gt;</li>
<li>再确定需要连接的表：INNER JOIN &lt;表2&gt;</li>
<li>然后确定连接的条件：使用ON&lt;条件…&gt;,这里的条件是：<strong>s.class_id &#x3D; c.id</strong>,表示students表的class_id列与classes表的id列相同的行需要连接。</li>
<li>可选：加上WHERE子句、ORDER BY等子句<br>如果是使用OUTER JOIN <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.id, s.name, s.class_id,c.name class_name, s.gender,s.score</span><br><span class="line">FROM students s</span><br><span class="line">RIGHT OUTER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure>
<img src="https://runnerxr.github.io//post-images/1652433048521.png"><br><strong>比较INNER JOIN和OUTER JOIN的结果</strong></li>
<li>多出了一行是’四班’，与学生相关的列name  gender score 都为NULL,students表中并不存在class_id&#x3D;4的行</li>
<li>有RIGHT OUTER JOIN 就有LEFT OUTER JOIN以及FULL OUTER JOIN <ol>
<li>INNER JOIN只返回同时存在于两张表的行数据</li>
<li>RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。</li>
<li>EFT OUTER JOIN则返回左表都存在的行。</li>
</ol>
</li>
</ol>
<p>使用图来表示结果集，相应的结果就是一目了然<br><img src="https://runnerxr.github.io//post-images/1652433705231.png"></p>
<h1 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h1><p>增删改查 ：Create Retrieve Update Delete<br>对应的语法：</p>
<ol>
<li>INSERT:插入新的记录</li>
<li>UPDATE:更新已有的记录</li>
<li>DELETE:删除已有的记录</li>
</ol>
<h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><p>基本语法：INSERT INTO &lt;表名&gt; (字段1, 字段2, …) VALUES (值1, 值2, …);<br>举例说明：向students表中插入一条新记录，先列举出需要插入的字段名称，然后在VALUES子句中依次写出对应字段的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (class_id, name,gender,score) VALUES (2,&#x27;大牛&#x27; ,&#x27;M&#x27; ,80);</span><br><span class="line">SELECT *FROM students;</span><br></pre></td></tr></table></figure>
<p><img src="https://runnerxr.github.io//post-images/1652434865938.png"><br>还可以一次性添加多条记录，只需要在VALUE子句中指定多个记录，每个记录是由（…）包含的一组值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (class_id,name,gender,score) VALUES</span><br><span class="line">    (1,&#x27;大宝&#x27;,&#x27;M&#x27;,87),</span><br><span class="line">    (1,&#x27;二宝&#x27;,&#x27;M&#x27;,81)</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure>
<h2 id="dudata"><a href="#dudata" class="headerlink" title="dudata"></a>dudata</h2><p>基本语句：UPDATE &lt;表名&gt; SET 字段1&#x3D;值1, 字段2&#x3D;值2, … WHERE …;<br>需求：想更新students表id&#x3D;1的记录的name和score这两个字段，先写出<strong>UPDATE students SET name &#x3D; ‘大牛’，scores&#x3D;66</strong>,然后在WHERE子句中写出需要更新的行的筛选条件：<strong>id&#x3D;1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--更新id=1的记录</span><br><span class="line">UPDATE students SET name = &#x27;大牛&#x27;，score=66 WHERE id=1;</span><br><span class="line">--查询并观察结果</span><br><span class="line">SELECT * FROM students WHERE id=1;</span><br></pre></td></tr></table></figure>
<p>在此基础上，一次更新多条记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE students SET name = &#x27;大牛&#x27;，score=77 WHERE id&gt;=5 AND id&lt;=7;</span><br><span class="line">SELECT *FROM sudents;</span><br></pre></td></tr></table></figure>
<p><img src="https://runnerxr.github.io//post-images/1652436296166.png"></p>
<h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><p>在MYSQL clinet中输入的SQL语句通过TCPO连接发送到MySQL Sever,默认的端口是3306，即如果发送到本机MYSQL Sever，地址就是127.0.0.1：3306<br>也可以只只安装MySQL Lient,然后连接到远程MySQL Sever<br>命令运行程序mysql实际上是MySQL客户端，真正的MySQL服务器程序是myqld,在后台运行。<br>要管理MYSQL，可以使用可视化图形界面My Workbench，是一个图形的客户端，它对MYSQL的操作是发送SQL语句并执行.MySQL Workbench 和MySQL交互，唯一的接口就是SQL<br>在一个运行MySQL的服务器上，<strong>实际上可以创建多个数据库</strong>（Datebase),要列出所有的数据库有如下的：<br>mysql&gt; SHOW DATABASES;<br>+——————–+<br>| Database           |<br>+——————–+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| shici              |<br>| sys                |<br>| test               |<br>| school             |<br>+——————–+<br>informaiton_schema  mysql  performace_scheam和sys是系统库，不需要去改动，其他的是用户创建的数据库</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/29/SQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" data-id="claqum2dc0009h0tk61d4dw08" data-title="SQL数据库的相关知识" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-关于字典树与并查集" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/16/%E5%85%B3%E4%BA%8E%E5%AD%97%E5%85%B8%E6%A0%91%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="article-date">
  <time class="dt-published" datetime="2022-04-16T15:42:40.000Z" itemprop="datePublished">2022-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/16/%E5%85%B3%E4%BA%8E%E5%AD%97%E5%85%B8%E6%A0%91%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86/">关于字典树与并查集</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="leetcoad208-实现Trie（前缀树）"><a href="#leetcoad208-实现Trie（前缀树）" class="headerlink" title="leetcoad208-实现Trie（前缀树）"></a>leetcoad208-实现Trie（前缀树）</h1><p> N叉树：每个节点可能包含m-1个值且可以有m个子节点<br>B树：n叉树的一种特例，广泛用于磁盘的访问（还有其他的一些性质没有补充进来）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般的多叉树的节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    VALUETYPE value;    <span class="comment">//结点值</span></span><br><span class="line">    TreeNode* children[NUM];    <span class="comment">//指向孩子结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字典树的节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    <span class="type">bool</span> isEnd; <span class="comment">//该结点是否是一个串的结束</span></span><br><span class="line">    TrieNode* next[<span class="number">26</span>]; <span class="comment">//字母映射表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ol>
<li>先明白它的节点设计，TrieNode中没有直接保存字符值的数据或成员</li>
<li>TrieNode* next[26]中保存了对当前节点而言下一个可能出现的所有字符的链接，可以通过父节点来预知它所有子节点的值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">    <span class="keyword">if</span> (parentNode-&gt;next[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        说明父结点的后一个字母不可为 ch</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        说明父结点的后一个字母可以是 ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字典树：tire是一种 N 叉树，前缀树，字典树、单词查找树(更是一种哈系数的变种)<br>前缀树是N叉树的一种特殊形式。通常来说，一个前缀树是用来存储字符串的。前缀树的每一个节点代表一个字符串（前缀）。每一个节点会有多个子节点，通往不同子节点的路径上有着不同的字符。子节点代表的字符串是由节点本身的原始字符串，以及通往该子节点路径上所有的字符组成的。用于高效存储和检索字符串数据集中的键。<br>改变二叉树里面节点的存储方式，字典树每个节点不再是存放单词本身，而是把字符串拆成单个单个的字母<br>基本性质：</p>
<ol>
<li>节点本身不存完整单词</li>
<li>从根节点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串</li>
<li>每个结点的所有子节点路径代表的字符都不相同。<br>核心思想：</li>
<li>空间换时间</li>
<li>利用字符串的公共前缀来降低查询时间的开销达到提高效率的目的<br>应用场景：自动补充和拼音检查，统计、排序和保存大量的字符串（不仅限于字符串）[一次建树，多次查询]<br>优点：利用字符串的公共前缀来减少查询时间，最大限度的减少无谓的字符串比较，查询效率比哈希树高<br>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46202073/article/details/107253959">https://blog.csdn.net/m0_46202073/article/details/107253959</a><br><img src="https://runnerxr.github.io/post-images/1650163178779.jpg"></li>
</ol>
<p><strong>方法一：采用哈希集合来解题：</strong><br>前缀树里面有一个好大好大的字典：键：值，键：值….,键：值。其中值又可以切分成新的字典，不断的套娃实现字典树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这种最基本的方式是必须要完完全全掌握清楚的，然后形成自己的模板形式，记下来备用。</span></span><br><span class="line"><span class="comment"># 使用哈希表来构建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="comment"># 先构建一个字典</span></span><br><span class="line">        self.root=&#123;&#125;</span><br><span class="line">		<span class="comment"># 一个单词的结束字符,该路径是否形成了一个有效的字符串</span></span><br><span class="line">        self.isEnd = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 描述：插入一个字符</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 先拷贝这个root结点</span></span><br><span class="line">        nownode = self.root</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> word:</span><br><span class="line">			<span class="comment"># 如果这个字母不在这个nownode字典里面，相当于没有创建链条来连接</span></span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> nownode:</span><br><span class="line">                <span class="comment"># 创建下一个结点</span></span><br><span class="line">                nownode[s]=&#123;&#125;</span><br><span class="line">            <span class="comment"># nownode指向下一个结点</span></span><br><span class="line">            nownode= nownode[s]</span><br><span class="line">		<span class="comment"># 插入结束后，将，插入一个标识符，并将值改为：True</span></span><br><span class="line">        <span class="comment"># 对于每插入一个字符串，都会在里面加入一个isend=True的键值对</span></span><br><span class="line">        nownode[self.isEnd] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 描述：查找Trie中是否存在单词word</span></span><br><span class="line">	<span class="comment"># 实现：从根节点的子节点开始，一直向下匹配，如果出现节点值为空就返回false，如果匹配到最后一个字符，只需判断  该字符是不是单词的末尾</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        nownode = self.root</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">in</span> nownode:</span><br><span class="line">                nownode= nownode[s]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">		<span class="comment"># 看这个标识符是否在字典里面，如果在说明之前插入过这个</span></span><br><span class="line">        <span class="keyword">if</span> self.isEnd <span class="keyword">in</span> nownode:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 描述：判断Trie中是或有以prefix为前缀的单词</span></span><br><span class="line">    <span class="comment"># 实现：和search的操作比较类似，只是不需要判断最后一个字符节点，能匹配到最后一个字符，那后面一定有单词是以它为前缀的</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        nownode = self.root</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">in</span> prefix:</span><br><span class="line">                nownode = nownode[s]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><strong>方法二：采用字典树解题：</strong><br>对于search的实现：</p>
<ol>
<li>采用一个布尔判断：判断是不是字符的末尾</li>
<li>或者用一个特殊的字符：在最后的时候加入一个结束符，每次走到最后的节点的时候，看有没有这样的一个结束符</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 采用字典树,建TrieNode结构结点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.children = &#123;&#125;</span><br><span class="line">        self.isEnd = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = TrieNode()</span><br><span class="line">    </span><br><span class="line">	<span class="comment"># 描述：插入一个字符</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        nownode= self.root</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> word:</span><br><span class="line">            <span class="comment"># 如果s不在任何一个分支上的话(不在nownode的孩子里面),也即没有一个字母是有的</span></span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span>  nownode.children:</span><br><span class="line">                <span class="comment"># 添加一个nownode.children[s]做成的Trie的形式</span></span><br><span class="line">                <span class="comment"># 随着数据的不断插入，需要不断的创建TrieNode节点</span></span><br><span class="line">                nownode.children[s]=TrieNode()</span><br><span class="line">            nownode = nownode.children[s]</span><br><span class="line">        nownode.isEnd=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 描述：查找Trie中是否存在单词word</span></span><br><span class="line">	<span class="comment"># 实现：从根节点的子节点开始，一直向下匹配，如果出现节点值为空就返回false，如果匹配到最后一个字符，只需判断  该字符是不是单词的末尾</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        nownode=self.root</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> word:</span><br><span class="line">            <span class="comment"># 如果这个字母没有在nownode的子节点里面</span></span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> nownode.children:</span><br><span class="line">                <span class="comment"># 直接返回False</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 如果在这个结点里面，就指向下一个结点</span></span><br><span class="line">            nownode= nownode.children[s]</span><br><span class="line">        <span class="comment"># 返回终止符的标记。</span></span><br><span class="line">        <span class="comment"># 如果最终的标识符是False，表明给定的单词实际上没有走完一个原本插入的路径，自然搜不到</span></span><br><span class="line">        <span class="comment"># 如果最终的标识符是True，表明给定的单词走完了一个完整的路径，已经搜索到了。</span></span><br><span class="line">        <span class="keyword">return</span> nownode.isEnd</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 描述：判断Trie中是或有以prefix为前缀的单词</span></span><br><span class="line">    <span class="comment"># 实现：和search的操作比较类似，只是不需要判断最后一个字符节点，能匹配到最后一个字符，那后面一定有单词是以它为前缀的</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        nownode=self.root</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> nownode.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            nownode= nownode.children[s]</span><br><span class="line">        <span class="comment"># 直接返回true即可</span></span><br><span class="line">        <span class="comment"># 因为不需要标识符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>这两种方法进行比较的过程:</p>
<ol>
<li>一个是采用哈希表的方法（不断的字典套字典的过程），一个是采用的构建字典树的方法</li>
<li>用isEnd这个标识符也不太一样，在哈希表里面就是一个键，它的值是False&#x2F;True(单词末尾会变成True),在字典树里面，isEnd这个包含在TrieNode里面了</li>
<li>在search中的判断条件不一样：</li>
</ol>
<h1 id="leetcoad720-词典中的最长单词"><a href="#leetcoad720-词典中的最长单词" class="headerlink" title="leetcoad720-词典中的最长单词"></a>leetcoad720-词典中的最长单词</h1><p>这道题是自己和陈刚一起做过的一道，实际上自己提交的版本并没有把它真正的弄懂，弄清楚<br>暴力解题的思路：</p>
<ol>
<li>单词必须最长，因此找出列表中最长的单词</li>
<li>单词必须由其它短的单词组成，因此要写个在长单词里找短单词的func  set()的查询是O(1)的</li>
<li>找到符合要求的单词后按字典序排列</li>
</ol>
<p>采用哈希集合的方式：</p>
<ol>
<li>单词必须最长，且要按照字典序进行排序，因此找出列表中最长的单词，字符串长度按照降序排列，如果字符串相同，字典序按照升序排列（用到了排序的思想）</li>
<li>对排序后的字符进行一个个的遍历，对选定的某个字符进行切分至最末尾，查看切分的是否在集合内</li>
<li>返回第一个所有切分的字符都是集合里面（因为前面已经运用了贪心排序的思想，那样第一个就是题目要求的那一个）</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：采用哈希集合,这种方式是自己必须要掌握的形式。本地调试的过程很重要，相应的思路要深深的刻在自己的脑袋里面。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestWord</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 创建一个words的无序的无重复的set集合</span></span><br><span class="line">        words_set = <span class="built_in">set</span>(words)</span><br><span class="line">        <span class="comment"># print(words_set)</span></span><br><span class="line">        <span class="comment"># 对words进行一个排序，其中key = lambda s:[-len(s), s]为排序的准则，有两个准则，</span></span><br><span class="line">        <span class="comment"># 将字符串按从大到小的顺序排列，如果字符串长度相同的时候，按照x的大小按照从小到大的顺序排列（按照字典序进行排序）</span></span><br><span class="line">        <span class="comment"># 如果能够满足单词是由一个个单词逐步添加一个字母而成的，就可以找到，有贪心的思想在里面，会特别的快 ，很可能第一个数就能够满足</span></span><br><span class="line">        words.sort(key = <span class="keyword">lambda</span> s:[-<span class="built_in">len</span>(s), s])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;排序后的words为--&gt;&#x27;</span>,words)</span><br><span class="line">        <span class="comment"># 在排序好的words中进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="comment"># 这里加入一行打印，主要是为了理解这里的过程</span></span><br><span class="line">                <span class="built_in">print</span>(s[:i])</span><br><span class="line">                <span class="comment"># 对于选定的s,判断从索引为0一直倒索引为i-1的字符是否在words_set这个集合中</span></span><br><span class="line">                <span class="keyword">if</span> s[:i] <span class="keyword">not</span> <span class="keyword">in</span> words_set:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> s</span><br><span class="line">        <span class="comment"># 如果在整个过程中都没有找到，直接返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 输入一个特定的需要求解的数组</span></span><br><span class="line">    words=[<span class="string">&quot;w&quot;</span>,<span class="string">&quot;wo&quot;</span>,<span class="string">&quot;wor&quot;</span>,<span class="string">&quot;worl&quot;</span>,<span class="string">&quot;world&quot;</span>]</span><br><span class="line">    <span class="comment"># words = [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;]</span></span><br><span class="line">    res = Solution().longestWord(words)</span><br><span class="line">    <span class="comment">#print(res)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;  输出 =&gt; &quot;</span> ,res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># 主要是为了理解为什么要创建set集合：为了便于好定位</span></span><br><span class="line"><span class="comment"># &#123;&#x27;wor&#x27;, &#x27;worl&#x27;, &#x27;world&#x27;, &#x27;wo&#x27;, &#x27;w&#x27;&#125;</span></span><br><span class="line"><span class="comment"># 排序后的words为--&gt; [&#x27;world&#x27;, &#x27;worl&#x27;, &#x27;wor&#x27;, &#x27;wo&#x27;, &#x27;w&#x27;](这里的排序按照字符串长度递减，字典序递增的方式)</span></span><br><span class="line"><span class="comment"># w</span></span><br><span class="line"><span class="comment"># wo</span></span><br><span class="line"><span class="comment"># wor</span></span><br><span class="line"><span class="comment"># worl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 =&gt;  world</span></span><br></pre></td></tr></table></figure>
<p>采用前缀树+DFS的方法</p>
<ol>
<li>将所有单词插入trie，然后从trie进行深度优先搜索，每找到一个单词表示该单词的全部前缀均存在，我们选取长度最长的单词</li>
<li>在python中，我们使用defaultdict的方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="leetcoad211-添加与搜索单词-数据结构设计"><a href="#leetcoad211-添加与搜索单词-数据结构设计" class="headerlink" title="leetcoad211-添加与搜索单词-数据结构设计"></a>leetcoad211-添加与搜索单词-数据结构设计</h1><p>采用的方法：字典树+DFS<br>理解题目的意思：设计一个数据结构，支持添加新单词和查找字符串是否与任何先前添加的字符串匹配，并且还有一个模糊查找的功能，也是这一题的难点所在。（这题没有这么简单，if嵌套的东西特别的多）<br>构建：</p>
<ol>
<li>根节点不保存任何信息，<strong>保存chilldren是使用的字典，相应的保存结构是{字符：Node}</strong></li>
<li>关键词放到「前缀树」时，需要把它拆成各个字符，每个字符按照字母表的顺序，放到children对应的位置。</li>
<li>一个字符串构建结束的时候，把该结点的endword 标记为True(这里有一个关键点：并不是达到叶子节点才形成一个关键字，只要endword是True就行)<br>附上一张图片辅助理解：c和cv都是加入的字符串，两个的endword都是True<br>对于’.’的处理：<br>在匹配的过程中，如果遇到’.’需要对当前结点的所有子树进行遍历，<strong>只要有任何一个子树能够最终完成匹配，那就代表能够匹配完成</strong><br><img src="https://runnerxr.github.io/post-images/1650630747310.jpeg"><br><img src="https://runnerxr.github.io/post-images/1650635845318.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对字典树和哈希集合+DFS有了深入的了解后再来回顾！！！！！</span><br><span class="line"></span><br><span class="line">以下的算例没有通过。</span><br><span class="line"><span class="comment"># [&quot;WordDictionary&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;search&quot;,&quot;search&quot;,&quot;addWord&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [[],[&quot;at&quot;],[&quot;and&quot;],[&quot;an&quot;],[&quot;add&quot;],[&quot;a&quot;],[&quot;.at&quot;],[&quot;bat&quot;],[&quot;.at&quot;],[&quot;an.&quot;],[&quot;a.d.&quot;],[&quot;b.&quot;],[&quot;a.d&quot;],[&quot;.&quot;]]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="并查集：Union-Find"><a href="#并查集：Union-Find" class="headerlink" title="并查集：Union Find"></a>并查集：Union Find</h1><h2 id="相关的系类题目：（牢牢理解并掌握）"><a href="#相关的系类题目：（牢牢理解并掌握）" class="headerlink" title="相关的系类题目：（牢牢理解并掌握）"></a>相关的系类题目：（牢牢理解并掌握）</h2><ol>
<li>leetcoad128:最长连续的序列</li>
<li>leetcoad130:被围绕的区域(**)</li>
<li>leetcoad200:岛屿数量</li>
<li>leetcoad547：省份数量</li>
<li>leetcoad399:除法求值</li>
<li>leetcoad695-岛屿的最大面积</li>
</ol>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Q5411H7v5">https://www.bilibili.com/video/BV1Q5411H7v5</a><br>union:合并两个元素为同一个根节点(将两个子集合并成同一个集合)<br>Find:找到某个和元素的根节点(可以被用来确定两个元素是否属于同一个子集，加入路径压缩，复杂度近乎O(1))<br>用于解决动态连通性的问题，能动态连接两个点，并判断两个点是否连通，处理元素的合并与查询问题,组团或配对的问题，任给两个人是不是朋友的问题<br><img src="https://runnerxr.github.io/post-images/1650185586256.jpg"><br><img src="https://runnerxr.github.io/post-images/1650507755861.png"><br><img src="https://runnerxr.github.io/post-images/1650528457231.png"></p>
<ol>
<li>先初始化：count和parent ,其中parent[i]&#x3D;i</li>
<li>如何寻找给定任何一个数p，怎么找它的集合是谁（如何找它集合和它集合的领头元素），不能用parent[p]&#x3D;p,需要不断的向上找它的parent,直到parent[i]&#x3D;i（数组的索引&#x3D;索引对应的元素）,说明找到了它所在集合的领头元素<ul>
<li>不断的把parent[p]赋给p本身的一个过程（不断的往上找parent，最后找到root的一个过程：p[root]&#x3D;&#x3D;root）</li>
<li>把p它的爷爷节点直接赋给现在的parent[p]直接往上多窜了一层</li>
</ul>
</li>
<li>如何进行union的操作<ul>
<li>首先调用find找出它的p的集合所在的领头元素，找出来之后赋给rootP</li>
<li>另外的找q赋给rootQ</li>
<li>如果它们两个相等的话就不用管，如果相等的话，把其中一个rootP放在括号里面，或者两个替换一下：把rootP的parent弄成rootQ(反过来也行)，相当于把这两个集合合并在一起了。</li>
<li>count–:里面独立的集合就减少一个（在最后输出后就表示有多少孤立的集合）<br>java的实现过程：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用一个UnionFind类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line">    <span class="comment">//两个成员变量count和parent</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//count初始化一个数组长度</span></span><br><span class="line">        count =n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//数组parent初始：parent[i] = i,是指向指针的关系，和数组是相同的道理</span></span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接下来就是一个寻找的过程,给定任何一个数p,找它的集合的领头的过程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p!=parent[p])&#123;</span><br><span class="line">            <span class="comment">// 不断的往上找parent的过程</span></span><br><span class="line">            <span class="comment">// 把p爷爷的节点直接赋给现在的parent[p].,直接往上多窜了一层</span></span><br><span class="line">            parent[p] = parent[parent[p]];</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如何进行union的合并操作，在上一步中调用find找到p的领头元素</span></span><br><span class="line">    <span class="comment">// 把集合p q合并的一个过程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="comment">// 找出p的领头元素赋给rootP</span></span><br><span class="line">        <span class="type">int</span> rootP= find(p);</span><br><span class="line">        <span class="type">int</span> rootQ= find(q);</span><br><span class="line">        <span class="comment">// 如果两者相等直接返回</span></span><br><span class="line">        <span class="keyword">if</span> （rootP==rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果两者不相等的话，把rootP的parent弄成rootQ，将两个集合合并在一起了</span></span><br><span class="line">        parent[rootP]= rootQ; </span><br><span class="line">        <span class="comment">// 里面的独立集合就减少了一个  </span></span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="python模板一："><a href="#python模板一：" class="headerlink" title="python模板一："></a>python模板一：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化的过程</span></span><br><span class="line"><span class="comment">#  for i =0...n:p[i]=i</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="comment"># 每一个数，它的祖先都是它自己</span></span><br><span class="line">    p = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># parent代码，不断的去找p[root]的过程（就是find函数，换了一个名字好理解）</span></span><br><span class="line"><span class="comment"># 这一段代码也是比较抽象和晦涩难懂的一部分</span></span><br><span class="line"><span class="comment"># 其中p是一个集合，root既是索引也是值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_parent</span>(<span class="params">self,p,i</span>):</span><br><span class="line">    <span class="comment"># 把i赋给root,不断的找p[i]=i这件事，通过下面的代码找到它的root，root满足的条件就是p[root]==root</span></span><br><span class="line">    root = i</span><br><span class="line">    <span class="comment"># 同java的版本一起理解，这里用两个while循环替换递归的操作（可能更好理解，本质上是一样的）</span></span><br><span class="line">    <span class="comment"># 第一个循环终止条件：p[root]=root</span></span><br><span class="line">    <span class="keyword">while</span> p[root] != root:</span><br><span class="line">        root = p[root]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第一个循环结束之后</span></span><br><span class="line">    <span class="comment"># 路径压缩，把沿路上所有的parent[i]让它等于i，也可以不做，直接返回root(写了可以减少检索时间)</span></span><br><span class="line">    <span class="comment"># 把原本间接与根节点相连的节点，让它与根直接相连</span></span><br><span class="line">    <span class="comment"># 第二个循环终止条件：p[i]=i</span></span><br><span class="line">    <span class="keyword">while</span> p[i] != i:</span><br><span class="line">        <span class="comment"># 交换了一下，继续往上，再走</span></span><br><span class="line">        x ,i,p[x] = i,p[i],root</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="comment"># union的过程：把i和j对应的根节点p1和p2合并在一起的这样一个过程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_union</span>(<span class="params">self,p,i,j</span>):</span><br><span class="line">    <span class="comment"># 调用parent找到i和j的根节点</span></span><br><span class="line">    p1 = self._parent(p,i)</span><br><span class="line">    p2 = self._parent(p,j)</span><br><span class="line">    <span class="comment"># 如果相等，表明i和j本来就是连在一起的</span></span><br><span class="line">    <span class="keyword">if</span> p1==p2:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 把p1的parent用p2赋值过去</span></span><br><span class="line">    p[p1]=p2</span><br></pre></td></tr></table></figure>
<h2 id="python模板二："><a href="#python模板二：" class="headerlink" title="python模板二："></a>python模板二：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 附上另外的一个python模板(辅助理解，代码的书写上有一些差别，但是个人感觉在理解之后写出来的会更加的清爽)</span></span><br><span class="line"><span class="comment"># 写一个UnionFind类，后面也是直接就拿来用的那种(这里题目的原型是岛屿的数量问题，加入了count变量)</span></span><br><span class="line"><span class="comment"># 这里定义了__init__方法，但是在后面没有将root传入进去，所以后面有用到root的地方都要用到self</span></span><br><span class="line"><span class="comment"># 这样对写代码提出了要求，但是阅读起来更加的直观，find就只用传入一个参数，union传入两个参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,grid</span>):</span><br><span class="line">        row=<span class="built_in">len</span>(grid)</span><br><span class="line">        col=<span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 单个集合的个数</span></span><br><span class="line">        n=row*col</span><br><span class="line">        <span class="comment"># 表明最初的孤立的集合数量为n个</span></span><br><span class="line">        <span class="comment"># 后面随着不断地连通，相应的孤立集合就减少</span></span><br><span class="line">        self.count=n</span><br><span class="line">        <span class="comment"># self.root=[i for i in range(n)]</span></span><br><span class="line">        <span class="comment"># 如果觉得上面的初始化的方式不好理解，可以采用下面的方式</span></span><br><span class="line">        self.root=[-<span class="number">1</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            self.root[i]=i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self,p</span>):</span><br><span class="line">        <span class="comment"># 如果节点p正好和它对应的根节点相同</span></span><br><span class="line">        <span class="keyword">if</span> p==self.root[p]:</span><br><span class="line">            <span class="keyword">return</span> self.root[p]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.root[p]=self.find(self.root[p])</span><br><span class="line">            <span class="keyword">return</span> self.root[p]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 然后是union函数部分</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self,p,q</span>):</span><br><span class="line">        <span class="comment"># 分别调用find函数找到节点p和q的根节点</span></span><br><span class="line">        rootP=self.find(p)</span><br><span class="line">        rootQ=self.find(q)</span><br><span class="line">        <span class="comment"># 如果它们的根节点不相同才需要合并（相同的时候不需要合并）</span></span><br><span class="line">        <span class="keyword">if</span> rootP!=rootQ:</span><br><span class="line">            <span class="comment"># 任取一个加入到另外一个上</span></span><br><span class="line">            root[rootP]=rootQ</span><br><span class="line">            <span class="comment"># 一旦进行合并，孤立的集合就减少</span></span><br><span class="line">            self.count-=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="python模板二（优化）："><a href="#python模板二（优化）：" class="headerlink" title="python模板二（优化）："></a>python模板二（优化）：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,grid</span>):</span><br><span class="line">        row=<span class="built_in">len</span>(grid)</span><br><span class="line">        col=<span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 看有多少个数</span></span><br><span class="line">        self.root = [-<span class="number">1</span>]*(row*col)</span><br><span class="line">        self.count = row*col</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row*col):</span><br><span class="line">            self.root[i]=i</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="keyword">if</span> x == self.root[p]:</span><br><span class="line">            <span class="keyword">return</span> self.root[p]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 嵌套了一个小的递归函数，进行了Quick Find的优化过程</span></span><br><span class="line">            <span class="comment"># 这里是需要重点理解</span></span><br><span class="line">            self.root[p] = self.find(self.root[p])</span><br><span class="line">            <span class="keyword">return</span> self.root[p]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        rootP = self.find(p)</span><br><span class="line">        rootQ = self.find(q)</span><br><span class="line">        <span class="comment"># 当两个根节点不相同的时候具体应该怎么做的问题</span></span><br><span class="line">        <span class="keyword">if</span> rootP != rootQ:</span><br><span class="line">            <span class="comment"># P的根节点的权重大于Q的根节点的权重</span></span><br><span class="line">            <span class="keyword">if</span> self.rank[rootP]&gt;self.rank[rootQ]:</span><br><span class="line">                <span class="comment"># 将Q的根节点改为P（把Q的部分黏到P下面）</span></span><br><span class="line">                root[rootQ]=rootP</span><br><span class="line">            <span class="keyword">elif</span> self.rank[rootP]&lt;self.rank[rootQ]:</span><br><span class="line">                root[rootP]=rootQ</span><br><span class="line">            <span class="comment"># 两者的权重相同的时候</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 将Q的根节点改为P</span></span><br><span class="line">                root[rootQ]=rootP</span><br><span class="line">                <span class="comment"># 此时P的权重就要在之前的基础上+1</span></span><br><span class="line">                self.rank[rootP]+=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这里也整理几道相对简单一点的并查集相关的题目练练手：</p>
<h2 id="leetcoad128-最长连续序列"><a href="#leetcoad128-最长连续序列" class="headerlink" title="leetcoad128-最长连续序列"></a>leetcoad128-最长连续序列</h2><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（<strong>不要求序列元素在原数组中连续</strong>）的长度。<br>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。<br>输入：nums &#x3D; [100,4,200,1,3,2]<br>输出：4<br>解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</p>
<p>输入：nums &#x3D; [0,3,7,2,5,8,4,6,0,1]<br>输出：9<br>分析思路：<br>咋一看的时候，发现之前是有一道题叫：<strong>最长连续递增序列</strong>，两道题目描述的也不太一样，那道题条件要严格一些：最长+连续+递增，在这题里面原数组是不要求连续的，但是<strong>组成的序列最后是要连续的</strong>。常规的思路的话可以直接将该无序的数组进行排序，然后按照最长连续递增的思路求出来就行了。</p>
<ol>
<li>找到一个数字之后，然后找到它的左边和右边，根据它左边和右边的长度来更新当前我循环到的值（更新我自己）</li>
<li><strong>更新左边界和右边界的值</strong>（更新两头的边界值，这里是不太好理解的）</li>
</ol>
<p>用最暴力的解法应该也是没有问标题的，这里虽然不符合题目的要求，但是针对学习的话一定是不错的。<br>主要是思维能力很重要，当然代码也很重要</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">以下为采用哈希表的代码：</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestConsecutive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 新建一个哈希表，并理解哈希表中要存放的数字</span></span><br><span class="line">        <span class="comment"># key：每个nums中的元素，value：包含当前key的连续区间的长度</span></span><br><span class="line">        hashmap=<span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 新进来哈希表一个数</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                <span class="comment"># 获取当前函数最左边的连续长度，没有的话就更新为0</span></span><br><span class="line">                left=hashmap.get(num-<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 获取右边的数</span></span><br><span class="line">                right=hashmap.get(num+<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 将当前数组加入哈希表代表当前数字出现过，任意值都是可以的</span></span><br><span class="line">                hashmap[num]=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 更新长度</span></span><br><span class="line">                length=left +<span class="number">1</span>+ right</span><br><span class="line">                <span class="comment"># 更新结果值</span></span><br><span class="line">                <span class="comment"># res=max(res,length)</span></span><br><span class="line">                <span class="keyword">if</span> length&gt;res:</span><br><span class="line">                    res=length</span><br><span class="line">                <span class="comment"># 只更新端点值，中间的值是不需要处理的</span></span><br><span class="line">                <span class="comment"># 更新最左端的值，如果left=n存在，那么证明当前的数的前n个都存在哈希表中</span></span><br><span class="line">                hashmap[num-left]=length</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 更新最右端点的值，如果right=n存在，那么证明当前数的后n个都存在哈希表中</span></span><br><span class="line">                hashmap[num+right]=length</span><br><span class="line">                <span class="comment"># 此时[num-left,num-right]的值都连续存在哈希表中了</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums=[<span class="number">100</span>,<span class="number">4</span>,<span class="number">200</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">    res=Solution().longestConsecutive(nums)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<p>运用动态规划的思路也是可以求解的，解这道题的时候参考了  <strong>最长连续递增序列的动态规划的思路解法</strong>，在该方法的基础上，先进行排序，然后不断地更新dp数组地值，在更新的时候存在两个状态，后面的一个值与前面值相差1，第二种状态是后面的值与前面的值相等。其实也是很好理解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestConsecutive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先将序列排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        maxlength=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 然后用最长连续递增子序列的思路来做，用到动态规划</span></span><br><span class="line">        dp=[<span class="number">1</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="comment"># 保证后面的数比前面的数大，而且要是连续的</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]-nums[i-<span class="number">1</span>]==<span class="number">1</span>:</span><br><span class="line">                dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i]==nums[i-<span class="number">1</span>]:</span><br><span class="line">                dp[i]=dp[i-<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> dp[i]&gt;maxlength:</span><br><span class="line">                maxlength=dp[i]</span><br><span class="line">        <span class="keyword">return</span> maxlength</span><br></pre></td></tr></table></figure>
<p>本着学知识的态度，自己想用并查集的思路来解决这道题<br>最主要的是要<strong>找连续的序列</strong>：数字的连续就是相邻的两个元素相差1，这里就很巧妙的用到了并查集的思想：<strong>将最小的元素作为根节点</strong>，对于1 2 3 4   8 9 10这些元素来说，1就是2 3 4这些元素的根节点，8 就是9 10的根节点。也即所有在一个连续区间内的元素都会在一个连通的分量中，且这些元素的根节点都为最远的右边界元素。具体的思路如下：</p>
<ol>
<li>遍历所有的元素，如果num+1存在，将num加入到num+1所在的连通分量中</li>
<li>重新遍历一遍所有的元素num，通过find函数找到num所在分量的根节点，也即最远的右边界，从而求得连续区间的长度<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这种方法真的有点不好写，而且效率有点低</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,nums</span>):</span><br><span class="line">        self.parent=&#123;num:num <span class="keyword">for</span> num <span class="keyword">in</span> nums&#125;</span><br><span class="line">        self.count=collections.defaultdict(<span class="keyword">lambda</span>:<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(self.parent)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self,x</span>):</span><br><span class="line">        <span class="keyword">while</span> x!=self.parent[x]:</span><br><span class="line">            x=self.parent[x]</span><br><span class="line">            self.parent[x]=self.parent[self.parent[x]]</span><br><span class="line">        <span class="keyword">return</span> self.parent[x]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self,p,q</span>):</span><br><span class="line">        <span class="keyword">if</span> q <span class="keyword">not</span> <span class="keyword">in</span> self.parent:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># 调用find函数找到对应的根节点</span></span><br><span class="line">        rootP,rootQ=self.find(p),self.find(q)</span><br><span class="line">        <span class="comment"># 比较根节点</span></span><br><span class="line">        <span class="keyword">if</span> rootP==rootQ:</span><br><span class="line">            <span class="keyword">return</span> self.count[rootP]</span><br><span class="line">        <span class="comment"># 如果根节点不相等的话需要，将任意一个加入另一个上面去</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.parent[rootP]=rootQ</span><br><span class="line">            <span class="comment"># 对应的以rootQ为根节点的序列长度会增加</span></span><br><span class="line">            self.count[rootQ]+=self.count[rootP]</span><br><span class="line">            <span class="keyword">return</span> self.count[rootQ]</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestConsecutive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        res=<span class="number">1</span></span><br><span class="line">        uf=UnionFind(nums)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            res=<span class="built_in">max</span>(res,uf.union(num,num+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="leetcoad-130被围绕的区域"><a href="#leetcoad-130被围绕的区域" class="headerlink" title="leetcoad-130被围绕的区域"></a>leetcoad-130被围绕的区域</h2><p>给你一个 m x n 的矩阵 board ，由若干字符 ‘X’ 和 ‘O’ ，找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。<br><img src="https://runnerxr.github.io/post-images/1652764164562.jpg"><br>输入：board &#x3D; [[“X”,”X”,”X”,”X”],[“X”,”O”,”O”,”X”],[“X”,”X”,”O”,”X”],[“X”,”O”,”X”,”X”]]<br>输出：[[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”O”,”X”,”X”]]<br>解释：被围绕的区间<strong>不会存在于边界上</strong>，换句话说，任何边界上的 ‘O’ 都<strong>不会被填充为 ‘X’<strong>。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。</strong>如果两个元素在水平或垂直方向相邻，则称它们是“相连”的</strong>。<br>自己的思维过程：如果用并查集应该具体怎么做？<br>有几个需要注意的地方：</p>
<ol>
<li><strong>被包围的区域不会存在于边界上</strong>，边界上的O要特殊的处理(读懂题目就是其中的一环)</li>
<li>只要把边界的O特殊处理了，剩下的O替换成X就可以了</li>
<li>问题转换为如何寻找和边界连通的O<br>先确定解题的思路（并查集）：这个思路很棒，十分巧妙而且合理，相当于把问题转化为最大岛屿的问题</li>
<li>当判断图中的两个点之间是否存在路径的时候，根据判断他们是否在一个连通区域内，<strong>这道题的本质：求解和边界的O在一个连通区域的问题</strong></li>
<li>把所有边界上的O看成一个连通区域，<strong>遇到O就执行并查集的合并操作</strong>，所有的O会被分为两类：<ol>
<li>和边界的 O在一个连通区域的，这些O需要保留</li>
<li>和边界的O不在一个连通区域的，这些O是被包围的，需要替换成X</li>
</ol>
</li>
<li>将二维坐标转化为一维坐标</li>
</ol>
<p>如果用深度优先搜索又应该怎么做的问题 </p>
<h2 id="leetcoad547-省份数量"><a href="#leetcoad547-省份数量" class="headerlink" title="leetcoad547-省份数量"></a>leetcoad547-省份数量</h2><p>没有重视这一题，发现自己在重新做的时候，问题还是有很多，其实题目应该是不难的，如果真的已经完全弄懂了。<strong>最开始的时候每个城市都属于不同的连通分量，在遍历矩阵的过程中，如果发现两个城市有相连的关系，则它们属于同一个连通分量，对它们进行合并，在遍历完之后，计算连通分量的总数就是省份的总数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写UnionFind模板的时候放在原类下面的情况</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findCircleNum</span>(<span class="params">self, isConnected: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isConnected:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># n为城市的数量</span></span><br><span class="line">        n=<span class="built_in">len</span>(isConnected)</span><br><span class="line">        <span class="comment"># self.parent为一个特定的数组</span></span><br><span class="line">        self.parent=[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># print(self.parent)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对数组进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果发现isConnected[i][j]==1</span></span><br><span class="line">                <span class="keyword">if</span> isConnected[i][j]==<span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 需要将i和j合并</span></span><br><span class="line">                    self.union(i,j)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最后要统计孤立的数量就需要用到set的去重操作</span></span><br><span class="line">        res=[self.find(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">        <span class="built_in">print</span>(self.parent)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">set</span>(res))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 以下为标准模板部分</span></span><br><span class="line">    <span class="comment"># 构建find函数</span></span><br><span class="line">    <span class="comment"># 并且采用递归的方式进行了相应的路径压缩</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self,x</span>):</span><br><span class="line">        <span class="keyword">if</span> self.parent[x]==x:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.parent[x]=self.find(self.parent[x])</span><br><span class="line">            <span class="keyword">return</span> self.parent[x]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 构建union函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self,p,q</span>):</span><br><span class="line">        <span class="comment"># 通过调用find函数来找到p q的根节点</span></span><br><span class="line">        rootP,rootQ=self.find(p),self.find(q)</span><br><span class="line">        <span class="comment"># 比较两个根节点</span></span><br><span class="line">        <span class="keyword">if</span> rootP==rootQ:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="comment"># 如果两个根节点不相同，就需要进行相应的合并</span></span><br><span class="line">        <span class="comment"># 将rootP连接到rootQ上面去</span></span><br><span class="line">        self.parent[rootP]=rootQ</span><br></pre></td></tr></table></figure>


<h1 id="leetcoad399-除法求值"><a href="#leetcoad399-除法求值" class="headerlink" title="leetcoad399:除法求值"></a>leetcoad399:除法求值</h1><p>题目描述：<br>给你一个<strong>变量对数组</strong> equations 和一个<strong>实数值数组</strong> values 作为已知条件，其中 equations[i] &#x3D; [Ai, Bi] 和 values[i] 共同表示等式 Ai &#x2F; Bi &#x3D; values[i] 。每个 Ai 或 Bi 是一个表示<strong>单个变量</strong>的字符串。<br>另有一些以数组 queries <strong>表示的问题</strong>，其中 queries[j] &#x3D; [Cj, Dj] 表示<strong>第 j 个问题</strong>，请你<strong>根据已知条件</strong>找出 Cj &#x2F; Dj &#x3D; ? 的结果作为答案。<br>返回 <strong>所有问题的答案</strong> 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。<br>注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。<br>示例 1：<br>输入：equations &#x3D; [[“a”,”b”],[“b”,”c”]], values &#x3D; [2.0,3.0],<br>queries &#x3D; [[“a”,”c”],[“b”,”a”],[“a”,”e”],[“a”,”a”],[“x”,”x”]]<br>输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]<br>解释：<br>条件：a &#x2F; b &#x3D; 2.0, b &#x2F; c &#x3D; 3.0<br>问题：a &#x2F; c &#x3D; ?, b &#x2F; a &#x3D; ?, a &#x2F; e &#x3D; ?, a &#x2F; a &#x3D; ?, x &#x2F; x &#x3D; ?<br>结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]</p>
<p>示例 2：<br>输入：equations &#x3D; [[“a”,”b”],[“b”,”c”],[“bc”,”cd”]], values &#x3D; [1.5,2.5,5.0], queries &#x3D; [[“a”,”c”],[“c”,”b”],[“bc”,”cd”],[“cd”,”bc”]]<br>输出：[3.75000,0.40000,5.00000,0.20000]</p>
<h1 id="leetcoad695-岛屿的最大面积"><a href="#leetcoad695-岛屿的最大面积" class="headerlink" title="leetcoad695-岛屿的最大面积"></a>leetcoad695-岛屿的最大面积</h1><p>题目描述：<br>给你一个大小为** m x n** 的二进制矩阵 grid 。<br>岛屿 是由一些<strong>相邻的 1 (代表土地) 构成</strong>的组合，这里的「相邻」要求<strong>两个 1 <strong>必须在</strong> 水平或者竖直</strong>的<strong>四个方向</strong>上 <strong>相邻</strong>。你可以假设 grid 的<strong>四个边缘</strong>都被 0（代表<strong>水</strong>）<strong>包围</strong>着。<br>岛屿的面积是岛上值为 1 的单元格的数目。<br>计算并返回 grid 中<strong>最大的岛屿面积</strong>。如果没有岛屿，则返回面积为 0<br><img src="https://runnerxr.github.io/post-images/1654017378787.jpg"><br>输入：grid &#x3D; [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>输出：6<br>解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。</p>
<p>自己解析：<br>首先这个题目肯定是既可以用并查集也可以用深度优先搜索来解题的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/16/%E5%85%B3%E4%BA%8E%E5%AD%97%E5%85%B8%E6%A0%91%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86/" data-id="claqum2dx001kh0tkd8j62aur" data-title="关于字典树与并查集" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer系类二题目" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/14/%E5%89%91%E6%8C%87offer%E7%B3%BB%E7%B1%BB%E4%BA%8C%E9%A2%98%E7%9B%AE/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T02:15:50.000Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/14/%E5%89%91%E6%8C%87offer%E7%B3%BB%E7%B1%BB%E4%BA%8C%E9%A2%98%E7%9B%AE/">剑指offer系类二题目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="剑指offer52-两个链表的第一个公共节点"><a href="#剑指offer52-两个链表的第一个公共节点" class="headerlink" title="剑指offer52-两个链表的第一个公共节点"></a>剑指offer52-两个链表的第一个公共节点</h1><p>题目描述：输入两个链表，找出它们的第一个公共节点。<br><img src="https://runnerxr.github.io/post-images/1653759440127.png"><br>解题的思路：</p>
<ol>
<li>采用双指针的解法，并且在遍历的过程中用到了三目运算符</li>
<li>两个指针在走到它们各自链表的结尾的时候需要跳到另一个链表的头开始遍历</li>
<li>最终它们要么在某一个节点相遇，要么在None相遇（也即没有相遇）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="comment"># 思考这是一道链表的题目，用什么方法比较好</span></span><br><span class="line">        <span class="comment"># 要找出公共节点，尝试使用双指针的思路来解题</span></span><br><span class="line">        <span class="comment"># 相交的位置的值是相同的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进行边界的判断</span></span><br><span class="line">        <span class="comment"># 如果两个链表其中一个为空的话</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 同时从两个链表的头部开始遍历</span></span><br><span class="line">        pA,pB=headA,headB</span><br><span class="line">        <span class="comment"># 指针pA和pB不断的向后遍历，直到找到相交点</span></span><br><span class="line">        <span class="comment"># 如果两个链表不相交，则None是它们的相交点，因此不会跳不出循环</span></span><br><span class="line">        <span class="keyword">while</span> pA!=pB:</span><br><span class="line">            <span class="comment"># 指针pA一开始在链表A上遍历，当走到链表A的尾部的时候（即指向None）,跳到链表B上面</span></span><br><span class="line">            pA=pA.<span class="built_in">next</span> <span class="keyword">if</span> pA <span class="keyword">else</span> headB</span><br><span class="line">            <span class="comment"># 指针pB一开始在链表B上遍历，当走到链表B的尾部的时候（即指向None）,跳到链表A上面</span></span><br><span class="line">            pB=pB.<span class="built_in">next</span> <span class="keyword">if</span> pB <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> pA</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="剑指offer54-二叉搜索树的第k大节点"><a href="#剑指offer54-二叉搜索树的第k大节点" class="headerlink" title="剑指offer54-二叉搜索树的第k大节点"></a>剑指offer54-二叉搜索树的第k大节点</h1><p>题目描述：给定一棵二叉搜索树，请找出其中第 k 大的节点的值。<br>基础知识：</p>
<ol>
<li>对于任意一个二叉搜索树<br>解题思路：</li>
<li>将二叉树按照中序遍历的方式输出</li>
<li>将中序遍历倒序输出</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthLargest</span>(<span class="params">self, root: TreeNode, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 解题思路：将二叉搜索树转换成为一个中序遍历的序列/链表</span></span><br><span class="line">        <span class="comment"># 然后将列表进行排序（倒序），输出相应的值</span></span><br><span class="line">        <span class="comment"># 实际上用一根线从右往左扫描就行了</span></span><br><span class="line">        <span class="comment"># 采用递归的写法（中序遍历）</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 遍历左子树</span></span><br><span class="line">                dfs(root.left)</span><br><span class="line">                <span class="comment"># 加入根节点</span></span><br><span class="line">                res.append(root.val)</span><br><span class="line">                <span class="comment"># 遍历右子树</span></span><br><span class="line">                dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>][k-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="剑指offer57I-和为s的两个数字"><a href="#剑指offer57I-和为s的两个数字" class="headerlink" title="剑指offer57I-和为s的两个数字"></a>剑指offer57I-和为s的两个数字</h1><p>输入一个<strong>递增排序</strong>的数组和一个数字s，在数组中<strong>查找两个数</strong>，使得<strong>它们的和正好是s</strong>。如果有<strong>多对</strong>数字的和等于s，则<strong>输出任意一对</strong>即可。<br>示例 1：<br>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[2,7] 或者 [7,2]<br>示例 2：<br>输入：nums &#x3D; [10,26,30,31,47,60], target &#x3D; 40<br>输出：[10,30] 或者 [30,10]</p>
<p>一开始自己做了一遍，用的元组的方法，不过最后只AC了70%的案例<br>这里附上相应的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        nums=<span class="built_in">tuple</span>(nums)</span><br><span class="line">        <span class="comment"># print(nums)</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 如果元素不在元组中，将该值加入元组中</span></span><br><span class="line">            <span class="keyword">if</span> target-nums[i] <span class="keyword">in</span> nums:</span><br><span class="line">                res.append(nums[i])</span><br><span class="line">                res.append(target-nums[i])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>看了题解之后，想到有更加有效的方法，整理如下：<br>利用<strong>哈希表</strong>可以通过遍历组合找到数组组合。用字典存储已经遍历的结果，如果target-c也在字典中，则输出[c,target-c]即为题目中需要的结果，时间和空间的复杂度均为O(N)<br>在考试的时候写出这样的答案我觉得已经不错了，只要是能够AC的，相比纯暴力的解法要好多了，也对哈希字典有了更多的了解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hashmap=<span class="built_in">dict</span>()</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 特殊情况的判定：nums的长度为1</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 如果发现target-c也在哈希表中，直接输出[c,target-c]</span></span><br><span class="line">            <span class="keyword">if</span> target-c <span class="keyword">in</span> hashmap:</span><br><span class="line">                <span class="keyword">return</span> [c,target-c]</span><br><span class="line">            hashmap[c]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    nums=[<span class="number">10</span>,<span class="number">26</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">47</span>,<span class="number">60</span>]</span><br><span class="line">    target=<span class="number">40</span></span><br><span class="line">    res=Solution().twoSum(nums,target)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<p>由于是<strong>排序的数组</strong>，可以使用双指针将空间复杂度降低为O(1)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 设置两个指针分别指向数组的开头和末尾位置</span></span><br><span class="line">        left,right=<span class="number">0</span>,n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;right:</span><br><span class="line">            <span class="comment"># 定义一个数组sum</span></span><br><span class="line">            <span class="built_in">sum</span>=nums[left]+nums[right]</span><br><span class="line">            <span class="comment"># 如果发现之和小于target</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>&lt;target:</span><br><span class="line">                <span class="comment"># 说明需要将左指针右移</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">sum</span>==target:</span><br><span class="line">                <span class="keyword">return</span> [nums[left],nums[right]]</span><br><span class="line">            <span class="comment"># 如果发现之和大于target,说明需要将右指针左移</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 循环结束仍没有返回</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<h1 id="剑指offer57II-和为s的连续正数序列"><a href="#剑指offer57II-和为s的连续正数序列" class="headerlink" title="剑指offer57II-和为s的连续正数序列"></a>剑指offer57II-和为s的连续正数序列</h1><p>自己采用的是暴力的解法，结果是超出了时间的限制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力解法</span></span><br><span class="line"><span class="comment"># 不能完全通过（AC大约70%）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findContinuousSequence</span>(<span class="params">self, target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        n=target//<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        res=[]</span><br><span class="line">        nums=[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># print(nums)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                temp=<span class="built_in">sum</span>(nums[i:j])</span><br><span class="line">                <span class="keyword">if</span> temp==target:</span><br><span class="line">                    res.append(nums[i:j])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>看看题解有没有什么比较好的方法：（滑动窗口的思路）<br><img src="https://runnerxr.github.io/post-images/1653728756744.png"><br><img src="https://runnerxr.github.io/post-images/1653728762861.png"><br>自己写的时候一直调试失败，打败我的真的是一些细节的部分，实在是太细了<br>调试了好几遍，还是在仔细对比K神的基础上才发现问题所在，有一些细节：</p>
<ol>
<li>当<code>sum&lt;target</code>的时候,此时需要先把右边窗口扩大后再加入到sum值中</li>
<li>当<code>sum&gt;target</code>的时候,需要sum中的值减小后，然后再将左侧的窗口向右滑动</li>
<li>当<code>sum=target</code>的时候，这个时候的窗口仍然需要滑动，sum值仍然需要更新<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据K神的代码更改的版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findContinuousSequence</span>(<span class="params">self, target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 采用滑动窗口的思路来解题</span></span><br><span class="line">        <span class="comment"># 滑动窗口用错方式了</span></span><br><span class="line">        <span class="comment"># n=target//2+1</span></span><br><span class="line">        <span class="comment"># nums=[i for i in range(1,n+1)]</span></span><br><span class="line">        <span class="comment"># 定义了三个值：分别是第一个，第二个以及两数之和</span></span><br><span class="line">        i,j,s=<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">        <span class="comment"># 用于储存结果</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            <span class="comment"># 此时的正是要求的区间值，加入结果数组中</span></span><br><span class="line">            <span class="keyword">if</span> s==target:</span><br><span class="line">                <span class="comment"># res.append(nums[i-1:j+1])</span></span><br><span class="line">                res.append(<span class="built_in">list</span>(<span class="built_in">range</span>(i, j + <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果发现之和小于目标值，将右边的值+1，同时将和更新</span></span><br><span class="line">            <span class="keyword">if</span> s&lt;=target:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">                s+=j</span><br><span class="line">            <span class="comment"># 如果发现之和大于目标值，将左边的值+1，同时将和更新</span></span><br><span class="line">            <span class="keyword">elif</span> s&gt;target:</span><br><span class="line">                s-=i</span><br><span class="line">                i+=<span class="number">1</span>      </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
后来仔细想了想，自己的代码就是在细节上没有处理好，当判定sum&#x3D;&#x3D;target的时候，也需要移动数和改变sum的值，这里摘录后面自己修改后的版本<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment"># 剑指offer58I-翻转单词顺序</span></span><br><span class="line">还有一个案例没有通过，没通过的主要原因：<span class="string">&quot;a good   example&quot;</span> ,在good和example这两个单词中间有两个空格，但是在我的代码中并没有将这个考虑进去。</span><br><span class="line">**发现问题**：原因是我在用split()函数的时候，没有区分split()和split(<span class="string">&quot; &quot;</span>)的区别</span><br><span class="line"><span class="number">1.</span> s.split()  :在用空格分割字符串的时候可以将多个空格连在一起进行分割</span><br><span class="line"><span class="number">2.</span> s.split(<span class="string">&#x27; &#x27;</span>) :在用空格分割的时候就会存在问题，因为有的单词之间存在多个空格的情况，比如说的这个例子</span><br><span class="line">![](https://runnerxr.github.io/post-images/<span class="number">1653730469306.</span>png)</span><br><span class="line">这种方法实际上是借用语言的特性，简单的调用内置的API函数来完成的</span><br><span class="line">```python</span><br><span class="line"><span class="comment"># 进行发现问题后通过的版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 翻转句子中的单词顺序，单词内的顺序不变，标点符号和普通字母一样处理</span></span><br><span class="line">        <span class="comment"># 采用字符串的空格的切分方式</span></span><br><span class="line">        <span class="comment"># 先将字符串中的多个空格转化为只有一个空格，并转化为列表的形式</span></span><br><span class="line">        a=s.split()</span><br><span class="line">        <span class="comment"># print(a)</span></span><br><span class="line">        <span class="comment"># 列表翻转</span></span><br><span class="line">        b=a[::-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># print(b)</span></span><br><span class="line">        <span class="comment"># 用join函数对字符串进行连接，同时去除头部和尾部的空格</span></span><br><span class="line">        res=<span class="string">&#x27; &#x27;</span>.join(b).lstrip().rstrip()</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
这里再次参考别人一些比较 优秀的解法：用双指针<br>具体的算法解析：</li>
<li>倒序遍历字符串，记录单词的左右索引边界i j </li>
<li>每确定一个单词的边界，则将其添加到单词的列表中</li>
<li>最终将单词的列表拼接为字符串，并返回</li>
</ol>
<p>如果采用自己编写函数的方式去解决的话就稍微偏麻烦一点（python的语言字符串不可变）<br>需要将字符串转化为可变的数据结构，在转化的过程中去除空格<br>具体的代码后面有空再另行整理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其他解法待整理：K神和官方题解</span></span><br></pre></td></tr></table></figure>

<h1 id="剑指offer58II-左旋转字符串"><a href="#剑指offer58II-左旋转字符串" class="headerlink" title="剑指offer58II-左旋转字符串"></a>剑指offer58II-左旋转字符串</h1><p>自己写的稍微有点简单</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseLeftWords</span>(<span class="params">self, s: <span class="built_in">str</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 左旋转本质就是字符串的切分</span></span><br><span class="line">        a=s[:n]</span><br><span class="line">        b=s[n:]</span><br><span class="line">        <span class="keyword">return</span> b+a</span><br></pre></td></tr></table></figure>
<p>有空的话建议看看K神的其他做法<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/solution/mian-shi-ti-58-ii-zuo-xuan-zhuan-zi-fu-chuan-qie-p/">https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/solution/mian-shi-ti-58-ii-zuo-xuan-zhuan-zi-fu-chuan-qie-p/</a></p>
<h1 id="剑指offer59I-滑动窗口的最大值（已经做过的）"><a href="#剑指offer59I-滑动窗口的最大值（已经做过的）" class="headerlink" title="剑指offer59I-滑动窗口的最大值（已经做过的）"></a>剑指offer59I-滑动窗口的最大值（已经做过的）</h1><p>自己独立做出来了，想想之前做的另外的一个版本的方法是怎么样的<br>在别处已经做完了，此处省略</p>
<h1 id="剑指offer59II-队列的最大值"><a href="#剑指offer59II-队列的最大值" class="headerlink" title="剑指offer59II-队列的最大值"></a>剑指offer59II-队列的最大值</h1><p>虽然是模仿的，但是也要追根溯源的把概念搞清楚<br>看到题解的时候发现这一部分写的十分的详细，而且内容也是特别的多，看来也是自己学习的一个地方呀，得好好整理一下，好好的补充一下知识点。我自己写的这种方式可能时间复杂度不同，需要满足O(1）的要求。所以还是得学习一下：<br>对于一个普通的队列，push_back 和 pop_front 的时间复杂度都是 O(1)，因此我们直接使用队列的相关操作就可以实现这两个函数。但是对于实现最大值有另外的理解<br><strong>解决思路：</strong><br>只需<strong>记住当前最大值</strong>出队后，队列里的<strong>下一个最大值</strong>即可（维护一个最大值的变量）。<br>具体方法是使用一个<strong>双端队列 deque</strong>，在每次入队时，如果 deque 队尾元素小于即将入队的元素 value，则将小于 value 的元素全部出队后，再将 value入队；否则直接入队。<br><img src="https://runnerxr.github.io/post-images/1653742753659.gif"><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/solution/jian-zhi-offer-59-ii-dui-lie-de-zui-da-z-0pap/">https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/solution/jian-zhi-offer-59-ii-dui-lie-de-zui-da-z-0pap/</a><br>说实话这一块的理解有点复杂，暂时不准备去管了。</p>
<h1 id="剑指offer61-扑克牌中的顺子"><a href="#剑指offer61-扑克牌中的顺子" class="headerlink" title="剑指offer61-扑克牌中的顺子"></a>剑指offer61-扑克牌中的顺子</h1><p>主要是要分析，当有两张大小王的时候，剩下的牌中，最大值与最小值的差值可以为多少的问题？<br>答案：除了大小王之后的其他的牌的最大值与最小值的差值不能超过4(下面是用的一张图来辅助理解的。有助于加深印象，也是本题的一个关键点)<br>用一个哈希表：看是否有重复的牌（有重复的肯定不能形成顺子）<br>根据题意，此 5张牌是顺子的 充分条件 如下：<br><img src="https://runnerxr.github.io/post-images/1653747990962.png"><br>    * 除大小王外，所有牌 无重复 ；<br>    * 设此 5 张牌中最大的牌为 maxcard ，最小的牌为 mincard （大小王除外），则需满足：<code>pythonmax−min&lt;5max - min &lt; 5 max−min&lt;5</code></p>
<p>  要自己来写：</p>
<ol>
<li>hashset+遍历<br>1. 遍历5张牌，遇到大小王就直接跳过<br>2. 判别重复：利用set实现判重<br>3. 或者最大最小的牌（需要借助辅助变量遍历统计得到）</li>
<li>排序之后再比较<br>1. 先对数组进行排序<br>2. 判别重复，通过遍历数组看nums[i]&#x3D;&#x3D;nums[i+1]<br>3. 获取最大与最小牌</li>
</ol>
<p>以下分别结合K神的两种解法的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 采用set集合+遍历的方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isStraight</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 看了K神的题解之后自己马上过来实际操作一下</span></span><br><span class="line">        hashset=<span class="built_in">set</span>()</span><br><span class="line">        mincard,maxcard=<span class="number">14</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 定义两个变量用来记录最大值与最小值，同时如果遇到0（表示是大小王，直接跳过）</span></span><br><span class="line">            <span class="keyword">if</span> c==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 不断地更新最大牌与最小牌的值</span></span><br><span class="line">            mincard=<span class="built_in">min</span>(mincard,c)</span><br><span class="line">            maxcard=<span class="built_in">max</span>(maxcard,c)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当遍历到c的时候发现重复了，有对子存在，直接返回False</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> hashset:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 将元素加入到set集合中</span></span><br><span class="line">            hashset.add(c)</span><br><span class="line">        <span class="comment"># 下面来判定最大值与最小值直接的差值是否小于5</span></span><br><span class="line">        <span class="keyword">return</span> maxcard-mincard &lt; <span class="number">5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 采用排序+遍历的方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isStraight</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 先对数组进行排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="comment"># 用一个数组记录0的个数</span></span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i]==<span class="number">0</span>:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i-<span class="number">1</span>]==nums[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 返回最终的结果</span></span><br><span class="line">        <span class="comment"># 因为已经经过了排序，所以最大值一定是最右边的数</span></span><br><span class="line">        <span class="comment"># 0的个数正好就是最小牌对应的下标（非王牌）</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">4</span>]-nums[count]&lt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h1 id="剑指offer62-圆圈中最后剩下的数字"><a href="#剑指offer62-圆圈中最后剩下的数字" class="headerlink" title="剑指offer62-圆圈中最后剩下的数字"></a>剑指offer62-圆圈中最后剩下的数字</h1><p>这题没有思路，做不出来？？（主要是没有找到规律）<br>看题解的之后再好好的整理一下，其实我的写法已经有那么一点接近了<br>是著名的约瑟环问题，可以采用动态规划的思路来解题<br>输入n,m，计入问题为<br><strong>从链表的角度来分析：</strong><br>假设当前删除的位置的idx，那么下一个要删除的位置是idx+m,由于当前的位置删除了，会往后移动一位，所以实际的下一个位置是：idx+m-1,由于数到末尾会从头继续需要取模：(idx+m-1)%n<br><img src="https://runnerxr.github.io/post-images/1653756671508.png"><br><strong>从数学的角度来看问题</strong><br>0 1 2 3 4<br>第一轮：从0开始的第三个数(总共5个数)，<strong>删除2 <strong>（原余数的下标）<br>剩余3 4 0 1<br>第二轮：从3开始的第三个数(总共4个数)，</strong>删除0</strong><br>剩余 1 3 4<br>第三轮：从1开始的第三个数(总共3个数)，<strong>删除4</strong><br>剩余 1 3 1 3<br>第四轮：从1开始的第三个数(总共2个数)，<strong>删除1</strong><br>剩余3 </p>
<p>根据分析的结果来反推是如何得到这样的一个3的：虽然自己已经明白了这样的一个过程，但是要我写却依然是无法写出来的<br>由于最后一定是剩下一个数，所以索引为0，现在反推在上一轮中该数在哪个索引？<br>（0+3）% 2&#x3D;1<br>在这个基础上继续的往上进行反推，当前索引为1的数，在本轮的上一轮中哪个索引？<br>（1+3）%3&#x3D;1<br>在这个基础上继续的往上进行反推，当前索引为1的数，在本轮的上一轮中哪个索引？<br>（1+3）%4&#x3D;0<br>在这个基础上继续的往上进行反推，当前索引为0的数，在本轮的上一轮中哪个索引？<br>（0+3）%5&#x3D;2<br>由于已经到了上一轮剩余的数字的个数为5的情况（等于给定数组的长度），此时<strong>不再向上反推</strong>，因为此时索引2就为原数组中<strong>经过这种方式的删除后剩余的元素</strong>：3</p>
<p>这里我又参考了另外的一个人题解：<strong>只关心最终活着的那个人的序号变化</strong>（感这句话说的非常好，在反推的时候就是在确定这个数的索引变化）<br>约瑟夫问题：<br><code>N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。</code></p>
<p><strong>问题的转化</strong>：<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/">https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/</a></p>
<p>还是用人来举例，给u每个人一个编号（索引值），每个人用字母代替<br><img src="https://runnerxr.github.io/post-images/1653754809436.png"><br>从8个人开始，每次杀掉一个人，去掉被杀掉的那个人，然后把杀掉的那个人<strong>之后的第一个人</strong>作为开头重新编号。</p>
<ol>
<li>第一次C被杀掉，人数变成7，D作为开头（最终活下来的G的编号从6–3）</li>
<li>第二次F被杀掉，人数变成6，G作为开头（最终活下来的G的编号从3–0）</li>
<li>第三次A被杀掉，人数变成5，B作为开头（最终活下来的G的编号从0–3）</li>
<li>第四次E被杀掉，人数变成4，G作为开头（最终活下来的G的编号从3–0）</li>
<li>第五次B被杀掉，人数变成3，D作为开头（最终活下来的G的编号从0–1）</li>
<li>第六次H被杀掉，人数变成2，D作为开头（最终活下来的G的编号从1–1）</li>
<li>第七次D被杀掉，人数变成1，G作为开头（最终活下来的G的编号从1–0）:最终编号肯定是为0，G活下来了。</li>
</ol>
<p><strong>最终活着的人的编号反推</strong>：<br>知道了G的索引号的变化过程来进行相应的反推过程<br>从N&#x3D;7到N&#x3D;8的过程<br>先把被杀掉的C补充回来，然后右移动m个人，把溢出的补充在最前面<br><img src="https://runnerxr.github.io/post-images/1653757513872.png"></p>
<p>这里给出一份递归的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lastRemaining</span>(<span class="params">self, n: <span class="built_in">int</span>, m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 递归的出口</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.lastRemaining(n-<span class="number">1</span>,m)+m)%n</span><br></pre></td></tr></table></figure>

<h1 id="剑指offer63-股票的最大利润（已经做过的）"><a href="#剑指offer63-股票的最大利润（已经做过的）" class="headerlink" title="剑指offer63-股票的最大利润（已经做过的）"></a>剑指offer63-股票的最大利润（已经做过的）</h1><p>见动态规划部分的题解</p>
<h1 id="剑指offer64-1-2-3-…-n"><a href="#剑指offer64-1-2-3-…-n" class="headerlink" title="剑指offer64-1+2 +3+…+n"></a>剑指offer64-1+2 +3+…+n</h1><p>要求：不能使用乘除法、for while if else switch case等关键字以及条件判断语句（A?B:C）<br>略</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/%E5%89%91%E6%8C%87offer%E7%B3%BB%E7%B1%BB%E4%BA%8C%E9%A2%98%E7%9B%AE/" data-id="claqum2e2001wh0tka2rmfaly" data-title="剑指offer系类二题目" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer系类一题目" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/12/%E5%89%91%E6%8C%87offer%E7%B3%BB%E7%B1%BB%E4%B8%80%E9%A2%98%E7%9B%AE/" class="article-date">
  <time class="dt-published" datetime="2022-04-12T15:18:54.000Z" itemprop="datePublished">2022-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/12/%E5%89%91%E6%8C%87offer%E7%B3%BB%E7%B1%BB%E4%B8%80%E9%A2%98%E7%9B%AE/">剑指offer系类一题目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>剑指offer03-数组占用重复的数字<br>创建一个哈希表，遍历数组，如果数组中没有这个元素，就将元素加入进去，如果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRepeatNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 创建一个哈希表，用来存储遍历到的数字</span></span><br><span class="line">        dic = []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 如果在哈希表中没有这个数字，就把该数字的下标加进来</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic.append(nums[i])</span><br></pre></td></tr></table></figure>


<h1 id="剑指offer04-二维数组中的查找"><a href="#剑指offer04-二维数组中的查找" class="headerlink" title="剑指offer04-二维数组中的查找"></a>剑指offer04-二维数组中的查找</h1><p>从左下角开始查找</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findNumberIn2DArray</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 如果数组为空，返回false</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        n= <span class="built_in">len</span>(matrix)</span><br><span class="line">        m = <span class="built_in">len</span>(matrix[<span class="number">0</span>]) </span><br><span class="line">         <span class="comment"># 整体思路从左下角开始遍历</span></span><br><span class="line">        i = n-<span class="number">1</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> <span class="keyword">and</span> j &lt;m):</span><br><span class="line">            <span class="keyword">if</span> target&lt; matrix[i][j]:</span><br><span class="line">                i -=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果正好找到，返回true</span></span><br><span class="line">            <span class="keyword">elif</span> target==matrix[i][j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 如果目标值大于遍历的值，需要在下一列去寻找</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>反思为什么用for循环反而会出错的原因：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findNumberIn2DArray</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 如果数组为空，返回false</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        n= <span class="built_in">len</span>(matrix)</span><br><span class="line">        m = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当数组只有一行的时候 </span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> target==matrix[<span class="number">0</span>][j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">         <span class="comment"># 当数组只有一列的时候 </span></span><br><span class="line">        <span class="keyword">if</span> m==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> target==matrix[j][<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 整体思路从左下角开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="comment"># 如果目标值小于此时遍历的值，需要到上一行去寻找</span></span><br><span class="line">                <span class="keyword">if</span> target&lt; matrix[i][j]:</span><br><span class="line">                    i -=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果正好找到，返回true</span></span><br><span class="line">                <span class="keyword">elif</span> target==matrix[i][j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="comment"># 如果目标值大于遍历的值，需要在下一列去寻找</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="剑指offer05-替换空格"><a href="#剑指offer05-替换空格" class="headerlink" title="剑指offer05-替换空格"></a>剑指offer05-替换空格</h1><p>方式一：采用python中内置的replace()函数可以直接将’ ‘ 替换为%20</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">replaceSpace</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 直接用replce函数进行替换</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;%20&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>方式二：空数组不断加入以及组成新的数组的形式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">replaceSpace</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 在字符串中遍历，当遍历到空格的时候，加入%20，当遍历到字符串的时候，加入进去</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27; &#x27;</span>: </span><br><span class="line">                res.append(<span class="string">&quot;%20&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                res.append(c)</span><br><span class="line">        <span class="comment"># 返回用&quot;.&quot;连接的字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)</span><br></pre></td></tr></table></figure>

<h1 id="剑指offer09-用两个栈实现队列"><a href="#剑指offer09-用两个栈实现队列" class="headerlink" title="剑指offer09-用两个栈实现队列"></a>剑指offer09-用两个栈实现队列</h1><p>这里重在理解相应的题意，以及理解栈与队列的性质</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 写一个方法，定义两个栈，其中栈A作为主栈，栈B作为辅助栈</span></span><br><span class="line">        <span class="comment"># 栈A实现入队功能，栈B实现出队功能</span></span><br><span class="line">        self.A,self.B=[],[]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义在队列尾部插入整数的函数，插入操作是有参数，没有返回值的</span></span><br><span class="line">    <span class="comment"># 直接在A中插入元素就可以</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">appendTail</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.A.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义在头部删除整数的函数，删除操作没有参数，有返回值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteHead</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果栈B有值的话，就弹出返回即可</span></span><br><span class="line">        <span class="keyword">if</span> self.B:</span><br><span class="line">            <span class="keyword">return</span> self.B.pop()</span><br><span class="line">        <span class="comment"># 如果栈A中没有值，表明此时构造的队列是空的，deleteHead操作返回-1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.A:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果栈A中有元素，将栈A中的元素弹出添加到栈B中（栈B元素实现栈A元素的倒序）</span></span><br><span class="line">        <span class="keyword">while</span> self.A:</span><br><span class="line">            self.B.append(self.A.pop())</span><br><span class="line">        <span class="comment"># 栈B执行出栈，相当于删除A的栈底元素，实现队首元素的删除</span></span><br><span class="line">        <span class="keyword">return</span> self.B.pop()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后的一个函数也可以做适当的变化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deleteHead</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果栈A为空,直接返回-1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.A <span class="keyword">and</span> <span class="keyword">not</span> self.B:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 如果栈B为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.B:</span><br><span class="line">            <span class="keyword">while</span> self.A:</span><br><span class="line">                self.B.append(self.A.pop())</span><br><span class="line">        <span class="comment"># 栈B执行出栈，相当于删除A的栈底元素，实现队首元素的删除</span></span><br><span class="line">        <span class="keyword">return</span> self.B.pop()</span><br></pre></td></tr></table></figure>

<p>同时联系之前的一道题，基本上同样的思维模式，其中的pop()函数和empty()函数在上一道题目中包含在deleteHead()函数中了。</p>
<h1 id="leetcoad232-用栈实现队列"><a href="#leetcoad232-用栈实现队列" class="headerlink" title="leetcoad232-用栈实现队列"></a>leetcoad232-用栈实现队列</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 定义两个栈</span></span><br><span class="line">        self.A,self.B=[],[]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将元素推到队列的末尾</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.A.append(x)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 移除队首元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果栈B为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.B:</span><br><span class="line">            <span class="keyword">while</span> self.A:</span><br><span class="line">                self.B.append(self.A.pop())</span><br><span class="line">        <span class="keyword">return</span> self.B.pop()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回队列开头的元素(pop和peek的区别，一个是删除，一个是返回)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.B:</span><br><span class="line">            <span class="keyword">while</span> self.A:</span><br><span class="line">                self.B.append(self.A.pop())</span><br><span class="line">        <span class="keyword">return</span> self.B[-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义一个empy函数，如果为空返回true，如果不为空就返回false</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 判断是否两个栈都为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.A <span class="keyword">and</span> <span class="keyword">not</span> self.B:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h1 id="剑指offer-06-从尾到头打印链表"><a href="#剑指offer-06-从尾到头打印链表" class="headerlink" title="剑指offer 06-从尾到头打印链表"></a>剑指offer 06-从尾到头打印链表</h1><p>备注：此题与反转链表之间的区别与联系<br>写法一：采用栈的写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePrint</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 构建一个栈（也是一个数组）</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="comment"># 把链表的头节点加入栈中</span></span><br><span class="line">            stack.append(head.val)</span><br><span class="line">            <span class="comment"># 不断的把头节点的值指向下一个结点，类似一个遍历的过程（不断的进行入栈的操作，直到头节点为空的时候跳出循环）</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 直接返回倒序数组</span></span><br><span class="line">        <span class="keyword">return</span> stack[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 真正运用栈的思想的，只是从概念上去理解，实际没必要，因为多用了一个res数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePrint</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 构建一个栈</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="comment"># 把链表的头节点加入栈中（push：入栈）</span></span><br><span class="line">            stack.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="comment"># pop：出栈</span></span><br><span class="line">            res.append(stack.pop())</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>写法二：采用递归的方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 另外写了一个DFS的函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePrint</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">head</span>):</span><br><span class="line">            <span class="comment"># 递归终止条件</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="comment"># 每次返回当前的list +当前的节点值，实现节点的倒序输出</span></span><br><span class="line">            <span class="keyword">return</span> dfs(head.<span class="built_in">next</span>) + [head.val] </span><br><span class="line">        <span class="keyword">return</span> dfs(head)</span><br></pre></td></tr></table></figure>
<p>或者采用这样的递归形式，利用已有的函数一步到位</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePrint</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.reversePrint(head.<span class="built_in">next</span>) + [head.val]</span><br></pre></td></tr></table></figure>


<h1 id="剑指offer-11-旋转数组中的最小数字"><a href="#剑指offer-11-旋转数组中的最小数字" class="headerlink" title="剑指offer 11-旋转数组中的最小数字"></a>剑指offer 11-旋转数组中的最小数字</h1><p>参考链接：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/</a><br>有几个注意点：</p>
<ol>
<li>原来的数组是递增有序</li>
<li>左边元素大于右边元素</li>
<li>首先肯定是要用二分法的（排序数组的查找优先使用二分），目的是看中间元素是在哪个排序数组中</li>
<li>在采用的基础上，要用中间的值和右边的值进行比较才能知道旋转的数到底在哪个区间范围内（如果与左边的值进行比较的话，无法选定区间）</li>
<li>为什么要单独区分中间值与右边值相等的情况:先记住</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minArray</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(numbers)</span><br><span class="line">        <span class="keyword">if</span> n ==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> numbers[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 采用二分查找的思路解题</span></span><br><span class="line">        left=<span class="number">0</span></span><br><span class="line">        right=n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left +(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="comment"># 如果中间的值大于右边的值，mid在左排序数组中，所以旋转的元素在右边区间：[mid+1,right]之间，left=mid+1</span></span><br><span class="line">            <span class="keyword">if</span> numbers[mid]&gt;numbers[right]:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果中间的值小于右边的值，这是一个正常的排序，mid在右排序数组中，所以旋转的元素在[left,mid]之间，right=mid（mid也可能是一个旋转元素，不能排除mid比左边的元素更小）</span></span><br><span class="line">            <span class="keyword">elif</span> numbers[mid] &lt;numbers[right]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="comment"># 如果中间的值等于右边的值，无法判断到底在哪个区间</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 一个一个的往前去遍历，找到那个最小值</span></span><br><span class="line">                <span class="keyword">return</span> self.findMin(numbers,left,right)</span><br><span class="line">        <span class="keyword">return</span> numbers[left]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从头到尾遍历numbers获取最小值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self,numbers,left,right</span>):</span><br><span class="line">        res=numbers[left]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left,right+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 一旦发现遍历的值还小于左边这个值，就更新这个最小值</span></span><br><span class="line">            <span class="keyword">if</span> numbers[i]&lt; res:</span><br><span class="line">                res=numbers[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h1 id="剑指offer12-矩阵中的路径"><a href="#剑指offer12-矩阵中的路径" class="headerlink" title="剑指offer12-矩阵中的路径"></a>剑指offer12-矩阵中的路径</h1><p>题目描述：给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。<br>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。<br>加上自己的一点理解：回溯，在每一层的搜索里面，不管有没有找到，都需要往回走<br>还有要把DFS想象成为一个多叉树，每个下面都是有多种选择的，如果不对就回退，接着进行选择<br>要解决什么叫搜索过的问题<br><img src="https://runnerxr.github.io/post-images/1651338595481.png"><br><img src="https://runnerxr.github.io/post-images/1651338683210.png"><br>需要将字符串进行拆分，一个一个元素进行匹配<br>通过两层嵌套覆盖所有的情况<br>写入dfs函数：<br><strong>终止条件：</strong></p>
<ol>
<li>边界情况的判断:行越界、列越界、以及网格中的任何一个元素都没有与word中的字母匹配，返回False</li>
<li>当访问到最后一个字符的时候，说明成功匹配到了最后一个元素，直接返回True(网格中存在这个单词)</li>
</ol>
<p><strong>递推工作：</strong></p>
<ol>
<li>标记当前矩阵元素，将其修改为特殊字符，代表元素已经访问，防止之后的搜索重复访问</li>
<li>搜索元素的四个方向，匹配下一个目标元素，使用或来连接（只需找到一条可行的路径就直接返回，不再做后续的DFS）,并记录结果至res</li>
<li><strong>还原当前矩阵</strong>：一趟结束后，把原来设置的’#’改成匹配好的字符，以免影响后面dfs的遍历。将board[i][j]还原至初始值:work[k]  这里是自己在学习算法的时候最难立即的一点</li>
</ol>
<p><strong>返回值：</strong><br>返回布尔量res,代表是否搜索到目标的字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要加上自己的本地调试过程（必须要做到），同时还要结合岛屿数量的那一道题或者思路再整理一遍</span></span><br><span class="line"><span class="comment"># 深度优先搜索+剪枝</span></span><br><span class="line"><span class="comment"># 深度优先搜索：暴力遍历矩阵中所有字符串可能性，DFS通过递归，先朝一个反向搜搜索到底，再回溯到上一个节点，沿着另外的一个方向搜索，以此类推。</span></span><br><span class="line"><span class="comment"># 剪枝：在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况，（例如：此矩阵元素和目标字符不同、此元素已被访问[后面处理的方式也是一个亮点]），则应立即返回，称之为 可行性剪枝</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="comment"># 根据输入的条件，预计需要输出的是true,相当于作为一个理解题目的过程</span></span><br><span class="line"><span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">    输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span></span><br><span class="line"><span class="string">    输出：true</span></span><br><span class="line"><span class="string">     &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exist</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二维网格的行数与列数</span></span><br><span class="line">        m,n = <span class="built_in">len</span>(board),<span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 遍历网格,通过两层嵌套覆盖所有的情况，一个字母一个字母的尝试</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 以左上角第一个元素为起点进行相应的dfs搜索，如果能够查到，直接返回true,所有的情况都没没有找到，返回False（是一个查找字符的过程）</span></span><br><span class="line">                <span class="keyword">if</span> self.dfs(board,word,i,j,<span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># dfs作用：查看在给定的网格中是否存在word这个路径</span></span><br><span class="line">    <span class="comment"># x 和y分别表示行和列数</span></span><br><span class="line">    <span class="comment"># k 表示访问到word中的字母的下标（递归参数有三个）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]],word,x,y,k</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对各种边界条件进行判断,两个终止条件</span></span><br><span class="line">        <span class="comment"># 终止条件一：行或列索引越界或当前矩阵元素与目标字符不同</span></span><br><span class="line">        <span class="keyword">if</span> x &lt;<span class="number">0</span> <span class="keyword">or</span> x&gt;=<span class="built_in">len</span>(board) <span class="keyword">or</span> y&lt;<span class="number">0</span> <span class="keyword">or</span> y &gt;=<span class="built_in">len</span>(board[<span class="number">0</span>]) <span class="keyword">or</span> board[x][y]!=word[k]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当程序跑到word的最后一个字母的时候，不需要搜索，直接返回True</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="built_in">len</span>(word)-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 把访问过的字母标记为&quot;#&quot;，代表已经遍历了，以免影响后面dfs的遍历使用</span></span><br><span class="line">        <span class="comment"># 只会保证当前的匹配方案中不要走回头路，一旦看到这个符号，说明不能走回头路，但是于此同时也只是影响当前的匹配方案，因为如果匹配成功与不成功，要回溯返回，此时需要取消标记（也就是后面的操作）</span></span><br><span class="line">        board[x][y]=<span class="string">&quot;#&quot;</span></span><br><span class="line">        <span class="comment"># 进行剪枝,按照上下左右的顺序进行搜索去匹配word中下一个字母，用res进行记录</span></span><br><span class="line">        <span class="comment"># 也即朝四个方向递归，看是否有能够匹配下一个字母的元素存在，只需要找到一条可行的路径就直接返回，不再做后续的dfs（一条不行就另外换一条路径）</span></span><br><span class="line">        res = self.dfs(board,word,x-<span class="number">1</span>,y,k+<span class="number">1</span>) <span class="keyword">or</span> self.dfs(board,word,x+<span class="number">1</span>,y,k+<span class="number">1</span>) <span class="keyword">or</span> self.dfs(board,word,x,y-<span class="number">1</span>,k+<span class="number">1</span>) <span class="keyword">or</span> self.dfs(board,word,x,y+<span class="number">1</span>,k+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 一趟结束后，把原来设置的&#x27;#&#x27;改成匹配好的字符，以免影响后面dfs的遍历,因为一旦没有找到还需要回退到上一层或上上层去寻找</span></span><br><span class="line">        board[x][y]=word[k]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果能够找到就返回res</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件（本地调试的时候需要）</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 输入一个特定的需要求解的数组</span></span><br><span class="line">    board = [[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;E&quot;</span>],[<span class="string">&quot;S&quot;</span>,<span class="string">&quot;F&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;S&quot;</span>],[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>,<span class="string">&quot;E&quot;</span>]]</span><br><span class="line">    word=<span class="string">&quot;BFCE&quot;</span></span><br><span class="line">    res = Solution().exist(board,word)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    <span class="comment"># print(&quot;  输出 =&gt; &quot; ,res)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>提供另外的一种解决思路</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 另外的一种思路：按照岛屿数量的思路来写，借鉴黑眼圈的写法</span></span><br><span class="line"><span class="comment"># 之前不算正真的理解，所以在调试之后发现还是很有新的收获的</span></span><br><span class="line"><span class="comment"># 主函数退出递归的条件：要么已经找到了一条完整的路径，要么网格已经遍历完全了（刚开始是自己一直疑惑的点）</span></span><br><span class="line"><span class="comment"># 但是这里的解法还是有问题，没有体现回溯的过程，还是不太建议采用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exist</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        m,n = <span class="built_in">len</span>(board),<span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> self.dfs(board,word,i,j,<span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]],word,x,y,k</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果board[x][y]元素与words的第k个元素不相等，直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span>  board[x][y]!=word[k]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当程序跑到word的最后一个字母的时候，不需要搜索，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="built_in">len</span>(word)-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 原来位置的字符串，用临时变量进行存储，在每一个递归里面都会变化</span></span><br><span class="line">        temp = board[x][y]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 把访问过的字母标记为&quot;#&quot;，代表已经遍历了，以免影响后面dfs的遍历使用</span></span><br><span class="line">        board[x][y]=<span class="string">&quot;#&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 循环遍历当前位置的上、下、左、右四个方向</span></span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> ((-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>)):</span><br><span class="line">            newX = dx + x</span><br><span class="line">            newY = dy + y</span><br><span class="line">            <span class="comment"># 如果新的位置超出了数组边界 或者 已经访问过</span></span><br><span class="line">            <span class="keyword">if</span> newX &lt;<span class="number">0</span> <span class="keyword">or</span> newX&gt;=<span class="built_in">len</span>(board) <span class="keyword">or</span> newY&lt;<span class="number">0</span> <span class="keyword">or</span> newY &gt;=<span class="built_in">len</span>(board[<span class="number">0</span>]) <span class="keyword">or</span> board[newX][newY]==<span class="string">&quot;#&quot;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归搜索新的位置</span></span><br><span class="line">            <span class="keyword">if</span> self.dfs(board,word,newX,newY,k+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 恢复状态，这里恢复状态的方式也要注意理解：因为已经位于循环的外面，不能用上面的解法：board[x][y]=word[k],用的是变量temp进行存储的</span></span><br><span class="line">        board[x][y]=temp</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h1 id="剑指offer13-机器人的运动范围"><a href="#剑指offer13-机器人的运动范围" class="headerlink" title="剑指offer13-机器人的运动范围"></a>剑指offer13-机器人的运动范围</h1><p>再做第二遍的时候，思路及代码必须自己独立实现，不能辅助其他的方法，看懂之后再写。<br>题目分析：在一个m行n列的方格之中，机器人可以从[0.0]开始向上下左右移动，但是不能出界也不能进入到行坐标与列坐标的数位之和大于k的格子，问机器人最多能够达到多少的格子？<br>这里自己做了一个excel表格帮助自己去理解，其中m&#x3D;n&#x3D;20,k&#x3D;8,表中红色区域是满足要求的，并且机器人是可以达到的，黄色区域虽然满足数位之和的要求，但是机器人并不能达到，仍然不是题目中符合要求的格子。<br><img src="https://runnerxr.github.io/post-images/1652580591080.png"><br>有两个关键点记录一下：</p>
<ol>
<li>避免少统计：遍历所有能移动的格子</li>
<li>避免重复统计：每次统计完一个格子后将其移除</li>
<li>还有一点：符合要求的区域机器人不一定能够到达（重点理解），中间有一些不符合要求的区域机器人无法跨越</li>
<li>机器人从一个方向出发，直到达到不可到达的区域才会返回，是深度优先遍历</li>
<li>机器人不断的<strong>重复从一个格子出发探索</strong>、<strong>返回携带数量以及清除区域操作</strong>，用<strong>递归</strong>来解决</li>
<li>数位之和的计算可以用一个函数来辅助的计算（思维方式吧，实现的过程并不难，但是就是要十分的熟练）<br>使用图片来辅助理解<br><img src="https://runnerxr.github.io/post-images/1650334552674.png"><br><img src="https://runnerxr.github.io/post-images/1650338941071.png"><br><strong>移动机器人前进和后退的移动轨迹（也即DFS的递归和回溯过程）</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">movingCount</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用临时变量 visited 记录格子是否被访问过</span></span><br><span class="line">        visited=[[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 开始深度优先遍历</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(<span class="number">0</span>,<span class="number">0</span>,m,n,k,visited)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写一个深度优先遍历函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,i,j,m,n,k,visited</span>):</span><br><span class="line">        <span class="comment"># 几种边界条件</span></span><br><span class="line">        <span class="comment"># 行列索引越界</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;=m <span class="keyword">or</span> j &gt;=n :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 数位和超出目标值 k ，即不满足行坐标和列坐标的数位之和小于 k 的格子（剪枝1）</span></span><br><span class="line">        <span class="keyword">if</span> self.<span class="built_in">sum</span>(i,j)&gt;k: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 已经被访问过的格子（剪枝2）</span></span><br><span class="line">        <span class="keyword">if</span> visited[i][j]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 机器人进入了一个新格子，标注这个格子被访问过</span></span><br><span class="line">        visited[i][j]= <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 沿着当前格子的右边和下边继续访问</span></span><br><span class="line">        <span class="comment"># 回溯返回值：返回1+下方搜索可达的解总数+右方搜索的可达解总数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+ self.dfs(i+<span class="number">1</span>,j,m,n,k,visited) +self.dfs(i,j+<span class="number">1</span>,m,n,k,visited)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写一个计算两个坐标之和的函数sum</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">self,i,j</span>):</span><br><span class="line">        <span class="comment"># 通过求余与取整的方式来计算</span></span><br><span class="line">        ia,ib=i//<span class="number">10</span>,i%<span class="number">10</span></span><br><span class="line">        ja,jb=j//<span class="number">10</span>,j%<span class="number">10</span></span><br><span class="line">        s = ia +ib +ja +jb</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把计算数位之和的函数优化一下</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">movingCount</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用临时变量 visited 记录格子是否被访问过</span></span><br><span class="line">        visited=[[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 开始深度优先遍历</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(<span class="number">0</span>,<span class="number">0</span>,m,n,k,visited)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写一个深度优先遍历函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,i,j,m,n,k,visited</span>):</span><br><span class="line">        <span class="keyword">if</span> i &gt;=m <span class="keyword">or</span> j &gt;=n <span class="keyword">or</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.<span class="built_in">sum</span>(i)+self.<span class="built_in">sum</span>(j)&gt;k: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> visited[i][j]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        visited[i][j]= <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+ self.dfs(i+<span class="number">1</span>,j,m,n,k,visited) +self.dfs(i,j+<span class="number">1</span>,m,n,k,visited)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">self,i</span>):</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i!=<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 计算数位之和</span></span><br><span class="line">            s+=i +i%<span class="number">10</span></span><br><span class="line">            <span class="comment"># 计算十位数</span></span><br><span class="line">            i = i//<span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="剑指offer-18-删除链表的节点"><a href="#剑指offer-18-删除链表的节点" class="headerlink" title="剑指offer 18 删除链表的节点"></a>剑指offer 18 删除链表的节点</h1><p>需要定义两个指针，不断的向右移动<br>当cur指针访问到需要删除的元素的受，将pre指针指向cur的下一个指针（此时需要删除的节点，没有任何一个指针指向它）<br>最后返回链表的头节点就是删除后的链表<br>特殊情况的处理：当删除的节点就是头节点的时候，直接返回头节点的下一个节点<br>循环的终止条件：cur指针指向空或是cur指针指向的节点值就是要删除的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, head: ListNode, val: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="comment"># 特殊的情况处理</span></span><br><span class="line">        <span class="keyword">if</span> head.val==val:</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 遍历整个链表,要用指针来做,实质是一种二叉树的遍历框架</span></span><br><span class="line">        <span class="comment"># 定义两个指针pre,cur</span></span><br><span class="line">        pre,cur= head,head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当cur的节点值等于val的时候跳出循环</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.val != val:</span><br><span class="line">        <span class="comment"># while cur.val != val:</span></span><br><span class="line">            pre= cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        pre.<span class="built_in">next</span>= cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<h1 id="剑指offer-21调整数组顺序使奇数位于偶数前面"><a href="#剑指offer-21调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指offer 21调整数组顺序使奇数位于偶数前面"></a>剑指offer 21调整数组顺序使奇数位于偶数前面</h1><p>采用双指针的做法：让left左边都是奇数，让right右边都属偶数<br>如果left指针指向的元素值是奇数，说明该元素在左侧，让left向右移动<br>如果right指针指向的元素是偶数，那么元素在右侧，让right向左移动<br>否则，要么left指向的为偶数，right指向的为奇数，交换两个位置的元素（空变量），题目不难，主要是找对思路就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exchange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 采用双指针的写法</span></span><br><span class="line">        left ,right = <span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 采用二分查找的思路</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># 如果left指针指向的元素是奇数，说明该元素应该再左侧，让left向右移动</span></span><br><span class="line">            <span class="keyword">if</span> nums[left]%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                left +=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果right指针指向的元素是偶数，那么元素在右侧，让right向左移动</span></span><br><span class="line">            <span class="keyword">elif</span> nums[right]%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp = nums[left]</span><br><span class="line">                nums[left]= nums[right]</span><br><span class="line">                nums[right]=temp</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h1 id="剑指offer22-链表中倒数第k个节点"><a href="#剑指offer22-链表中倒数第k个节点" class="headerlink" title="剑指offer22 链表中倒数第k个节点"></a>剑指offer22 链表中倒数第k个节点</h1><p>仍然是采用双指针，同时让其中的一个节点先走k步(这里实现的过程也是一个考察点，需要自己注意)<br>然后两个指针同时向右移动，直到先行的指针指向为空此时后面的那个指针指向的就是要求的链表（理解这里的思想很重要）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKthFromEnd</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="comment"># 定义两个指针</span></span><br><span class="line">        pre,cur=head,head</span><br><span class="line">        <span class="comment"># 让cur指针提前向右移动k步</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,k):</span><br><span class="line">            cur=cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 让两个指针同时向向移动，跳出循环的条件是cur指针指向为空</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            pre=pre.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

<h1 id="剑指offer-26-树的子结构"><a href="#剑指offer-26-树的子结构" class="headerlink" title="剑指offer 26 树的子结构"></a>剑指offer 26 树的子结构</h1><p>利用二叉树递归的代码（做的时候，这几种情况记得再判断一下 ）<br>边界的判断：<br>空树不是任意一个树的子结构<br>查看几种情况：</p>
<ol>
<li>A的根节点与B的根节点相同，依次比较他们的子节点</li>
<li>A的根节点与B的根节点不同，A的左子树与B的根节点比较</li>
<li>A的根节点与B的根节点不同，A的右子树与B的根节点比较<br>用两张图来辅助理解：<br>要判断B是否是A的子结构，要么一开始就从A和B的根节点开始<br><img src="https://runnerxr.github.io/post-images/1650334161301.png"><br>如果根节点不相同，就需要判断B是否为A的左子树或右子树<br><img src="https://runnerxr.github.io/post-images/1650334167543.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubStructure</span>(<span class="params">self, A: TreeNode, B: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 先从两个根节点出发进行判断</span></span><br><span class="line">        <span class="comment"># 如果一开始A或者B为空，直接返回False（特例情况：空树不是任何一个树的子结构）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> <span class="keyword">not</span> B:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判单B是否是A的左子树含有右子树的结构：实际上是有以下的三种情况，都可以通过函数的递归抵用来解决</span></span><br><span class="line">        <span class="comment"># 接下来主要比较的点：A与B的根节点的比较（A的左右子树的节点与B的根节点的比较）,本质是对A进行一个先序遍历</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 情况一：如果找到相同的节点值，判断它们各自的左右子节点是否相同（以节点A为根节点的子树包含树B,直接用dfs）</span></span><br><span class="line">        <span class="comment"># 情况二：如果A根节点与B的根节点不同，比较A的左子树与B的根节点（树B是树A左子树的子结构,用isSubStructure(A.left,B)）</span></span><br><span class="line">        <span class="comment"># 情况三：如果A根节点与B的根节点不同，比较A的右子树与B的根节点 (树B是树A右子树的子结构,用isSubStructure(A.right,B)）</span></span><br><span class="line">        <span class="keyword">return</span>  self.dfs(A, B) <span class="keyword">or</span> self.isSubStructure(A.left,B) <span class="keyword">or</span> self.isSubStructure(A.right,B)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写一个函数，作用是：从上一个函数得到的根节点开始递归比较是否右子树</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,A,B</span>):</span><br><span class="line">        <span class="comment"># 一开始去找A和B完全匹配的情况</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归的终止条件：</span></span><br><span class="line">        <span class="comment"># 终止条件一：# 对B不断的进行遍历，直到为空（B已经递归到叶子节点了），说明B的全部节点都和A的子结构能够匹配</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> B:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 终止条件二：如果A中的节点为空，B中的节点不为空，不能匹配</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 终止条件三：如果A和B都不为空，但是数值又不同，也是不匹配的（理解）</span></span><br><span class="line">        <span class="keyword">if</span> A.val != B.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回值：当前的这个点是匹配的（A.val= B.val），继续的递归判断左子树和右子树是否分别匹配（需要同时递归）</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(A.left,B.left) <span class="keyword">and</span> self.dfs(A.right,B.right)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="剑指offer-27-二叉树的镜像"><a href="#剑指offer-27-二叉树的镜像" class="headerlink" title="剑指offer 27-二叉树的镜像"></a>剑指offer 27-二叉树的镜像</h1><p>总体的思路：</p>
<ol>
<li>把根节点的左子树先抽离出来进行保存</li>
<li>把当前节点的右子树镜像到镜像的二叉树中</li>
<li>把原左子树放到镜像二叉树的右子树中</li>
<li>在整个的过程中都是递归的进行操作的<br><img src="https://runnerxr.github.io/post-images/1650129779849.png"><br><img src="https://runnerxr.github.io/post-images/1650129747856.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归的写法：类似于交换两个数的写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mirrorTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="comment"># 当节点为空时，直接返回</span></span><br><span class="line">        <span class="comment"># 递归的出口</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置一个临时的节点 tmp 用来存储当前节点的左子树（避免覆盖后找到左右子节点）</span></span><br><span class="line">        temp = root.left</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 以下两个操作是在交换当前节点的左右子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当前节点的左子树为节点的右子树</span></span><br><span class="line">        <span class="comment"># 同时递归下去，不停的交换子树中的节点</span></span><br><span class="line">        root.left=self.mirrorTree(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前节点的右子树为节点的左子树</span></span><br><span class="line">        <span class="comment"># 同时递归下去，不停的交互子树中的节点</span></span><br><span class="line">        root.right=self.mirrorTree(temp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最后返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
看到题解的时候发现还有很多其他的解法在里面，如果自己右精力的话可以去考虑一下。</li>
</ol>
<h1 id="剑指offer28-对称的二叉树"><a href="#剑指offer28-对称的二叉树" class="headerlink" title="剑指offer28-对称的二叉树"></a>剑指offer28-对称的二叉树</h1><p>题目本身是一个定义题，自己之前也是做过的，二叉树的本质都是递归的做法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 边界情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.isSymmetricalTree(root.left,root.right)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义一个判断两个二叉树是否对称的函数isSymmetricalTree</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetricalTree</span>(<span class="params">self,left, right</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果根子树的左右两个节点同时为空，肯定是对称的，直接的返回true</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果根子树的左右子树有一个为空，一个有值，不对称，返回false</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 左右子树都是有值的</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果左子树与右子树的值不相等，不对称，返回fasle</span></span><br><span class="line">            <span class="keyword">if</span> left.val !=right.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 递归的对比当前节点的左子树的左子树与右子树的右子树、左子树的右子树与右子树的左子树是否对称</span></span><br><span class="line">            <span class="keyword">return</span> self.isSymmetricalTree(left.left,right.right) <span class="keyword">and</span> self.isSymmetricalTree(left.right,right.left)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把代码做一点简化操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.isSymmetricalTree(root.left,root.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetricalTree</span>(<span class="params">self,left, right</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 上面的几种判断的情况，由于返回值是相同的，可以进行合并</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right <span class="keyword">or</span> left.val !=right.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">            <span class="comment"># 递归的对比当前节点的左子树的左子树与右子树的右子树、左子树的右子树与右子树的左子树是否对称</span></span><br><span class="line">        <span class="keyword">return</span> self.isSymmetricalTree(left.left,right.right) <span class="keyword">and</span> self.isSymmetricalTree(left.right,right.left)</span><br></pre></td></tr></table></figure>


<h1 id="剑指offer32-I从上到下打印二叉树II-树的按层打印，打印到一个数组中"><a href="#剑指offer32-I从上到下打印二叉树II-树的按层打印，打印到一个数组中" class="headerlink" title="剑指offer32-I从上到下打印二叉树II(树的按层打印，打印到一个数组中)"></a>剑指offer32-I从上到下打印二叉树II(树的按层打印，打印到一个数组中)</h1><p>后面的连续的三道题要求理解并加深相应的印象，对于理解层序遍历(BFS)概念十分有帮助！！！！<br>要点如下：</p>
<ol>
<li>边界条件的判断：当根节点为空的时候，返回空数组</li>
<li>需要借助一个队列，先将二叉树的根节点入队，然后出队，访问出队节点</li>
<li>如果有左子树，则将左子树的根节点入队，若有右子树，将右子树的根节点入队</li>
<li>然后出队，访问根节点，如此反复直到队列为空<br>这里贴一段伪代码，加强学习与记忆：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    InitQueue(Q) ;  <span class="comment">//初始化辅助队列</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,T);  <span class="comment">//将根节点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(o))&#123;  <span class="comment">//队列不空则循环</span></span><br><span class="line">        DeQueue(Q,P)      <span class="comment">//队头节点出队</span></span><br><span class="line">        visit(p)                  <span class="comment">//访问出队节点</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,P-&gt;left);  <span class="comment">//左子树不空，则左子树根节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,P-&gt;right); <span class="comment">//右子树不空，则左子树根节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
以下为本题的python的实现代码：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 根节点为空的情况返回空数组</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 生成一个队列，用来保存节点</span></span><br><span class="line">        <span class="comment"># queue=collections.deque()</span></span><br><span class="line">        queue=[]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 生成一个 res，用来保存输出的节点</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 首先让根节点入队</span></span><br><span class="line">        queue.append(root)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历队列，直到队列为空</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">             <span class="comment"># 获取队列的头部元素(把队列的队头元素进行推出)</span></span><br><span class="line">             <span class="comment"># curNode=queue.popleft()</span></span><br><span class="line">             curNode=queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">             <span class="comment"># 把推出的结点值存放到 res 中</span></span><br><span class="line">             res.append(curNode.val)</span><br><span class="line"></span><br><span class="line">             <span class="comment"># 判断该节点是否有左右子节点</span></span><br><span class="line">             <span class="comment"># 如果左子节点有值，则把左子节点加入到队列中</span></span><br><span class="line">             <span class="keyword">if</span> curNode.left:</span><br><span class="line">                 queue.append(curNode.left)</span><br><span class="line">             <span class="comment"># 如果右子节点有值，则把右子节点加入到队列中 </span></span><br><span class="line">             <span class="keyword">if</span> curNode.right:</span><br><span class="line">                 queue.append(curNode.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="剑指offer32-II从上到下打印二叉树II-层序遍历"><a href="#剑指offer32-II从上到下打印二叉树II-层序遍历" class="headerlink" title="剑指offer32-II从上到下打印二叉树II(层序遍历)"></a>剑指offer32-II从上到下打印二叉树II(层序遍历)</h1><p>在上一题的基础上加入了需要每一层打印到一行，也是层序遍历的精髓所在。<br>主要是要通过图深刻的将层序遍历的思想彻底弄清楚，有几个要点：</p>
<ol>
<li>在大的循环下面（只要队列不为空就一直循环），打印的时候需要加入一个循环将队列中的元素不断加入到数组中，其中循环的次数与队列的长度（也即每层的节点的个数有关）</li>
<li>每一层的循环结束后，把层的结果添加到最后的结果中<ol>
<li>出队</li>
<li>打印</li>
<li>添加子节点<br><img src="https://runnerxr.github.io/post-images/1650464453326.png"><br><img src="https://runnerxr.github.io/post-images/1650464463204.png"><br><img src="https://runnerxr.github.io/post-images/1650464470734.png"><br><img src="https://runnerxr.github.io/post-images/1650464478317.png"><br><img src="https://runnerxr.github.io/post-images/1650464488128.png"><br><img src="https://runnerxr.github.io/post-images/1650464495073.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二次写了，当成模板来记忆就行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 根节点为空的情况返回空数组</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 生成一个队列，用来保存节点</span></span><br><span class="line">        queue=[]</span><br><span class="line">        <span class="comment"># 生成temp和res，分别用来保存每一层的节点和全部层的结果</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 首先让根节点入队</span></span><br><span class="line">        queue.append(root)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历队列，直到队列为空</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 记录queue的长度，即每层节点的个数</span></span><br><span class="line">            n= <span class="built_in">len</span>(queue)</span><br><span class="line">            temp=[]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 用for循环将队列中的元素添加到temp数组中</span></span><br><span class="line">            <span class="comment"># temp =[num for num in queue]</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 把队列的头部元素弹出</span></span><br><span class="line">                curNode=queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 用temp数组保存当前层的元素</span></span><br><span class="line">                temp.append(curNode.val)</span><br><span class="line">                <span class="comment"># print(temp)</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 判断该节点是否有左右子节点</span></span><br><span class="line">                <span class="comment"># 如果左子节点有值，则把左子节点加入到队列中</span></span><br><span class="line">                <span class="keyword">if</span> curNode.left:</span><br><span class="line">                    queue.append(curNode.left)</span><br><span class="line">                <span class="comment"># 如果右子节点有值，则把右子节点加入到队列中 </span></span><br><span class="line">                <span class="keyword">if</span> curNode.right:</span><br><span class="line">                    queue.append(curNode.right)</span><br><span class="line">            <span class="comment"># 把每一层的元素加入到res数组中</span></span><br><span class="line">            res.append(temp)</span><br><span class="line">            <span class="built_in">print</span>(res)   </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="剑指offer32-III从上到下打印二叉树III-打印顺序按照层的奇偶性交替变化"><a href="#剑指offer32-III从上到下打印二叉树III-打印顺序按照层的奇偶性交替变化" class="headerlink" title="剑指offer32-III从上到下打印二叉树III(打印顺序按照层的奇偶性交替变化)"></a>剑指offer32-III从上到下打印二叉树III(打印顺序按照层的奇偶性交替变化)</h1><p>同时在打印的时候，创建的打印数组必须是双端队列，满足可以从队头或者队尾插入元素的要求：奇数层添加至尾部，偶数层添加至头部<br>需要用到python中的：from collections import deque<br>值得学习别人的一些比较好的做法，后面有时间再细细的研究<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/solution/mian-shi-ti-32-iii-cong-shang-dao-xia-da-yin-er--3/">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/solution/mian-shi-ti-32-iii-cong-shang-dao-xia-da-yin-er--3/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 根节点为空的情况返回空数组</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 生成一个队列，用来保存节点</span></span><br><span class="line">        queue=[]</span><br><span class="line">        <span class="comment"># 生成temp和res，分别用来保存每一层的节点和全部层的结果</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 首先让根节点入队</span></span><br><span class="line">        queue.append(root)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 写一个函数用来判断当前的层数是否为奇数层，最开始是为奇数层的</span></span><br><span class="line">        isOddNnumber = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历队列，直到队列为空</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 记录queue的长度，即每层节点的个数,用于后面将每一层队列的元素加入到temp中</span></span><br><span class="line">            n= <span class="built_in">len</span>(queue)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 奇数与偶数层交替出现</span></span><br><span class="line">            <span class="comment"># 通过取反操作，判断当前的层数是否为奇数层</span></span><br><span class="line">            <span class="comment"># 由于isOddNnumber初始化为False，第一次进来这个while循环取反之后为true</span></span><br><span class="line">            isOddNnumber=~ isOddNnumber</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 生成一个双端队列,只有双端队列才可以从尾部加入到队列中</span></span><br><span class="line">            temp=collections.deque()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 用for循环将队列中的元素添加到temp数组中</span></span><br><span class="line">            <span class="comment"># temp =[num for num in queue]</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 把队列的头部元素弹出</span></span><br><span class="line">                curNode=queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 用temp数组保存当前层的元素</span></span><br><span class="line">                <span class="comment"># 如果发现是奇数层，需要从头加入到尾部</span></span><br><span class="line">                <span class="keyword">if</span> isOddNnumber:</span><br><span class="line">                    temp.append(curNode.val)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果发现是偶数层，需要从尾部加到头部</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp.appendleft(curNode.val)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 判断该节点是否有左右子节点</span></span><br><span class="line">                <span class="comment"># 如果左子节点有值，则把左子节点加入到队列中</span></span><br><span class="line">                <span class="keyword">if</span> curNode.left:</span><br><span class="line">                    queue.append(curNode.left)</span><br><span class="line">                <span class="comment"># 如果右子节点有值，则把右子节点加入到队列中 </span></span><br><span class="line">                <span class="keyword">if</span> curNode.right:</span><br><span class="line">                    queue.append(curNode.right)</span><br><span class="line">            <span class="comment"># 把每一层的元素加入到res数组中</span></span><br><span class="line">            res.append(<span class="built_in">list</span>(temp))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="剑指offer33-二叉搜索树的后序遍历"><a href="#剑指offer33-二叉搜索树的后序遍历" class="headerlink" title="剑指offer33-二叉搜索树的后序遍历"></a>剑指offer33-二叉搜索树的后序遍历</h1><h1 id="剑指offer35-复杂链表的复制"><a href="#剑指offer35-复杂链表的复制" class="headerlink" title="剑指offer35-复杂链表的复制"></a>剑指offer35-复杂链表的复制</h1><h1 id="剑指offer36-二叉搜索树与双向链表"><a href="#剑指offer36-二叉搜索树与双向链表" class="headerlink" title="剑指offer36-二叉搜索树与双向链表"></a>剑指offer36-二叉搜索树与双向链表</h1><h1 id="剑指offer39-数组中出现次数超过一半的"><a href="#剑指offer39-数组中出现次数超过一半的" class="headerlink" title="剑指offer39-数组中出现次数超过一半的"></a>剑指offer39-数组中出现次数超过一半的</h1><h1 id="剑指offer41-数据流中的中位数"><a href="#剑指offer41-数据流中的中位数" class="headerlink" title="剑指offer41-数据流中的中位数"></a>剑指offer41-数据流中的中位数</h1><p>如果是奇数个数值，中位数是数值排序后中间的数值<br>如果是偶数个数值，中位数是数值排序后中间两个数的平均值<br>有几个注意点：</p>
<ol>
<li>数据在不断的变</li>
<li>求中位数的方法也在不断的变</li>
<li>对于动态的数据，借助堆来帮忙解决</li>
<li>大顶堆：用来存储数据流中较小的一半（递增，堆顶为最大值）</li>
<li>小顶堆：存储数据流中较大的一半（递增，堆顶为最小值）</li>
<li>保持大顶堆与小顶堆的元素个数相同（两个堆顶元素平均数）或者至多相差一个，更多的元素出现在小顶堆中（直接将小顶堆的堆顶元素弹出就行）</li>
<li>重要的是：维护大小顶堆的过程：<ol>
<li>想要添加一个元素到小顶堆，先到大顶堆中排序一番，将大顶堆的堆顶元素弹出来加入到小顶堆中</li>
</ol>
</li>
</ol>
<h1 id="剑指offer43-1-n中整数中1出现的次数"><a href="#剑指offer43-1-n中整数中1出现的次数" class="headerlink" title="剑指offer43-1~n中整数中1出现的次数"></a>剑指offer43-1~n中整数中1出现的次数</h1><h1 id="剑指offer44数字序列中某一位的数字"><a href="#剑指offer44数字序列中某一位的数字" class="headerlink" title="剑指offer44数字序列中某一位的数字"></a>剑指offer44数字序列中某一位的数字</h1><h1 id="剑指offer45-把数组排列成最小的数"><a href="#剑指offer45-把数组排列成最小的数" class="headerlink" title="剑指offer45-把数组排列成最小的数"></a>剑指offer45-把数组排列成最小的数</h1><h1 id="剑指offer46-把数字翻译成字符串"><a href="#剑指offer46-把数字翻译成字符串" class="headerlink" title="剑指offer46-把数字翻译成字符串"></a>剑指offer46-把数字翻译成字符串</h1><h1 id="剑指offer47-礼物的最大价值"><a href="#剑指offer47-礼物的最大价值" class="headerlink" title="剑指offer47-礼物的最大价值"></a>剑指offer47-礼物的最大价值</h1><h1 id="剑指-Offer48-最长不含重复字符的子字符串"><a href="#剑指-Offer48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer48-最长不含重复字符的子字符串"></a>剑指 Offer48-最长不含重复字符的子字符串</h1><h1 id="剑指offer49-丑数"><a href="#剑指offer49-丑数" class="headerlink" title="剑指offer49-丑数"></a>剑指offer49-丑数</h1><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。<br>理解题目的意思：<br>假设已知的丑数序列：1，2，3，4，5，6，8，9，</p>
<ul>
<li>nums2数组中存储这个序列中所有丑数与2相乘的结果,nums&#x3D;{ 1 * 2 ， 2 * 2 ，3 * 2 ， 4 * 2 ，5 * 2 ，6 * 2 ，8 * 2，。。。}</li>
<li>nums3 数组存储了这个序列中所有丑数与 3 相乘的结果，nums3 &#x3D; { 1 * 3 ， 2 * 3 ，3 * 3 ， 4 * 3 ，5 * 3 ，6 * 3 ，8 * 3，。。。}</li>
<li>nums5 数组存储了这个序列中所有丑数与 5 相乘的结果，nums5 &#x3D; { 1 * 5 ， 2 * 5 ，3 * 5 ， 4 * 5 ，5 * 5 ，6 * 5 ，8 * 5，。。。}<br><img src="https://runnerxr.github.io/post-images/1650474963654.png"><br>也就是说，每次寻找丑数的过程是在 nums2 、nums3、nums5 这三个数组中寻找最小值的过程。</li>
</ul>
<ol>
<li>在寻找过程中，因为丑数的序列在不断的扩充，nums2 、nums3、nums5 这三个数组也在不断的扩充。</li>
<li>每次找到那个最小值之后，接下来的寻找过程应该忽略它了。</li>
</ol>
<h1 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a>剑指 Offer 50. 第一个只出现一次的字符</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/12/%E5%89%91%E6%8C%87offer%E7%B3%BB%E7%B1%BB%E4%B8%80%E9%A2%98%E7%9B%AE/" data-id="claqum2e3001xh0tk5jh7aoth" data-title="剑指offer系类一题目" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python函数这一块的系统整理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/11/python%E5%87%BD%E6%95%B0%E8%BF%99%E4%B8%80%E5%9D%97%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2022-04-11T15:18:22.000Z" itemprop="datePublished">2022-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/11/python%E5%87%BD%E6%95%B0%E8%BF%99%E4%B8%80%E5%9D%97%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86/">对python函数这一块的系统整理（主要来自廖雪峰+平时的一些积累）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这一块应该没有什么难度的，但是对于初学小白来说也是非常重要的知识点</p>
<h1 id="一些小的层面的"><a href="#一些小的层面的" class="headerlink" title="一些小的层面的"></a>一些小的层面的</h1><p>函数常用的一些操作：<br>调用函数<br>定义函数<br>函数的参数<br>递归函数<br>函数的高级特性：（印象笔记也整理了一部分，这里相当于是二次整理，只不过可能更加的详细了）</p>
<ol>
<li>切片</li>
<li>迭代</li>
<li>列表生成式</li>
<li>生成器</li>
<li>迭代器</li>
</ol>
<p>函数式编程：</p>
<h1 id="大的层面方向的"><a href="#大的层面方向的" class="headerlink" title="大的层面方向的"></a>大的层面方向的</h1><p><strong>Python函数调用时，参数的传递方式</strong><br>详细内容移步：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/downey-blog/p/10483216.html">https://www.cnblogs.com/downey-blog/p/10483216.html</a>     有兴趣的话后面再吗，慢慢的去结合起来进行全方面的深度理解。</p>
<p>对于C程序员来说，我们都知道C在函数调用时，采用的是值传递，即形参和实参分配不同的内存地址，在调用时将实参的值传给实参，在这种情况下，在函数内修改形参并不会影响到实参，但是这样带来一个问题，如果我们需要刻意地对实参进行修改，就不得不传递实参的指针到函数，然后在函数中修改指针指向的数据，以达到修改实参的目的。</p>
<p>后来，C++中引入了引用这个概念，即在函数定义时，在形参前加一个&amp;符号，表示传递参数的引用，在写法上，除了多出一个&amp;符号，其他部分和C中传值调用一样，但是实际确是达到了可以在函数内修改实参内容的目的。这种参数传递的方式被称为传引用。</p>
<p><strong>python的参数传递</strong></p>
<p><strong>关于各个函数的调用的问题</strong><br>以及各个循环之间的参数是否互不影响的问题？？这也是我在做算法题遇到的一些很小的问题</p>
<h1 id="python类中函数调用要加self"><a href="#python类中函数调用要加self" class="headerlink" title="python类中函数调用要加self"></a>python类中函数调用要加self</h1><p>参考链接：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jessonluo/p/4717140.html">https://www.cnblogs.com/jessonluo/p/4717140.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/stuscs/article/details/40110815">https://blog.csdn.net/stuscs/article/details/40110815</a><br>python中的类方法也是一种对象，既可以通过实例也可以通过类来访问方法，再python里面有两种风格</p>
<ol>
<li>未绑定的类方法：没有self<br>通过类来引用方法返回一个未绑定方法对象。要调用它，你必须显示地提供一个实例作为第一个参数。</li>
<li>绑定的实例方法：有self<br>通过实例访问方法返回一个绑定的方法对象。Python自动地给方法绑定一个实例，所以我们调用它时不用再传一个实例参数。<br>两者的区别：两种方法都是对象，它们可以被传递、存入列表等待。两者运行时都需要一个实例作为第一参数（给予一个self值），但当通过一个实例调用一个绑定方法时Python自动会提供一个。<br>对象调用方法时, 实际上是通过类调用的a &#x3D; muffedcalculator()a.calc(expr)<br>实际上是这样调用的 muffledcalculator.calc(a, expr)这样self 就是 a, python隐含地把a 传进方法 替代了self, 就成了绑定的方法, 就可以执行了. 否则就是非绑定方法(这种方式虽然很抽象，但是子集读了几遍之后大概是理解了,self就像是一个替代品一样)<br><strong>self代表类的实例，而非类</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prt</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="built_in">print</span>(self.__class__)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line"><span class="comment"># &lt;__main__.Test object at 0x000000000284E080&gt;</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;__main__.Test&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
从上面的例子中可以很明显的看出，self代表的是类的实例。而self.__class__则指向类。(没有太懂)<br><strong>self不必非写成self</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prt</span>(<span class="params">this</span>):</span><br><span class="line">        <span class="built_in">print</span>(this)</span><br><span class="line">        <span class="built_in">print</span>(this.__class__)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br><span class="line"><span class="comment"># 运行结果不变</span></span><br></pre></td></tr></table></figure>
<strong>self是否可以不写</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prt</span>():</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br><span class="line"><span class="comment"># 运行提示：prt() takes 0 positional arguments but 1 was given（prt在定义的时候没有参数，但是我们运行的时候强行传入了一个参数。t.prt()通过python解释成：Test.prt(t),程序提醒我们多传入了一个参数t）</span></span><br></pre></td></tr></table></figure>
如果我们在定义和调用的时候都不传入实例，就是属于类方法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prt</span>():</span><br><span class="line">        <span class="built_in">print</span>(__class__)</span><br><span class="line">Test.prt()</span><br><span class="line"><span class="comment"># 输出：&lt;class &#x27;__main__.Test&#x27;&gt; </span></span><br></pre></td></tr></table></figure>
<strong>在继承时，传入的是哪个实例，就是那个传入的实例，而不是指定义了self的类的实例</strong></li>
</ol>
<pre><code class="python"># 定义父类
class Parent:
    # 定义了一个pprt()函数
    def pprt(self):
        print(self)

# 定义一个child类
class Child(Parent):
    # 定义了一个cprt()函数
    def cprt(self):
        print(self)

c = Child()
c.cprt()
# 输出结果：&lt;__main__.Child object at 0x0000000002A47080&gt;
# 指的是child类的实例
c.pprt()
# 输出结果：&lt;__main__.Child object at 0x0000000002A47080&gt;
# 等同于child.pprt(c),self依然是child类的实例，由于self中没有定义pprt()方法，所以沿着继承树往上找，发现在父类Parent中定义了pprt()方法，所以就会成功调用。
p = Parent()
p.pprt()
# 输出结果：&lt;__main__.Parent object at 0x0000000002A47240&gt;


</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/11/python%E5%87%BD%E6%95%B0%E8%BF%99%E4%B8%80%E5%9D%97%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86/" data-id="claqum2dp0013h0tk1joo4ar0" data-title="对python函数这一块的系统整理（主要来自廖雪峰+平时的一些积累）" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python中数组和矩阵的知识及相关题目延申" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/29/python%E4%B8%AD%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5%E7%9A%84%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E5%BB%B6%E7%94%B3/" class="article-date">
  <time class="dt-published" datetime="2022-03-29T09:44:35.000Z" itemprop="datePublished">2022-03-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/29/python%E4%B8%AD%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5%E7%9A%84%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E5%BB%B6%E7%94%B3/">python中数组和矩阵的知识及相关题目延申（只能算基础知识部分）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>牛客网一些简单的题型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    scores = [<span class="built_in">float</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">    s =<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(scores[i], end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        s +=scores[i]</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># while True:</span></span><br><span class="line"><span class="comment">#     try:</span></span><br><span class="line"><span class="comment">#         a = list(map(float,input().split()))</span></span><br><span class="line"><span class="comment">#         for i in a:</span></span><br><span class="line"><span class="comment">#             print(&#x27;&#123;:.1f&#125;&#x27;.format(i),end=&quot; &quot;)</span></span><br><span class="line"><span class="comment">#         print(&#x27;&#123;:.1f&#125;&#x27;.format(sum(a)))</span></span><br><span class="line"><span class="comment">#     except:</span></span><br><span class="line"><span class="comment">#         break</span></span><br></pre></td></tr></table></figure>
<p>二维矩阵：自己用代码貌似还不熟练<br>在leetcoad上面这些题目也挺多的</p>
<ul>
<li>283 Move Zeroes (Easy)</li>
<li>566 Reshape the Matrix (Easy)</li>
<li>485 Max Consecutive Ones (Easy)</li>
<li>240 Search a 2D Matrix II (Medium)</li>
<li>378 Kth Smallest Element in a Sorted Matrix ((Medium))</li>
<li>645 Set Mismatch (Easy)</li>
<li>287 Find the Duplicate Number (Medium)</li>
<li>667 Beautiful Arrangement II (Medium)</li>
<li>697 Degree of an Array (Easy)</li>
<li>766 Toeplitz Matrix (Easy)</li>
<li>565 Array Nesting (Medium)</li>
<li>769 Max Chunks To Make Sorted (Medium)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/29/python%E4%B8%AD%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5%E7%9A%84%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E5%BB%B6%E7%94%B3/" data-id="claqum2dp0014h0tka9p23z3i" data-title="python中数组和矩阵的知识及相关题目延申（只能算基础知识部分）" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-分治法的思想及相关例题（Divide and conquer）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/25/%E5%88%86%E6%B2%BB%E6%B3%95%E7%9A%84%E6%80%9D%E6%83%B3%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98%EF%BC%88Divide%20and%20conquer%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2022-03-25T15:17:09.000Z" itemprop="datePublished">2022-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/25/%E5%88%86%E6%B2%BB%E6%B3%95%E7%9A%84%E6%80%9D%E6%83%B3%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98%EF%BC%88Divide%20and%20conquer%EF%BC%89/">分治法的思想及相关例题（Divide and conquer）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一种重要的经典算法及算法设计思想：<br>归并排序就是典型的分治法的思想<br>divide:将大的问题分解为若干较小的问题<br>conquer:继续分解子问题，直到base case,直接求解<br>combine：层层合并子问题的解，直到得到原始大问题的解<br>典型例题合集：</p>
<ul>
<li>241 Different Ways to Add Parentheses (Medium)</li>
<li>95 Unique Binary Search Trees II (Medium)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/25/%E5%88%86%E6%B2%BB%E6%B3%95%E7%9A%84%E6%80%9D%E6%83%B3%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98%EF%BC%88Divide%20and%20conquer%EF%BC%89/" data-id="claqum2e0001rh0tkc18zg41h" data-title="分治法的思想及相关例题（Divide and conquer）" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-时刻牢记在心却不必把这件事挂在嘴边" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/25/%E6%97%B6%E5%88%BB%E7%89%A2%E8%AE%B0%E5%9C%A8%E5%BF%83%E5%8D%B4%E4%B8%8D%E5%BF%85%E6%8A%8A%E8%BF%99%E4%BB%B6%E4%BA%8B%E6%8C%82%E5%9C%A8%E5%98%B4%E8%BE%B9/" class="article-date">
  <time class="dt-published" datetime="2022-03-25T04:32:43.000Z" itemprop="datePublished">2022-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/25/%E6%97%B6%E5%88%BB%E7%89%A2%E8%AE%B0%E5%9C%A8%E5%BF%83%E5%8D%B4%E4%B8%8D%E5%BF%85%E6%8A%8A%E8%BF%99%E4%BB%B6%E4%BA%8B%E6%8C%82%E5%9C%A8%E5%98%B4%E8%BE%B9/">时刻牢记在心却不必把这件事挂在嘴边</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>父母的理解、祝福和支持。不解释，懂得都懂。<br>有足够的经济基础能熬过转型期，对于学生来说就是父母给不给钱，对于出社会的人来说就是储蓄是否能熬到拿第一份工资。<br>承受住不确定期间的心理压力。这个我是万万没想到的，很多同学是崩溃在这一步。别人进厂好歹工资拿着每天回十人间宿舍打游戏。你啥都没，啥也还不会，光熬着，后悔心不断深夜翻涌，在出租屋里算计着下个月房租怎么办，会不会被笑话，输了怎么办。<br>自制力，自知之明。不解释。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/25/%E6%97%B6%E5%88%BB%E7%89%A2%E8%AE%B0%E5%9C%A8%E5%BF%83%E5%8D%B4%E4%B8%8D%E5%BF%85%E6%8A%8A%E8%BF%99%E4%BB%B6%E4%BA%8B%E6%8C%82%E5%9C%A8%E5%98%B4%E8%BE%B9/" data-id="claqum2ej002jh0tk04zycgjr" data-title="时刻牢记在心却不必把这件事挂在嘴边" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gridea/" rel="tag">Gridea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" rel="tag">python知识小记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99%E7%9A%84%E5%B0%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/" rel="tag">工作之余的小的编程小知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" rel="tag">算法专栏（用python注写）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0/" rel="tag">读书摘记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Gridea/" style="font-size: 10px;">Gridea</a> <a href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" style="font-size: 13.33px;">python知识小记</a> <a href="/tags/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99%E7%9A%84%E5%B0%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/" style="font-size: 16.67px;">工作之余的小的编程小知识</a> <a href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" style="font-size: 20px;">算法专栏（用python注写）</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0/" style="font-size: 10px;">读书摘记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/21/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2022/11/12/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%BA%94%E7%9A%84%E5%90%8C%E6%AD%A5/">搭建自己的博客并进行相应的同步</a>
          </li>
        
          <li>
            <a href="/2022/10/03/vs%20code%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%B7%A5%E5%85%B7%E5%8C%85/">关于vs code导入本地工具包和消除&#39;import [module] could not be resolved in pylance&#39;</a>
          </li>
        
          <li>
            <a href="/2022/09/25/%E5%85%B3%E4%BA%8Ematalab%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">关于matalab的数据分析</a>
          </li>
        
          <li>
            <a href="/2022/07/30/%E5%85%B3%E4%BA%8Epython%E7%88%AC%E8%99%AB%E4%B8%80%E7%82%B9%E5%B0%8F%E7%9A%84%E6%95%B4%E7%90%86/">关于python爬虫一点小的整理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>