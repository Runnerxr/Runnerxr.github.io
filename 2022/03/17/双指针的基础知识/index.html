<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>
        bear的生活随笔
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico" />
    <link rel="stylesheet" href="/css/style/github.min.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <div class="container">
        <div class="header">
    <!-- <div class="logo">
        <a href="/">bear的生活随笔</a>
    </div> -->
    <div class="logo">
        <img src="/images/logo.png" alt="Logo">
    </div>
    <div class="nav">
        <ul class="menu">
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">
                        Home
                    </a>
                </li>
            
                <li class="menu-item">
                    <a target="_blank" rel="noopener" href="https://github.com/Runnerxr" class="menu-item-link">
                        Github
                    </a>
                </li>
                
        </ul>
    </div>
</div>
        <div class="article">
    <!-- <div class="article-title">
        <h2>
            双指针的基础知识
        </h2>
    </div> -->
    <div class="article-meta">
        <div class="article-date">
            <i class="fas fa-edit"></i>
            2022/03/17 Thu 15:17&nbsp;&nbsp;&nbsp;
            <span class="just-a-temp"><span>
            <i class="fas fa-redo"></i>
            2022/11/16 Wed 23:31
        </div>
    </div>
    <div class="article-content">
        <p>这一块是自己不怎么熟悉的部分，所以是需要后续来发力的，这里只是做了整理，不代表是自己的知识内容。<br>参考链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kyoner/p/11087755.html">https://www.cnblogs.com/kyoner/p/11087755.html</a><br>快慢指针:解决主要解决链表中的问题，比如典型的判定链表中是否包含环<br>左右指针:主要解决数组（或者字符串）中的问题，比如二分查找。</p>
<h1 id="一、快慢指针的常见算法"><a href="#一、快慢指针的常见算法" class="headerlink" title="一、快慢指针的常见算法"></a>一、快慢指针的常见算法</h1><p>快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。</p>
<h2 id="1、判定链表中是否含有环"><a href="#1、判定链表中是否含有环" class="headerlink" title="1、判定链表中是否含有环"></a>1、判定链表中是否含有环</h2><p>单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。<br>如果链表中不包含环，那么这个指针最终会遇到空指针 null 表示链表到头了，这还好说，可以判断该链表不含环。</p>
<h2 id="2、已知链表中含有环，返回这个环的起始位置"><a href="#2、已知链表中含有环，返回这个环的起始位置" class="headerlink" title="2、已知链表中含有环，返回这个环的起始位置"></a>2、已知链表中含有环，返回这个环的起始位置</h2><h2 id="3、寻找链表的中点"><a href="#3、寻找链表的中点" class="headerlink" title="3、寻找链表的中点"></a>3、寻找链表的中点</h2><h2 id="4、寻找链表的倒数第-k-个元素"><a href="#4、寻找链表的倒数第-k-个元素" class="headerlink" title="4、寻找链表的倒数第 k 个元素"></a>4、寻找链表的倒数第 k 个元素</h2><h1 id="二、左右指针的常用算法"><a href="#二、左右指针的常用算法" class="headerlink" title="二、左右指针的常用算法"></a>二、左右指针的常用算法</h1><p>左右指针在数组中实际是指两个索引值，一般初始化为 left &#x3D; 0, right &#x3D; nums.length - 1 。</p>
<h2 id="1、二分查找"><a href="#1、二分查找" class="headerlink" title="1、二分查找"></a>1、二分查找</h2><p>前文 二分查找算法详解 有详细讲解，这里只写最简单的二分算法，旨在突出它的双指针特性：</p>
<h2 id="2、两数之和"><a href="#2、两数之和" class="headerlink" title="2、两数之和"></a>2、两数之和</h2><h2 id="3、反转数组"><a href="#3、反转数组" class="headerlink" title="3、反转数组"></a>3、反转数组</h2><h2 id="4、滑动窗口算法"><a href="#4、滑动窗口算法" class="headerlink" title="4、滑动窗口算法"></a>4、滑动窗口算法</h2><h1 id="双指针-对撞指针"><a href="#双指针-对撞指针" class="headerlink" title="双指针(对撞指针)"></a>双指针(对撞指针)</h1><p>包含几道leetcode题目：</p>
<ul>
<li>167 有序数组的 Two Sum 2 (easy)</li>
<li>633 两数的平方和(easy)</li>
<li>345 反转元音字符(easy)</li>
<li>125 验证回文串(easy)</li>
<li>680 回文字符串(easy)</li>
<li>344 反转字符串(easy)</li>
<li>11 盛最多水容器(medium)</li>
</ul>
<h2 id="167-有序数组的two-sum-2-easy"><a href="#167-有序数组的two-sum-2-easy" class="headerlink" title="167. 有序数组的two sum 2 ( easy )"></a>167. 有序数组的two sum 2 ( easy )</h2><p>题目链接： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/</a></p>
<h3 id="解法：-采用头尾指针"><a href="#解法：-采用头尾指针" class="headerlink" title="解法： 采用头尾指针"></a>解法： 采用头尾指针</h3><p>解题思路：</p>
<p>由于数组为有序数组，因此利用头尾指针进行处理，头尾元素之和大于目标值，尾指针向前移动， 如果大于目标值，首指针向后移动</p>
<ol>
<li>先判断输入数组是否为空</li>
<li>设置首尾指针分别指向首尾元素</li>
<li>判断首尾指针对应的元素之和与目标值之间的关系：<ol>
<li>如果大于目标值： 尾指针前移，继续判断</li>
<li>如果小于目标值： 头指针后移， 继续判断</li>
<li>等于目标值： 返回头尾指针（由于题目要求从1开始，因此首尾指针均需要加1）</li>
</ol>
</li>
</ol>
<p><em>此题也可以采用hash表解决，后边章节再进行介绍</em></p>
<p>解题代码：</p>
<pre><code class="python">class Solution:
    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:
        if not numbers: return []  #输入列表不存在，返回空值
        start, end = 0, len(numbers)-1  #头尾指针

        while start &lt; end:  #保证尾指针在头指针后边
            _sum = numbers[start] + numbers[end]
            if  _sum &lt; target:  #小于目标值，首指针后移
                start += 1
            elif _sum &gt; target: #大于目标值，尾指针前移
                end -= 1
            else:               #等于目标值，返回结果
                return [start + 1, end + 1]
        return []
</code></pre>
<h2 id="633-两数的平方和-easy"><a href="#633-两数的平方和-easy" class="headerlink" title="633. 两数的平方和(easy)"></a>633. 两数的平方和(easy)</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-square-numbers/">https://leetcode-cn.com/problems/sum-of-square-numbers/</a></p>
<h3 id="解法：-采用头尾指针-1"><a href="#解法：-采用头尾指针-1" class="headerlink" title="解法： 采用头尾指针"></a>解法： 采用头尾指针</h3><p>解题思路同上题差不多，因此此处不再赘述。</p>
<pre><code>class Solution:
    def judgeSquareSum(self, c: int) -&gt; bool:
        assert c &gt;= 0
        start, end = 0, int(sqrt(c)) #设置首尾指针
        while start &lt;= end:
            _sum = start **2 + end **2
            if _sum &gt; c: end -= 1
            elif _sum &lt; c: start += 1
            else: return True
        return False
</code></pre>
<h2 id="345-反转元音字符-easy"><a href="#345-反转元音字符-easy" class="headerlink" title="345. 反转元音字符(easy)"></a>345. 反转元音字符(easy)</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">https://leetcode-cn.com/problems/reverse-vowels-of-a-string/</a></p>
<h3 id="解法：-采用头尾指针-2"><a href="#解法：-采用头尾指针-2" class="headerlink" title="解法： 采用头尾指针"></a>解法： 采用头尾指针</h3><p>同前边的方法一样，采用首尾指针，不再赘述</p>
<pre><code>class Solution:
    def reverseVowels(self, s: str) -&gt; str:
        if len(s)&lt;1: return s
        s = list(s)
        start, end = 0, len(s)-1
        vowels = set(&#39;aeiouAEIOU&#39;)
        while start &lt; end:
            if s[start] in vowels and s[end] in vowels:
                s[start], s[end] = s[end], s[start]
                start += 1
                end -= 1
            elif s[start] in vowels: end -= 1
            elif s[end] in vowels: start += 1
            else: 
                start +=1
                end -= 1
        return &#39;&#39;.join(s)
</code></pre>
<h2 id="125-验证回文串-easy"><a href="#125-验证回文串-easy" class="headerlink" title="125. 验证回文串(easy)"></a>125. 验证回文串(easy)</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome/">https://leetcode-cn.com/problems/valid-palindrome/</a></p>
<h3 id="解法：-首尾指针"><a href="#解法：-首尾指针" class="headerlink" title="解法： 首尾指针"></a>解法： 首尾指针</h3><p><strong>注意：</strong> 题目中忽略大小写，因此采用lower(), 题目中忽略非字母数字字符，因此采用isalnum()</p>
<ul>
<li>与前边几道题不一样的地方就是，先忽略非字母数字字符，然后忽略大小写，再进行比较。</li>
</ul>
<pre><code>class Solution:
    def isPalindrome(self, s: str) -&gt; bool:
        if len(s) &lt;= 1: return True
        start, end = 0, len(s)-1
        while start &lt; end:
            if s[start].isalnum() and s[end].isalnum():
                if s[start].lower() == s[end].lower(): 
                    start += 1
                    end -=1
                    continue
                else: return False
            elif s[start].isalnum(): end -= 1
            elif s[end].isalnum() : start += 1
            else:
                start += 1
                end -= 1
        return True
</code></pre>
<h2 id="680-验证回文字符串2-easy"><a href="#680-验证回文字符串2-easy" class="headerlink" title="680. 验证回文字符串2(easy)"></a>680. 验证回文字符串2(easy)</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome-ii/">https://leetcode-cn.com/problems/valid-palindrome-ii/</a></p>
<h3 id="解法：-首尾指针-1"><a href="#解法：-首尾指针-1" class="headerlink" title="解法： 首尾指针"></a>解法： 首尾指针</h3><p><strong>注意：</strong> 与前那边几道题不同的是，中间可以忽略一个字符，因此当比较到出现不同的字符时，需要比较两组，一组为start+1到end之间的字符，另一组为[start end-1]之间的字符是否为回文串</p>
<pre><code>class Solution:
    def validPalindrome(self, s: str) -&gt; bool:
        if len(s) &lt; 2: return True

        def isPalindrome(s, start, end):
            while start &lt; end:
                if s[start] == s[end]:
                    start += 1
                    end -= 1
                    continue
                else: return False
            return True

        start, end = 0, len(s)-1
        while start &lt; end:
            if s[start] == s[end]:
                start += 1
                end -= 1
                continue
            else: 
                return isPalindrome(s, start+1, end) or isPalindrome(s, start, end-1)
        return True
</code></pre>
<h2 id="344-反转字符串-easy"><a href="#344-反转字符串-easy" class="headerlink" title="344. 反转字符串(easy)"></a>344. 反转字符串(easy)</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-string/">https://leetcode-cn.com/problems/reverse-string/</a></p>
<h3 id="解法：首尾指针"><a href="#解法：首尾指针" class="headerlink" title="解法：首尾指针"></a>解法：首尾指针</h3><pre><code>class Solution:
    def reverseString(self, s: List[str]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify s in-place instead.
        &quot;&quot;&quot;
        if not s: return []
        start, end = 0, len(s)-1
        while start &lt; end:
            s[start], s[end] = s[end], s[start]
            start += 1
            end -= 1
</code></pre>
<h2 id="11-盛最多水的容器-medium"><a href="#11-盛最多水的容器-medium" class="headerlink" title="11.盛最多水的容器(medium)"></a>11.盛最多水的容器(medium)</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/container-with-most-water/">https://leetcode-cn.com/problems/container-with-most-water/</a></p>
<h3 id="解法：首尾指针-1"><a href="#解法：首尾指针-1" class="headerlink" title="解法：首尾指针"></a>解法：首尾指针</h3><pre><code class="python">class Solution:
    def maxArea(self, height: List[int]) -&gt; int:
        if len(height)&lt;2: return 0
        start, end = 0, len(height)-1
        max_area = 0  #存储最大面积
        while start &lt; end:
            area = (end - start) * min(height[start], height[end])
            max_area = max(area, max_area)   #更新最大的面积
            if height[start] &lt; height[end]:
                start += 1  #高度较低的那一端向前移动，寻找较高的高度
            else:
                end -= 1
        return max_area
</code></pre>
<h1 id="双指针-快慢指针"><a href="#双指针-快慢指针" class="headerlink" title="双指针(快慢指针)"></a>双指针(快慢指针)</h1><p>包含几道leetcode题目：</p>
<ul>
<li>141 判断列表是否存在环(easy)</li>
<li>283 移动零(easy)</li>
<li>27 移除元素(easy)</li>
<li>26 删除排序数组中的重复项(easy)</li>
<li>80 删除排序数组中的重复项 II(medium)</li>
</ul>
<h2 id="141-判断列表是否存在环"><a href="#141-判断列表是否存在环" class="headerlink" title="141. 判断列表是否存在环"></a>141. 判断列表是否存在环</h2><h3 id="解法：-快慢指针"><a href="#解法：-快慢指针" class="headerlink" title="解法： 快慢指针"></a>解法： 快慢指针</h3><pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: ListNode) -&gt; bool:
        if not head or head.next == None:
            return False
        slow, faster = head, head.next
        while slow and faster:
            if slow == faster: return True
            slow = slow.next
            if faster.next: faster = faster.next.next
            else: return False
        return False
</code></pre>
<p><em>此题也可使用hash表，建立一个hash表存储访问过的节点，当出现重复访问的节点，说明出现环</em></p>
<h2 id="283-移动零-easy"><a href="#283-移动零-easy" class="headerlink" title="283. 移动零(easy)"></a>283. 移动零(easy)</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a></p>
<h3 id="解法：-快慢指针-1"><a href="#解法：-快慢指针-1" class="headerlink" title="解法： 快慢指针"></a>解法： 快慢指针</h3><p>利用快慢指针，慢指针指向零元素，快指针指向非零元素，将快慢指针对应的元素交换</p>
<pre><code>1. 定义快慢指针
2. 如果慢指针指向非零元素，慢指针后移，快指针后移
3. 如果慢指针指向零元素，快指针指向非零元素，二者交换，快慢指针均后移
4. 如果慢指针指向零， 快指针指向零元素， 快指针后移
</code></pre>
<pre><code>class Solution:
    def moveZeroes(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        slower, faster = 0, 0 #快指针指向不为零的元素，慢指针指向零元素，满足条件就交换
        while faster &lt; len(nums):
            if nums[slower] != 0:
                slower += 1
            elif nums[faster] != 0:
                nums[slower],  nums[faster] = nums[faster], nums[slower]
                slower += 1
            faster += 1
</code></pre>
<h2 id="27-移除元素-easy"><a href="#27-移除元素-easy" class="headerlink" title="27. 移除元素(easy)"></a>27. 移除元素(easy)</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-element/">https://leetcode-cn.com/problems/remove-element/</a></p>
<h3 id="解法：快慢指针"><a href="#解法：快慢指针" class="headerlink" title="解法：快慢指针"></a>解法：快慢指针</h3><pre><code class="python">### 类似于上一题将等于val的元素移动至末尾
class Solution:
    def removeElement(self, nums: List[int], val: int) -&gt; int:
        if not nums: return 0
        slower, faster = 0, 0
        while faster &lt; len(nums):
            if nums[slower] != val: slower += 1
            elif nums[faster] != val: 
                nums[slower], nums[faster] = nums[faster], nums[slower]
                slower += 1
            faster += 1
        return slower        
</code></pre>
<pre><code class="python">## 由于本题要求直接删除元素，不需要像移动零元素那样，直接覆盖即可
class Solution:
    def removeElement(self, nums: List[int], val: int) -&gt; int:
        if not nums: return 0
        slower, faster = 0, 0
        while faster &lt; len(nums):
            nums[slower] = nums[faster]
            if nums[slower] == val: 
                faster += 1
                continue
            slower += 1
            faster += 1
        return slower
</code></pre>
<h2 id="26-删除排序数组中的重复项-easy"><a href="#26-删除排序数组中的重复项-easy" class="headerlink" title="26. 删除排序数组中的重复项(easy)"></a>26. 删除排序数组中的重复项(easy)</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p>
<h3 id="解法：-快慢指针-2"><a href="#解法：-快慢指针-2" class="headerlink" title="解法： 快慢指针"></a>解法： 快慢指针</h3><pre><code>class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        if not  nums: return 0
        # 慢指针指向待写入元素的位置，快指针遍历数组
        slower, faster = 0, 0
        while faster&lt; len(nums):
        #当快指针指向的元素与慢指针不同时，说明相同的元素已经遍历结束，此时将慢指针后移，将快指针的元素写入慢指针位置，保留一个元素
            if nums[slower] != nums[faster]:
                slower += 1
                nums[slower] = nums[faster]
            faster += 1
        return slower + 1
</code></pre>
<h2 id="80-删除排序数组中的重复项-II-medium"><a href="#80-删除排序数组中的重复项-II-medium" class="headerlink" title="80. 删除排序数组中的重复项 II(medium)"></a>80. 删除排序数组中的重复项 II(medium)</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/</a></p>
<h3 id="解法：快慢指针-1"><a href="#解法：快慢指针-1" class="headerlink" title="解法：快慢指针"></a>解法：快慢指针</h3><pre><code>class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        if not nums: return 0
        flag = True
        slower, faster = 0, 1
        while faster &lt;len(nums):
            if nums[slower] != nums[faster]:
                slower += 1
                nums[slower] = nums[faster]
                flag = True
            else:
                if flag:
                    slower += 1
                    nums[slower] = nums[faster]
                    flag = False
            faster += 1 
        return slower + 1
</code></pre>
<h1 id="其他双指针"><a href="#其他双指针" class="headerlink" title="其他双指针"></a>其他双指针</h1><p>包含几道leetcode题目：</p>
<ul>
<li><ol start="88">
<li>归并有序数组(easy)</li>
</ol>
</li>
<li><ol start="524">
<li>最长的子序列(medium)</li>
</ol>
</li>
</ul>
<h2 id="88-归并有序数组-easy"><a href="#88-归并有序数组-easy" class="headerlink" title="88. 归并有序数组(easy)"></a>88. 归并有序数组(easy)</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-sorted-array/">https://leetcode-cn.com/problems/merge-sorted-array/</a></p>
<h3 id="解法：-三个指针（类似于首尾指针）"><a href="#解法：-三个指针（类似于首尾指针）" class="headerlink" title="解法： 三个指针（类似于首尾指针）"></a>解法： 三个指针（类似于首尾指针）</h3><p>将两个有序数组合并，必须执行in_place操作<br>解题思路：<br>    * 设计三个指针，分别指向nums1的末尾，nums2的末尾，合成之后数组的末尾<br>    * 然后比较两个数组最大值，然后填入合成之后数组的末尾</p>
<pre><code>class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums1 in-place instead.
        &quot;&quot;&quot;
        #三个指针，从后向前进行插入
        s1, s2, end =m-1, n-1, m + n -1
        while s1 &gt;=0 and s2 &gt;=0:
            if nums1[s1] &lt;= nums2[s2]:
                nums1[end] = nums2[s2]
                s2 -= 1
            else:
                nums1[end] = nums1[s1]
                s1 -= 1
            end -= 1
        if s2 &gt;= 0:
            nums1[:s2+1] = nums2[:s2+1]
</code></pre>
<h2 id="524-最长的子序列-medium"><a href="#524-最长的子序列-medium" class="headerlink" title="524. 最长的子序列(medium)"></a>524. 最长的子序列(medium)</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/submissions/">https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/submissions/</a></p>
<h3 id="解法：-双指针"><a href="#解法：-双指针" class="headerlink" title="解法： 双指针"></a>解法： 双指针</h3><pre><code>class Solution:
    def findLongestWord(self, s: str, d: List[str]) -&gt; str:
        if not s or not d: return &#39;&#39;       
        S = &#39;&#39;  # 保存结果字符串
        ## 循环遍历list字符串列表，将一个指针p2指向子字符串的开头
        for _s in d:
        ## 在比较的过程中，将找到的子串存储，然后在下一次找到后更新子串与子串的长度
            p2 = 0
            for p1 in range(len(s)):
                if p2 &lt; len(_s) and s[p1] == _s[p2]:
                    p2 += 1
                    continue
            ## 判断是否找到对应的字符串，如果第一次找到字串，保存结果
            if p2 == len(_s) and not S:
                S = _s
            ## 如果是不是第一次找到满足条件的子串，比较长度保留较长的，子串长度相等的，保存字典序较小的
            elif p2 == len(_s):
                if len(S) &gt; len(_s):
                    continue
                elif len(S) &lt; len(_s):
                    S = _s
                else:
                    if S &lt; _s: continue
                    else: S = _s
        return S
</code></pre>

    </div>

    <div class="totop">ToTOP</div>
</div>
        <div class="footer">
    <a href="#">
        2018 <i class="fab fa-studiovinari"></i> bear <i class="fas fa-angle-double-up"></i>
    </a>
</div>


<script src="/js/totop.js"></script>


<script src="/js/search.js"></script>

    </div>
</body>

</html>