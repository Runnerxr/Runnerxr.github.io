<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>牛客网刷基础题值得记录的一些问题（值得就整理） | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="既然记下来就是一些十分基础的题目，肯定是要百分百的掌握的。 牛客网-找出所有三位数中质数的个数方法一： 12345678a &#x3D; []for i in range(100,1000):    for j in range(2,i):        if (i%j &#x3D;&#x3D; 0):            break    else:        a.append(i)   #在数组a原有的基础上加上元素">
<meta property="og:type" content="article">
<meta property="og:title" content="牛客网刷基础题值得记录的一些问题（值得就整理）">
<meta property="og:url" content="http://example.com/2022/03/07/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E5%9F%BA%E7%A1%80%E9%A2%98%E5%80%BC%E5%BE%97%E8%AE%B0%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%88%E5%80%BC%E5%BE%97%E5%B0%B1%E6%95%B4%E7%90%86%EF%BC%89/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="既然记下来就是一些十分基础的题目，肯定是要百分百的掌握的。 牛客网-找出所有三位数中质数的个数方法一： 12345678a &#x3D; []for i in range(100,1000):    for j in range(2,i):        if (i%j &#x3D;&#x3D; 0):            break    else:        a.append(i)   #在数组a原有的基础上加上元素">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://runnerxr.github.io//post-images/1651476583992.png">
<meta property="og:image" content="https://runnerxr.github.io//post-images/1651476591581.png">
<meta property="og:image" content="https://runnerxr.github.io//post-images/1651508460475.png">
<meta property="og:image" content="https://runnerxr.github.io//post-images/1651476368777.gif">
<meta property="og:image" content="https://runnerxr.github.io//post-images/1651487261896.gif">
<meta property="og:image" content="https://runnerxr.github.io//post-images/1652192059144.png">
<meta property="og:image" content="https://runnerxr.github.io//post-images/1652175614590.png">
<meta property="og:image" content="https://runnerxr.github.io//post-images/1652191419226.png">
<meta property="og:image" content="https://runnerxr.github.io//post-images/1651409575289.png">
<meta property="og:image" content="https://runnerxr.github.io//post-images/1651409821187.png">
<meta property="article:published_time" content="2022-03-07T08:34:49.000Z">
<meta property="article:modified_time" content="2022-06-07T07:21:07.561Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="python知识小记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://runnerxr.github.io//post-images/1651476583992.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-牛客网刷基础题值得记录的一些问题（值得就整理）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/07/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E5%9F%BA%E7%A1%80%E9%A2%98%E5%80%BC%E5%BE%97%E8%AE%B0%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%88%E5%80%BC%E5%BE%97%E5%B0%B1%E6%95%B4%E7%90%86%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2022-03-07T08:34:49.000Z" itemprop="datePublished">2022-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      牛客网刷基础题值得记录的一些问题（值得就整理）
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>既然记下来就是一些十分基础的题目，肯定是要百分百的掌握的。</p>
<h1 id="牛客网-找出所有三位数中质数的个数"><a href="#牛客网-找出所有三位数中质数的个数" class="headerlink" title="牛客网-找出所有三位数中质数的个数"></a>牛客网-找出所有三位数中质数的个数</h1><p>方法一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>,<span class="number">1000</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,i):</span><br><span class="line">        <span class="keyword">if</span> (i%j == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a.append(i)   <span class="comment">#在数组a原有的基础上加上元素i</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a))</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>,<span class="number">1000</span>):<span class="comment">#对100~999的所有的三位数进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,i): <span class="comment">#对从2~i的所有数进行遍历(排除了1和i本身的这两种情况)</span></span><br><span class="line">        <span class="keyword">if</span> (i % j==<span class="number">0</span>):</span><br><span class="line">            n = n +<span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">900</span>-n)</span><br></pre></td></tr></table></figure>

<h1 id="前n项和的问题"><a href="#前n项和的问题" class="headerlink" title="前n项和的问题"></a>前n项和的问题</h1><p>看似简单，自己因为练习的比较少，觉得很好做，真正去调试的时候发现这些简单的题目也会出错。记录的原因就是不要让自己忘了最基本的东西也是最需要掌握的。<br> 题目一：<br> 输入一个整数n,计算 1+1&#x2F;（1-3）+1&#x2F;（1-3+5）+…+1&#x2F;(1-3+5-…((-1)^(n-1))*(2n-1))<br> 输出描述：输出一个浮点数，保留3位小数<br> 代码如下：<br> n &#x3D; int(input())<br>ai &#x3D; 0<br>total &#x3D; 0<br>#对n项数列的每一项进行遍历<br>#对其中一项的分母的各个子项进行遍历，这里j的范围很重要</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):                   </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,i+<span class="number">1</span>):                 </span><br><span class="line">        ai += (-<span class="number">1</span>)**(j-<span class="number">1</span>)*(<span class="number">2</span>*j-<span class="number">1</span>) <span class="comment">#对每一项值的分母进行记录</span></span><br><span class="line">    total += <span class="number">1</span>/ai <span class="comment">#前i项数列的和</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:.3f&#125;&quot;</span>.<span class="built_in">format</span>(total))</span><br></pre></td></tr></table></figure>
<p>题目二：<br>计算 1+（1+2）+（1+2+3）+…+(1+2+3+…+n)<br>输出描述：输出一个整数<br>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">ai = <span class="number">0</span></span><br><span class="line">aj = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):<span class="comment">#对n项数列的每一项进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,i+<span class="number">1</span>):<span class="comment">#对其中一项的分母的各个子项进行遍历</span></span><br><span class="line">        aj =aj+j</span><br><span class="line">    ai += aj</span><br><span class="line"><span class="built_in">sum</span> +=ai       </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>

<h1 id="一行输入两个整数，输出两个整数最大公约数和最小公倍数的和"><a href="#一行输入两个整数，输出两个整数最大公约数和最小公倍数的和" class="headerlink" title="一行输入两个整数，输出两个整数最大公约数和最小公倍数的和"></a>一行输入两个整数，输出两个整数最大公约数和最小公倍数的和</h1><p>主要是掌握最小公倍数的求法，最小公倍数与最大公约数是相关联的<br>如果能够求出最大公约数，则最小的公倍数&#x3D;a*b&#x2F;&#x2F;最大公约数<br><strong>方法一：辗转相除法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,(<span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>))) </span><br><span class="line">s=n*m</span><br><span class="line"><span class="keyword">while</span> n%m!=<span class="number">0</span>:</span><br><span class="line">    n,m=m,(n%m)  </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># print(m,&#x27;is the maximum common divisor&#x27;)</span></span><br><span class="line">    <span class="comment"># print(s//m,&#x27;is the least common multiple&#x27;) </span></span><br><span class="line">    <span class="built_in">print</span>(m+s//m)</span><br></pre></td></tr></table></figure>
<p><strong>更相减损法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,(<span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>))) </span><br><span class="line">s=n*m  </span><br><span class="line"><span class="keyword">while</span> n!=m:</span><br><span class="line">    <span class="keyword">if</span> n&gt;m:</span><br><span class="line">        <span class="comment">#n-=m  #以后n的值为现在n的值减去m,也即n = n -m</span></span><br><span class="line">        n = n - m</span><br><span class="line">    <span class="keyword">elif</span> n&lt;m:</span><br><span class="line">        <span class="comment">#m-=n</span></span><br><span class="line">        m = m - n</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(m+s//m)</span><br></pre></td></tr></table></figure>

<p>两者的区别：<br>（1）都是求最大公因数的方法，计算上辗转相除法以除法为主，更相减损术以减法为主，计算次数上辗转相除法计算次数相对较少，特别当两个数字大小区别较大时计算次数的区别较明显。更相减损术的时间复杂度约为O(N），辗转相除法的时间复杂度约为O(logN)。<br>（2）从结果体现形式来看，辗转相除法体现结果是以相除余数为0则得到，而更相减损术则以减数与差相等而得到。</p>
<h1 id="BC133-回型矩阵"><a href="#BC133-回型矩阵" class="headerlink" title="BC133-回型矩阵"></a>BC133-回型矩阵</h1><p>刚看到这题直到意思，但是也是不知道该如何处理，还得是去看题解才知道的，这里有两份题解，也是值得自己看一下的。首先有一个总起的思路：回型矩阵的特点：顺时针回型矩阵，按照一个回型为一层的情况来看，推导的前三条矩阵边上的**”结束值”-“起始值”&#x3D;”矩阵边长”-1**，第四条矩阵边的”结束值”为该层的起始值</p>
<ol>
<li>根据设定的矩阵边长，生成一个二维数组</li>
<li>按照矩阵边长生成该层的数据池<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这种方式不太好理解，放弃</span></span><br><span class="line"><span class="keyword">while</span> size &gt;<span class="number">0</span>:</span><br><span class="line">    create pool()</span><br><span class="line">    layer +=<span class="number">1</span></span><br><span class="line">    size -=<span class="number">2</span></span><br></pre></td></tr></table></figure>
最终的代码如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw_matrix</span>(<span class="params">begin,size,layer,arry,controlle_num</span>):</span><br><span class="line">    <span class="comment"># 以顺时针方向建立递增矩阵，按照层级</span></span><br><span class="line">    <span class="comment"># 根据递增1的特点，建立当前层的上下左右，四个list,形成资源池</span></span><br><span class="line">    <span class="comment"># 每个方向列表的长度都等于size的长度</span></span><br><span class="line">    top = <span class="built_in">range</span>(begin,begin +size)</span><br><span class="line">    right = <span class="built_in">range</span>(begin+size-<span class="number">1</span>,begin+size*<span class="number">2</span>-<span class="number">1</span>)</span><br><span class="line">    bottom = <span class="built_in">range</span>(begin+size*<span class="number">2</span>-<span class="number">2</span>,begin+size*<span class="number">3</span>-<span class="number">2</span>)</span><br><span class="line">    left = <span class="built_in">range</span>(begin+size*<span class="number">3</span>-<span class="number">3</span>,begin+size*<span class="number">4</span>-<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 顺时针的左list最后一个值改为起始值</span></span><br><span class="line">    left[size-<span class="number">1</span>]=begin</span><br><span class="line"></span><br><span class="line">    <span class="comment"># size相当于矩阵的边长，i既可以表示长，也可以表示宽</span></span><br><span class="line">    <span class="comment"># 通过i步进来从本层的资源池里面取出各个值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        arry[layer][layer+i] = top[i]</span><br><span class="line">        arry[layer+i][controlle_num-layer-<span class="number">1</span>]=right[i]</span><br><span class="line">        arry[controlle_num-layer-<span class="number">1</span>][controlle_num-layer-i-<span class="number">1</span>] = bottom[i]</span><br><span class="line">        arry[controlle_num-<span class="number">1</span>-layer-i][layer] = left[i]</span><br><span class="line">    <span class="keyword">return</span> arry</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Matirx</span>(<span class="params">size,begin=<span class="number">1</span>,layer=<span class="number">0</span></span>):</span><br><span class="line">    controlle_num = size</span><br><span class="line">    arry = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        arry.append(<span class="built_in">range</span>(size))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> size &gt;<span class="number">0</span>:</span><br><span class="line">        arry = draw_matrix(begin,size,layer,arry,controlle_num)</span><br><span class="line">        begin = begin+(<span class="number">4</span>*(size-<span class="number">1</span>))</span><br><span class="line">        size = size -<span class="number">2</span></span><br><span class="line">        layer = layer +<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> arry</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dat = Matrix(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(dat[i])</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 换第二种方式</span></span><br><span class="line">n= <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">s = [[-<span class="number">1</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">cnt =<span class="number">0</span></span><br><span class="line">directions=[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,-<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>],[-<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line"><span class="comment"># 0 1 = right</span></span><br><span class="line"><span class="comment"># 1 0 = down</span></span><br><span class="line"><span class="comment"># 0 -1 = left</span></span><br><span class="line"><span class="comment"># -1 0 = up</span></span><br><span class="line">x,y = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">state=<span class="number">0</span></span><br><span class="line">trace = []</span><br><span class="line"><span class="comment"># 总共有n**2个数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n**<span class="number">2</span>):</span><br><span class="line">    cnt+=<span class="number">1</span></span><br><span class="line">    s[y][x]=cnt</span><br><span class="line">    <span class="comment"># 记录已经经过的路径,这里的想法很好，如果不记录的话就永远时外层的在变化</span></span><br><span class="line">    trace.append([y,x])</span><br><span class="line">    y+=directions[state%<span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">    x+=directions[state%<span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> ([y,x] <span class="keyword">in</span> trace) <span class="keyword">or</span> y&gt;=n <span class="keyword">or</span> y&lt;<span class="number">0</span> <span class="keyword">or</span> x&gt;=n <span class="keyword">or</span> x&lt;<span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 已经经过或者已经越界的话，回退坐标</span></span><br><span class="line">        y-=directions[state%<span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">        x-=directions[state%<span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 更新状态</span></span><br><span class="line">        state +=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 更新坐标</span></span><br><span class="line">        y+=directions[state%<span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">        x+=directions[state%<span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line"><span class="comment">#print(s)</span></span><br><span class="line"><span class="comment"># 按题目条件打印有两种方式</span></span><br><span class="line"><span class="comment"># 按照两次遍历元素的方式</span></span><br><span class="line"><span class="comment"># 按照下标索引的方式（这种更好理解）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">for i in s:</span></span><br><span class="line"><span class="string">    for j in i:</span></span><br><span class="line"><span class="string">        print(j,end=&#x27; &#x27;)</span></span><br><span class="line"><span class="string">    print()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="built_in">print</span>(s[i][j],end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="comment"># 每次内循环结束后进行一次换行</span></span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>总结，要以这道题为原型来反思矩阵的计算、统计、输入与输出的问题。</p>
<h1 id="BC145笨小猴（很重要）"><a href="#BC145笨小猴（很重要）" class="headerlink" title="BC145笨小猴（很重要）"></a>BC145笨小猴（很重要）</h1><p>做题链接：<br><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/17865bc2a75c4944a872ef709958c56e?tpId=290&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=/exam/oj?tab=%25E8%25AF%25AD%25E6%25B3%2595%25E7%25AF%2587&topicId=290">https://www.nowcoder.com/practice/17865bc2a75c4944a872ef709958c56e?tpId=290&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E8%25AF%25AD%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D290</a><br>使用python判断质数的简单方法：<a target="_blank" rel="noopener" href="https://www.jb51.net/article/83616.htm">https://www.jb51.net/article/83616.htm</a><br>题目描述：找出一个输入的单词中出现频率最大的那个字母出现的次数与频率最小的那个字母出现的次数的差值，并判断该差值是否是一个质数，根据是否是质数，输出不同的结果。<br>解题思路：</p>
<ol>
<li>用数组创建一个哈希表，下标0~25对应的是26个英文单词</li>
<li>统计字母出现的频率</li>
<li>遍历数组，寻找单词中频率最高和最低的字母出现的次数</li>
<li>判断一个数是否为质数（需要写一个对应的判断质数的函数）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写一个判断是否为质数的函数</span></span><br><span class="line"><span class="comment">#定义一个判断质数的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zhi</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,n):</span><br><span class="line">        <span class="keyword">if</span> n%j==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">a= <span class="built_in">input</span>()</span><br><span class="line">lt =[]</span><br><span class="line"><span class="comment">#在所给的单词中去遍历</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    <span class="comment">#用一个变量去储存每一个单词</span></span><br><span class="line">    b =a[i]</span><br><span class="line">    <span class="comment">#用count函数去记录出现的次数</span></span><br><span class="line">    c=a.count(b)</span><br><span class="line">    <span class="comment">#把每次遍历的元素出现的次数都累加到列表中</span></span><br><span class="line">    lt.append(c)</span><br><span class="line"><span class="comment">#对记录的次数进行排序，然后找到maxn和minn</span></span><br><span class="line">lt.sort()</span><br><span class="line">maxn=lt[-<span class="number">1</span>]</span><br><span class="line">minn=lt[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> zhi(maxn-minn):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Lucky Word&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(maxn-minn)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;No Answer&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
调用相应的模块来解题：这种方法也值得自己去掌握清楚<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入python内建模块的collections模块中的Counter类</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="comment">#这里是以类似字典的方式存储起来的</span></span><br><span class="line"><span class="comment">#Counter(&#123;a:x ,b:y&#125; , c:z&#125;)</span></span><br><span class="line">c = Counter(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment">#用到most_common()函数,这里返回的是是一个列表，其中列表的每一个元素都是一个元组</span></span><br><span class="line"><span class="comment">#所以才会用c.most_common[0][1]来找到出现最多频率字母的次数</span></span><br><span class="line"><span class="comment">#most_common()是collections模块中Counter类的函数，使用的时候需要先导入collections模块</span></span><br><span class="line"><span class="comment">#返回的是元组列表，不是字典</span></span><br><span class="line">maxn = c.most_common()[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">minn = c.most_common()[-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 检查质数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isPrime</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>]:</span><br><span class="line">    <span class="comment">#if n==0 or n==1:</span></span><br><span class="line">    <span class="comment">#if n &lt;=1:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment">#运用到了质数的定义法：如果在2~√n中都不能被整除，那么在√n~n中也一定不能被整除</span></span><br><span class="line">    <span class="comment">#并且由于开方之后是浮点数，需要向上取整，这里进行了+1后int取整，或者直接round(n**0.5)代替int(n**0.5)+1)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n%i==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isPrime(maxn-minn):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Lucky Word&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(maxn-minn)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;No Answer&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="BM44-有效括号"><a href="#BM44-有效括号" class="headerlink" title="BM44-有效括号"></a>BM44-有效括号</h1><p>结合leetcoad上的一些思路：<br>自己第一遍做的时候，只能通过一部分的案例，题目要求最好是用栈来解决，虽然自己也用了但是也只是解决了一部分问题，以下是自己整理题解的时候发现的，希望自己能够好好掌握并且触类旁通。<br>思路如下：括号的匹配规则符合先进后出的规则，最外层的括号最早出现的左括号，也对应最晚出现的右括号（<strong>符合先进后出的规则，可以使用先进后出的栈</strong>），遇到左括号就将相应匹配的右括号加入栈中，后续如果是合法的，右括号来的顺序就是栈中弹出的顺序。</p>
<ol>
<li>创建辅助栈，遍历字符串</li>
<li>每次遇到小括号的左，中括号的左，大括号的左，就将其对应的右括号加入栈中，期待在后续遇到。</li>
<li>如果没有遇到左括号但是栈为空，说明直接遇到了右括号，不合法</li>
<li>其他情况下，如果遇到右括号，刚好会与栈顶元素相同，弹出栈顶元素继续遍历</li>
<li>只要括号是匹配的，栈中元素最后是为空的，因此检查栈是否为空即可最后判读是否合法</li>
</ol>
<p>下面的这两张图也可以用来辅助理解<br><img src="https://runnerxr.github.io//post-images/1651476583992.png"><br><img src="https://runnerxr.github.io//post-images/1651476591581.png"><br>注意事项：<br><img src="https://runnerxr.github.io//post-images/1651508460475.png"></p>
<span id="more"></span>
<ol>
<li>这两条elif语句是不能颠倒的，首先在栈内有元素，才能查看当前元素是否等于栈顶元素，如果直接颠倒的话，直接碰到的是右括号就会报错，因为stack一直是空（没有加入元素），也就不可能弹出元素。</li>
<li>其次不要用if语句全部代替elif语句，会出现问题</li>
<li>而且上面利用栈的过程其实是很巧妙的，自己当时写的时候，老是有算例通不过去，根本原因在：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self , s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 如果字符串为空，或者字符串的长度为奇数个， 直接返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)==<span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(s)%<span class="number">2</span>!=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 如果发现元素是左括号，就将右括号加入栈中</span></span><br><span class="line">            <span class="keyword">if</span> i==<span class="string">&quot;(&quot;</span>:</span><br><span class="line">                stack.append(<span class="string">&quot;)&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> i==<span class="string">&quot;[&quot;</span>:</span><br><span class="line">                stack.append(<span class="string">&quot;]&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> i==<span class="string">&quot;&#123;&quot;</span>:</span><br><span class="line">                stack.append(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">             <span class="comment"># 如果发现此时栈已经为空了，说明直接遇到了右括号</span></span><br><span class="line">             <span class="comment"># 给一个对应的例子：&quot;]()]&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(stack)==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 如果发现此时的数与栈顶元素相同，弹出栈顶元素继续遍历</span></span><br><span class="line">            <span class="keyword">elif</span> i==stack[-<span class="number">1</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="comment"># 检查栈是否为空来看括号是否合法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 这里给一个到这里仍然不能通过的例子：&quot;[()]&#123;&quot;，这个例子前面的几步都能执行，但是到了最后一步，这里加入了一个左括号，这里的栈是不为空的，需要返回False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>下面是换一种写法，本质上是一样的<br><img src="https://runnerxr.github.io//post-images/1651476368777.gif"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="comment"># 如果字符串的长度是奇数，直接返回False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 对字符串进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 如果发现是左括号,就将其加入进去</span></span><br><span class="line">            <span class="keyword">if</span> i==<span class="string">&quot;(&quot;</span> <span class="keyword">or</span> i==<span class="string">&#x27;[&#x27;</span> <span class="keyword">or</span> i==<span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="comment"># 遇到的不是左括号的情况</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果是一个空栈，说明一开始就遇到右括号</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 如果遇到的符合正好等于栈顶元素（说明匹配）</span></span><br><span class="line">                <span class="comment"># 将栈顶元素进行弹出</span></span><br><span class="line">                <span class="keyword">elif</span> i==<span class="string">&#x27;)&#x27;</span> <span class="keyword">and</span> stack[-<span class="number">1</span>]==<span class="string">&#x27;(&#x27;</span> <span class="keyword">or</span> i==<span class="string">&#x27;]&#x27;</span> <span class="keyword">and</span> stack[-<span class="number">1</span>]==<span class="string">&#x27;[&#x27;</span> <span class="keyword">or</span> i==<span class="string">&#x27;&#125;&#x27;</span> <span class="keyword">and</span> stack[-<span class="number">1</span>]==<span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="comment"># 如果没有找到相同的，说明也不符合要求</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 遍历完整个字符之后查看栈是否为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h1 id="BM46-最小的K个数"><a href="#BM46-最小的K个数" class="headerlink" title="BM46-最小的K个数"></a>BM46-最小的K个数</h1><h1 id="BM47-寻找第K大"><a href="#BM47-寻找第K大" class="headerlink" title="BM47-寻找第K大"></a>BM47-寻找第K大</h1><p>由于题目要求空间复杂度是O(1),所以用快速排序是允许的。以这题为基础，把几种排序的思想再好好的进行回顾（不是一件简单的事情）</p>
<h1 id="BM49-表达式求值-在后面也有相应的解答"><a href="#BM49-表达式求值-在后面也有相应的解答" class="headerlink" title="BM49-表达式求值(在后面也有相应的解答)"></a>BM49-表达式求值(在后面也有相应的解答)</h1><p>好像完全没有一点思路呀，是不是栈的知识点还没有完全的弄懂<br>题目描述：写一个整数计算器，支持加减乘三种运算和括号，保证结果始终在整型范围内<br>难点：如何考虑使用栈和递归的方法，对于括号的处理在44题里面有了一定的了解了。<br>这题思路好像打不开，主要是不知道该如何处理运算符号和括号的问题<br>再看这道题，发现这道题一点也不简单，应该有点属于难题的范畴了，哎，还是自己太菜了，还得加把劲再看看里面的内容，还是不够深入。<br>先看看题解，打开一下思路，不然后面这几道3题目都是相同类型的，都在这上面翻车。<br>思路：</p>
<ol>
<li><strong>处理运算优先级的问题</strong>：遇到乘法就把前面一个数和后面一个数乘起来，遇到加法（减法同），最后乘法处理完了，就剩余加法，把之前存的数字进行相加。</li>
<li><strong>处理括号的问题</strong>：<strong>将括号中的部分看成一个新的表达式</strong>，也就是一个子问题，因此可以将新的表达式进行递归的求解，得到一个数字，再运算<ul>
<li><strong>终止条件</strong>：每次遇到左括号意味着子问题进行计算，那么遇到右括号代表这个递归结束</li>
<li><strong>返回值</strong>：将括号内部的计算结果值返回</li>
<li><strong>本级任务</strong>：遍历括号里面的字符，进行计算<br>3.<strong>非个位数地运算数</strong>：在扫描字符串地时候，多扫描相邻地字符数字即可<br>具体做法如下：</li>
</ul>
</li>
<li>使用辅助栈处理优先级，默认符号为加号</li>
<li>遍历字符串，遇到数字，则将连续的数字字符部分转化为int型数字</li>
<li>遇到左括号，则<strong>将括号后的部分送入递归，处理子问题</strong>；遇到右括号代表已经达到这个子问题的结尾，<strong>结束继续遍历字符串，将子问题的加法部分相加为一个数字</strong>，返回。</li>
<li>当遇到符号的时候，如果是+ 得到的数字正常入栈，如果是-，则将相反数入栈，<strong>如果是</strong>*，则将栈中的内容弹出后与元素相乘再入栈</li>
<li>最后将栈中剩余的所有元素，进行一次全部的相加<br>总说：采用栈的方式，从左往右阶段性的找到可以优先计算的部分，不断地缩短栈地数据深度，直到把所有地数据都扫描完，同时栈深度合并为1<br><img src="https://runnerxr.github.io//post-images/1651487261896.gif"><br>可能需要补充逆波兰算法的原理（把这道题慕弄懂了再说）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 贴一个带头文件形式的（可本地调试）</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> AnyStr</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self , s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 用于存储数字的栈</span></span><br><span class="line">        number=[]</span><br><span class="line">        <span class="comment"># 用于存储运算操作的栈</span></span><br><span class="line">        operate=[]</span><br><span class="line">        <span class="comment"># 存储数字的空字符串</span></span><br><span class="line">        pre=<span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 遍历每个字符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 判断字符是否属于操作运算或者括号</span></span><br><span class="line">            <span class="keyword">if</span> i==<span class="string">&#x27;(&#x27;</span> <span class="keyword">or</span> i==<span class="string">&#x27;)&#x27;</span> <span class="keyword">or</span> i==<span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> i==<span class="string">&#x27;-&#x27;</span> <span class="keyword">or</span> i==<span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="comment"># 判断运算符之前是否有数字</span></span><br><span class="line">                <span class="comment"># 如果运算符之前的pre里面是有数字的</span></span><br><span class="line">                <span class="keyword">if</span> pre!=<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 把字符串数字转换为数字并添加进入number数组中（这里的理解：字符拼接好了，并且已经遇到了运算操作）</span></span><br><span class="line">                    number.append(<span class="built_in">int</span>(pre))</span><br><span class="line">                    <span class="comment"># 接下来就要进行相应的运算操作</span></span><br><span class="line">                    <span class="comment"># 先做乘法运算</span></span><br><span class="line">                    <span class="keyword">if</span> operate <span class="keyword">and</span> operate[-<span class="number">1</span>]==<span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        <span class="comment"># 弹出运算符</span></span><br><span class="line">                        op = operate.pop()</span><br><span class="line">                        <span class="comment"># 弹出操作数字</span></span><br><span class="line">                        num2=number.pop()</span><br><span class="line">                        num1=number.pop()</span><br><span class="line">                        <span class="comment"># 计算两数</span></span><br><span class="line">                        num3=self.cal(num1,num2,op)</span><br><span class="line">                        <span class="comment"># 将结果添加到数组栈中</span></span><br><span class="line">                        number.append(num3)</span><br><span class="line">                    <span class="keyword">if</span> operate <span class="keyword">and</span> operate[-<span class="number">1</span>]==<span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        operate[-<span class="number">1</span>]=<span class="string">&#x27;+&#x27;</span></span><br><span class="line">                        number[-<span class="number">1</span>]=(-<span class="number">1</span>)*number[-<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 有数字，但是数字已经被操作或者加入了相应的栈中</span></span><br><span class="line">                <span class="comment"># 对pre进行初始化</span></span><br><span class="line">                pre=<span class="string">&#x27;&#x27;</span></span><br><span class="line">                <span class="comment"># 添加操作数</span></span><br><span class="line">                operate.append(i)</span><br><span class="line">                        </span><br><span class="line">            <span class="comment">#当前遍历的字符是数字</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 对数字进行拼接</span></span><br><span class="line">                pre+=i</span><br><span class="line">            <span class="comment"># 如果发现右括号，就需要运算括号内的内容</span></span><br><span class="line">            <span class="keyword">if</span> operate <span class="keyword">and</span> operate[-<span class="number">1</span>]==<span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="comment"># 弹出右括号</span></span><br><span class="line">                operate.pop()</span><br><span class="line">                <span class="comment"># 开始运算括号内的数字</span></span><br><span class="line">                <span class="comment"># 只要运算栈存在，并且栈顶的元素不是左括号，就不停的对操作数和数组栈弹出</span></span><br><span class="line">                <span class="keyword">while</span> operate <span class="keyword">and</span> operate[-<span class="number">1</span>]!=<span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 用变量记录运算操作，因为后面的函数调用是需要的</span></span><br><span class="line">                    <span class="comment"># 依次弹出之前加入的两个数（数字是先进后出的，这里用num2和num1区分）</span></span><br><span class="line">                    op=operate.pop()</span><br><span class="line">                    num2=number.pop()</span><br><span class="line">                    num1=number.pop()</span><br><span class="line">                    num3=self.cal(num1,num2,op)</span><br><span class="line">                    <span class="comment"># 将计算好的值更新加入number栈中</span></span><br><span class="line">                    number.append(num3)</span><br><span class="line">                <span class="comment"># 此时发现栈顶元素已经是&#x27;(&#x27;</span></span><br><span class="line">                <span class="comment"># 弹出左括号</span></span><br><span class="line">                operate.pop()</span><br><span class="line">                <span class="comment"># 将括号中的负号 数字都转化为相反数</span></span><br><span class="line">                <span class="keyword">if</span> operate <span class="keyword">and</span> operate[-<span class="number">1</span>]==<span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    operate[-<span class="number">1</span>]=<span class="string">&#x27;+&#x27;</span></span><br><span class="line">                    number[-<span class="number">1</span>]=(-<span class="number">1</span>)*number[-<span class="number">1</span>]</span><br><span class="line">                    </span><br><span class="line">        <span class="comment"># 整个for循环结束之后(括号里面的内容已经处理完成了)</span></span><br><span class="line">        <span class="comment"># 剩下最后一步的运算</span></span><br><span class="line">        <span class="comment"># 1.拼接最后一个数字</span></span><br><span class="line">        <span class="keyword">if</span> pre!=<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            number.append(<span class="built_in">int</span>(pre))</span><br><span class="line">        <span class="keyword">if</span> operate <span class="keyword">and</span> operate[-<span class="number">1</span>]==<span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            operate[-<span class="number">1</span>]=<span class="string">&#x27;+&#x27;</span></span><br><span class="line">            number[-<span class="number">1</span>]=(-<span class="number">1</span>)*number[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 2.进行最后一步的运算</span></span><br><span class="line">        <span class="keyword">while</span> operate:</span><br><span class="line">            op=operate.pop()</span><br><span class="line">            num2=number.pop()</span><br><span class="line">            num1=number.pop()</span><br><span class="line">            num3=self.cal(num1,num2,op)</span><br><span class="line">            number.append(num3)</span><br><span class="line">        <span class="keyword">return</span> number[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 写出无括号，纯加减乘的函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params">self,num1,num2,op</span>):</span><br><span class="line">        <span class="keyword">if</span> op==<span class="string">&quot;+&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1+num2</span><br><span class="line">        <span class="keyword">if</span> op==<span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1*num2</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 剩下的运算</span></span><br><span class="line">        <span class="keyword">while</span> operate:</span><br><span class="line">            op = operate.pop()</span><br><span class="line">            num2 = number.pop()</span><br><span class="line">            num1 = number.pop()</span><br><span class="line">            num3 = self.cal(num1, num2, op)</span><br><span class="line">            number.append(num3)</span><br><span class="line">        <span class="keyword">return</span> number[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params">self, num1, num2, op</span>):</span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 + num2</span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 * num2</span><br><span class="line"><span class="comment"># 头文件</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 输入一个特定的需要求解的数组</span></span><br><span class="line">    s= <span class="string">&quot;(2*(3-4))*5&quot;</span></span><br><span class="line">    res = Solution().solve(s)</span><br><span class="line">    <span class="comment">#print(res)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;  输出 =&gt; &quot;</span> ,res)</span><br></pre></td></tr></table></figure>
当然这里引申一下关于eval()函数的用法：用来执行一个字符串表达式，并返回表达式的值<br>eval(expression[,globals[,locals]]).</li>
</ol>
<h1 id="BM65-最长公共子序列"><a href="#BM65-最长公共子序列" class="headerlink" title="BM65-最长公共子序列"></a>BM65-最长公共子序列</h1><p>题目的主要信息：</p>
<ol>
<li>找到两个字符串的最长公共子序列</li>
<li>仅存在一个最长的公共子序列，不需要去重</li>
<li>没有找到的时候，返回-1，需要变换（这里是一个隐藏的坑）</li>
</ol>
<p>思路：先得到最长公共子序列的长度（获取长度的思路已经知晓），然后根据这个长度来获取这个子序列（这里才是本道题有一个重点的部分，用到了栈的弹出的小知识，也是一个很关键的点，如果不是做题的话估计自己也很难想到这样的方法。需要对栈进行活学活用，而且要能够快速的反应过来，确实很考验代码和逻辑的思维能力！！！！！！）<br>在构造表的同时，用一个二维矩阵记录上面状态转移时选择的方向，用1表示来自左上方，用2表示来至左边，用3表示来自上边。<br>获取这个序列的时候，根据从最后一位开始，根据记录方向，不断地递归往前组装字符，只有来自左上的时候才添加本级字符（<strong>这种情况是动态规划中两个字符相等的情况，字符相等的时候才可以用</strong>）<br>这里看得到一个非常好的练习的线上的表格，帮自己完完全全的梳理了一下这个过程，一下子茅塞顿开。<br>链接如下：<a target="_blank" rel="noopener" href="https://alchemist-al.com/algorithms/longest-common-subsequence">https://alchemist-al.com/algorithms/longest-common-subsequence</a><br><img src="https://runnerxr.github.io//post-images/1652192059144.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LCS</span>(<span class="params">self , s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 首先采用二维dp来解题</span></span><br><span class="line">        <span class="comment"># dp[i][j]表示s1中前i个字符和s2中前j个字符的最长公公共子序列</span></span><br><span class="line">        <span class="comment"># 当两个字符串最后一个字符是相同的时候</span></span><br><span class="line">        <span class="comment"># dp[i][j]=dp[i-1][j-1]+1</span></span><br><span class="line">        <span class="comment"># 当两个字符串最后一个字符不是相同的时候，看到底是由s1延申过来，还是由s2延申过程</span></span><br><span class="line">        <span class="comment"># dp[i][j-1]:表示s1中前i个字符与s2中前j-1个字符的最长公共给子序列</span></span><br><span class="line">        <span class="comment"># dp[i-1][j]表示s1中的前i-1个字符与s2中前j个字符的最长公共子序列</span></span><br><span class="line">        m,n=<span class="built_in">len</span>(s1),<span class="built_in">len</span>(s2)</span><br><span class="line">        dp=[[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 初始条件</span></span><br><span class="line">        <span class="comment"># 当s1或者s2为空字符串的时候,最长公共子串均为0</span></span><br><span class="line">        <span class="keyword">if</span> m==<span class="number">0</span> <span class="keyword">or</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;-1&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 判断当前遍历的最后一个字符是否相</span></span><br><span class="line">                <span class="keyword">if</span> s1[i-<span class="number">1</span>]==s2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                <span class="comment"># 当最后一个字符不相等的时候</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j])</span><br><span class="line">        <span class="comment"># 找到最大长度之后，还要把对应的值给输出来</span></span><br><span class="line">        <span class="comment"># return dp[m][n]</span></span><br><span class="line">        <span class="comment">#print(dp)</span></span><br><span class="line">        <span class="comment"># # 从动态规划数组的末尾开始</span></span><br><span class="line">        i,j=m,n</span><br><span class="line">        <span class="comment"># 构建一个临时的栈，用来从后向前储存相同的字符</span></span><br><span class="line">        temp=[]</span><br><span class="line">        <span class="keyword">while</span> dp[i][j] !=<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 来自左方向</span></span><br><span class="line">            <span class="keyword">if</span> dp[i][j]==dp[i-<span class="number">1</span>][j]:</span><br><span class="line">                i=i-<span class="number">1</span></span><br><span class="line">            <span class="comment"># 来自上方向</span></span><br><span class="line">            <span class="keyword">elif</span> dp[i][j]==dp[i][j-<span class="number">1</span>]:</span><br><span class="line">                j= j-<span class="number">1</span></span><br><span class="line">            <span class="comment"># 来自左上方</span></span><br><span class="line">            <span class="keyword">elif</span> dp[i][j]&gt;dp[i-<span class="number">1</span>][j-<span class="number">1</span>]:</span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 只有左上方才是字符相等的情况，入栈，逆序使用</span></span><br><span class="line">                temp.append(s1[i])</span><br><span class="line">        <span class="comment"># 循环结束之后，进行子序列的拼接</span></span><br><span class="line">        <span class="comment"># print(temp)</span></span><br><span class="line">        res=<span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(temp)!=<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 将temp中的元素不断地弹出并加入到res字符串中</span></span><br><span class="line">            res+=temp.pop()</span><br><span class="line">        <span class="comment">#如果两个完全不同，返回字符串为空，需要改为-1</span></span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> res==<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;-1&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="BM66-最长公共子串"><a href="#BM66-最长公共子串" class="headerlink" title="BM66- 最长公共子串"></a>BM66- 最长公共子串</h1><p>注意审题：最长的公共子串，不是最长的公共子序列，子序列可以不是连续的，但是子串一定是连续的。（这里的理解对于做题来说是十分的关键的，一道题能够读懂也十分重要的）<br>看到题解的时候有一个枚举的思路，对于自己的思维锻炼很有帮助，而且动态规划就是从枚举的思路上发展而来的，需要考验的是自己的能够有枚举的思路，而且还能由枚举来想到用动态规划的思路。（枚举是思维的核心所在！！！！）<br>参考链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/f33f5adc55f444baa0e0ca87ad8a6aac?tpId=295&amp;tqId=991150&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=/exam/oj">https://www.nowcoder.com/practice/f33f5adc55f444baa0e0ca87ad8a6aac?tpId=295&amp;tqId=991150&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj</a><br>枚举所有的子串进行比较，不用完全枚举的形式，尝试做一点改良</p>
<ol>
<li>遍历两个字符串的所有字符串作为起始</li>
<li>同时开始检查字符是否相等，相等的话就不断地后移，增加子串地长度，<strong>如果不说明以这两个为起点地子串截至了，不会再有了</strong>。(这里也是同动态规划地思想一致的)</li>
<li>后续比较长度维护最大值即可。<br><img src="https://runnerxr.github.io//post-images/1652175614590.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写代码的核心思维思维</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LCS</span>(<span class="params">self , str1: <span class="built_in">str</span>, str2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment">#让str1为较长的字符串</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(str1) &lt; <span class="built_in">len</span>(str2): </span><br><span class="line">            str1, str2 = str2, str1</span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="comment">#遍历str1的长度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str1)): </span><br><span class="line">            <span class="comment">#查找是否存在</span></span><br><span class="line">            <span class="keyword">if</span> str1[i - max_len : i + <span class="number">1</span>] <span class="keyword">in</span> str2: </span><br><span class="line">                res = str1[i - max_len : i + <span class="number">1</span>]</span><br><span class="line">                max_len += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
这题和最长的公共子序列也有一定的联系：比如构建dp数组的含义，dp数组的长度以及大小（这种题型要形成自己的思考定式下次碰到的时候就可以直接写了）<br>定义dp[i][j]表示字符串str1中第i个字符和str2种第j个字符为最后一个元素所构成的最长公共子串。如果要求dp[i][j]，也就是str1的第i个字符和str2的第j个字符为最后一个元素所构成的最长公共子串，我们首先需要判断这两个字符是否相等。(相当于是递推公式)</li>
<li>如果不相等，那么他们就不能构成公共子串，也就是dp[i][j]&#x3D;0</li>
<li>如果相等的话，我们还需要计算前面相等字符的个数：即dp[i-1][j-1]<br><img src="https://runnerxr.github.io//post-images/1652191419226.png"><br>自己也要表格罗列了这样的一个过程，帮助自己去理解。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#很遗憾，采用动态规划的思路，用例并不能全盘的通过</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LCS</span>(<span class="params">self , str1: <span class="built_in">str</span>, str2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 设置二维dp数组,dp[i][j]表示在str1的前i个字符，str2的前j个字符中最长公共子串的个数</span></span><br><span class="line">        <span class="comment"># 当其中某个字符串长度为0的时候一定是空串</span></span><br><span class="line">        m,n=<span class="built_in">len</span>(str1),<span class="built_in">len</span>(str2)</span><br><span class="line">        maxlengh=<span class="number">0</span></span><br><span class="line">        dp=[[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 分别在两个字符串中进行遍历</span></span><br><span class="line">        <span class="comment"># 目的是为了找到最长公共子串的长度</span></span><br><span class="line">        <span class="comment"># 其中公共子串是需要连续的</span></span><br><span class="line">        <span class="comment"># i在第一个字符串中进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># j在第二个字符串中进行遍历</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 如果两个字符串当前遍历的最后一个字符相等,就增加公共子串的长度</span></span><br><span class="line">                <span class="keyword">if</span> str1[i-<span class="number">1</span>]==str2[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 更新，找到它斜上角的值+1</span></span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果不相等的话，需要将dp[i][j]置为0，一旦不等的时候就会断开</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=<span class="number">0</span></span><br><span class="line">                <span class="comment"># 判断结束之后，用一个数组来接受最大的长度</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j]&gt;maxlengh:</span><br><span class="line">                    <span class="comment"># 更新最大值</span></span><br><span class="line">                    maxlengh=dp[i][j]</span><br><span class="line">                    <span class="comment"># 此时pos记录的就是正常字符串的下标（从0开始的）</span></span><br><span class="line">                    pos=i-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 最后通过对任意一个字符串进行切分来返回最长的公共子串</span></span><br><span class="line">        <span class="keyword">return</span> str1[pos-maxlengh+<span class="number">1</span>:pos+<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以下为整理的牛客网上华为的一些机试的题目，希望认认真真的准备，50道题全方位的掌握是必须的。</p>
<h1 id="HJ6-质数因子"><a href="#HJ6-质数因子" class="headerlink" title="HJ6 质数因子"></a>HJ6 质数因子</h1><p>自己也是没有一点做题的思路，虽然理解质因数的概念，但是就是不能够用代码来实现，弱鸡实锤实锤。<br>这道题在之前的练习题目里面是有原型的，只是自己没有注意。<br>质因数：一个正整数的约数，并且该数还属于是质数的数字<br>附上思路：<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 理解好了之后，将代码附上去</span></span><br><span class="line"> n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"> <span class="comment"># 当n被所有不大于根号下n的质因数整除后，要么余下1，要么余下2，</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span> + <span class="number">1</span>)):</span><br><span class="line">    <span class="comment"># 如果n能够整除i</span></span><br><span class="line">    <span class="keyword">while</span> n % i == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 第一个能被整除的一定是最小的质因数</span></span><br><span class="line">        <span class="comment"># 得到的每一个数都是n的质因数（重复的值也会被列出来）</span></span><br><span class="line">        <span class="built_in">print</span>(i, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="comment"># 把n的值更新,n的值n//i的整数部分，确保没有i这个质因数</span></span><br><span class="line">        n = n // i</span><br><span class="line"><span class="comment"># 如果发现n还是大于2，则说明在上一次分解的n中，while循环一次都没跑，直接输出n为素数</span></span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure></p>
<h1 id="J8-合并表记录"><a href="#J8-合并表记录" class="headerlink" title="J8 合并表记录"></a>J8 合并表记录</h1><p>没有比较好的做题思路，做了一半放着了（再做的时候，给自己一点时间再做一遍，先不慌看题解）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入键值对的个数</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">temp=[]</span><br><span class="line"><span class="comment"># 将所有的键值对按照数组的形式加入到temp列表中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    a =<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">    <span class="comment">#print(a)</span></span><br><span class="line">    temp.append(a)</span><br><span class="line"><span class="comment"># 建立一个哈希表</span></span><br><span class="line">hashmap = <span class="built_in">dict</span>()</span><br><span class="line"><span class="comment"># 对数组进行遍历，找出索引相同的</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="comment"># 如果列表的索引i的第一个值不在哈希表里面</span></span><br><span class="line">    <span class="keyword">if</span> temp[i][<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">        <span class="comment"># 把值添加进去</span></span><br><span class="line">        hashmap[temp[i][<span class="number">0</span>]]=temp[i][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        hashmap[temp[i][<span class="number">0</span>]] +=temp[i][<span class="number">1</span>]</span><br><span class="line"><span class="comment">#print(hashmap)</span></span><br><span class="line"><span class="comment"># 对字典按照索引值进行排序</span></span><br><span class="line"><span class="comment">#hashmap.sort(key = lambda x:[x]) </span></span><br><span class="line"><span class="comment"># 按照字典的键和值份行输出</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">sorted</span>(hashmap.keys()):</span><br><span class="line">    <span class="built_in">print</span>(k,hashmap[k])   </span><br></pre></td></tr></table></figure>
<p>使用哈希表的时候可以做适当的简化操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入键值对的个数</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 建立一个哈希表</span></span><br><span class="line">hashmap = <span class="built_in">dict</span>()</span><br><span class="line"><span class="comment"># 将所有的键值对按照数组的形式加入到temp列表中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    key,value =<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">    <span class="comment"># 找出索引相同的</span></span><br><span class="line">    <span class="comment"># 如果key值不在当前的字典中，key和value加进去</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">        <span class="comment"># 把值添加进去</span></span><br><span class="line">        hashmap[key]=value</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        hashmap[key] +=value</span><br><span class="line"><span class="comment">#print(hashmap)</span></span><br><span class="line"><span class="comment"># 对字典按照索引值进行排序，并输出（这种方法是最简单的）</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">sorted</span>(hashmap.keys()):</span><br><span class="line">    <span class="built_in">print</span>(k,hashmap[k])</span><br></pre></td></tr></table></figure>
<p>对于排序后输出，可以将字典转换成列表再输出的话（这样的方法有点太繁琐了，上面的两行代码就可以解决掉）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">hashmap = &#123;<span class="number">8</span>: <span class="number">46828</span>, <span class="number">24</span>: <span class="number">47153</span>, <span class="number">3</span>: <span class="number">93735</span>, <span class="number">13</span>: <span class="number">72600</span>, <span class="number">4</span>: <span class="number">44422</span>&#125;</span><br><span class="line">dictlist=[]</span><br><span class="line"><span class="keyword">for</span> keys, value <span class="keyword">in</span> hashmap.items():</span><br><span class="line">    temp = (keys,value)</span><br><span class="line">    dictlist.append(temp)</span><br><span class="line">dictlist.sort(key = <span class="keyword">lambda</span> x:x[<span class="number">0</span>] )</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dictlist)):</span><br><span class="line">    <span class="comment"># print(dictlist[i][0],end=&quot; &quot;)</span></span><br><span class="line">    <span class="comment"># print(dictlist[i][1])</span></span><br><span class="line">    index =dictlist[i][<span class="number">0</span>]</span><br><span class="line">    value =dictlist[i][<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(index)+ <span class="string">&quot; &quot;</span> +<span class="built_in">str</span>(value))</span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># 3 93735</span></span><br><span class="line"><span class="comment"># 4 44422</span></span><br><span class="line"><span class="comment"># 8 46828</span></span><br><span class="line"><span class="comment"># 13 72600</span></span><br><span class="line"><span class="comment"># 24 47153</span></span><br></pre></td></tr></table></figure>
<p>转化为列表再排序的过程有一个简便的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hashmap = &#123;<span class="number">8</span>: <span class="number">46828</span>, <span class="number">24</span>: <span class="number">47153</span>, <span class="number">3</span>: <span class="number">93735</span>, <span class="number">13</span>: <span class="number">72600</span>, <span class="number">4</span>: <span class="number">44422</span>&#125;</span><br><span class="line"><span class="comment"># 直接借助sorted()函数进行排序，排序后会转换成一个列表</span></span><br><span class="line"><span class="comment"># sorted(iterable, key=None,reverse=False)</span></span><br><span class="line">lis1=<span class="built_in">sorted</span>(hashmap.items(),key=<span class="keyword">lambda</span> d:d[<span class="number">0</span>]) <span class="comment">#按键来排序</span></span><br><span class="line"><span class="built_in">print</span>(lis1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lis1)):</span><br><span class="line">    <span class="built_in">print</span>(lis1[i][<span class="number">0</span>], end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(lis1[i][<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># [(3, 93735), (4, 44422), (8, 46828), (13, 72600), (24, 47153)]</span></span><br><span class="line"><span class="comment"># 3 93735</span></span><br><span class="line"><span class="comment"># 4 44422</span></span><br><span class="line"><span class="comment"># 8 46828</span></span><br><span class="line"><span class="comment"># 13 72600</span></span><br><span class="line"><span class="comment"># 24 47153</span></span><br></pre></td></tr></table></figure>

<h1 id="HJ15-求int型正整数在内存中存储时1的个数"><a href="#HJ15-求int型正整数在内存中存储时1的个数" class="headerlink" title="HJ15 求int型正整数在内存中存储时1的个数"></a>HJ15 求int型正整数在内存中存储时1的个数</h1><p>题目自己都没有读懂？？？，不好开展下去,回顾的时候再把题目好好的领悟一下，不懂的先记载在这里</p>
<ol>
<li>先把数字转化为二进制</li>
<li>然后数二进制中1的个数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：这种方法相对来说比较的粗暴</span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">b = <span class="built_in">bin</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b.count(<span class="string">&quot;1&quot;</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法二：采用位运算与：&amp;</span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">count =<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> a !=<span class="number">0</span>:</span><br><span class="line">   <span class="comment"># n&amp;(n-1)d的操作是将n的二进制中最低位的1变成0的过程</span></span><br><span class="line">   <span class="comment"># 不断的进行这样的操作之后，就将a最低位的1不断地变为0，直到将所有的1都变为0，每次操作记录一次</span></span><br><span class="line">    a &amp;=a-<span class="number">1</span></span><br><span class="line">    count =+<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="HJ16-购物单"><a href="#HJ16-购物单" class="headerlink" title="HJ16 购物单"></a>HJ16 购物单</h1><p>需要用到动态规划的思路<br>把题目先读懂：（很关键！！！！），题解已经看了几遍了，还是不能够抓住其中的核心问题</p>
<ol>
<li>要买附件，必须买附件所属的主件，每件物品只能购买一次</li>
<li>每个主件可以有0、1、2个附件</li>
<li>每件物品的价格是10的整数倍，并且只有N元预算</li>
<li>满意度的概念：物品价格*重要度再加和</li>
<li>最后的要求：要计算最大的满意度的问题<br>结合0-1背包问题，做详细的分析后用代码完成，这道题必须做3遍（<strong>3遍代码实现！！！！！</strong>）<br>对于给定例子：物品的个数N&#x3D;3<br>考虑每个物品要考虑每种可能出现的情况：不一定每种情况都要考虑，只有当附件存在的时候才有对应的情况（重点和难点就是处理附件的地方）</li>
<li>主件</li>
<li>主件 + 附件1</li>
<li>主件 + 附件2 </li>
<li>主件 + 附件1 + 附件2</li>
</ol>
<p>将所得的数据分为两个表：</p>
<ol>
<li>单价价格表（相当于背包问题的重量，限制我们的总金额）</li>
<li>价值表(每个主、附件对应的价值，我们要求的是让他们和最大的值)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这种只是自己一开始就用别人的来理解，不一定是最好的</span></span><br><span class="line"><span class="keyword">while</span>  <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 最大金额total，物品数量k</span></span><br><span class="line">        total , k = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">        <span class="comment"># print(total,k)</span></span><br><span class="line">        <span class="comment"># 单价</span></span><br><span class="line">        W=&#123;&#125;</span><br><span class="line">        <span class="comment"># 单价*重要程度=价值(满意度)</span></span><br><span class="line">        V=&#123;&#125;</span><br><span class="line">        <span class="comment"># 因为价格是10的倍数，为了方便运算，价格/10，可以减少循环的次数</span></span><br><span class="line">        total = <span class="built_in">int</span>(total/<span class="number">10</span>)</span><br><span class="line">        <span class="comment"># print(total)</span></span><br><span class="line">        <span class="comment"># 主件个数</span></span><br><span class="line">        main_key = []</span><br><span class="line">        <span class="comment"># 构造字典</span></span><br><span class="line">        <span class="comment"># 对于每一个物品都有价值和相应的满意度,做了一个初始化，之所以用1~k，只是为了表示k件物品与数字对应，方便调试，</span></span><br><span class="line">        <span class="comment"># 同时也牵扯到一个编号的问题，必须要这样遍历然后创建</span></span><br><span class="line">        <span class="comment"># 因为最多有两个附件，所以对于每一个物品编号来说，是三列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">            W[i] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">            V[i] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#print(W)</span></span><br><span class="line">        <span class="comment">#print(V)</span></span><br><span class="line">        <span class="comment"># 将物品对应的三个属性分别录入进去</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="comment"># 单价，重要程度，类别</span></span><br><span class="line">            v,p,q= <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">            <span class="comment">#print(v,p,q)</span></span><br><span class="line">            <span class="comment"># 如果没有附件</span></span><br><span class="line">            <span class="keyword">if</span> q ==<span class="number">0</span>:</span><br><span class="line">                W[i+<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">int</span>(v/<span class="number">10</span>)</span><br><span class="line">                V[i+<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">int</span>(v*p/<span class="number">10</span>)</span><br><span class="line">                main_key.append(i+<span class="number">1</span>)</span><br><span class="line">                <span class="comment">#print(W)</span></span><br><span class="line">                <span class="comment">#print(V)</span></span><br><span class="line">                <span class="comment">#print(main_key)</span></span><br><span class="line">            <span class="comment"># 存在附件的时候</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># </span></span><br><span class="line">                <span class="keyword">if</span> W[q][<span class="number">1</span>]==<span class="number">0</span>:<span class="comment"># 附件</span></span><br><span class="line">                    W[q][<span class="number">1</span>]=<span class="built_in">int</span>(v/<span class="number">10</span>)  <span class="comment"># 第一个附件</span></span><br><span class="line">                    V[q][<span class="number">1</span>]=<span class="built_in">int</span>(v*p/<span class="number">10</span>)</span><br><span class="line">                    <span class="comment">#print(W)</span></span><br><span class="line">                    <span class="comment">#print(V)</span></span><br><span class="line">                <span class="comment"># </span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    W[q][<span class="number">2</span>]= <span class="built_in">int</span>(v/<span class="number">10</span>)  <span class="comment"># 第二个附件</span></span><br><span class="line">                    V[q][<span class="number">2</span>]= <span class="built_in">int</span>(v*p/<span class="number">10</span>)</span><br><span class="line">                    <span class="comment">#print(W)</span></span><br><span class="line">                    <span class="comment">#print(V)</span></span><br><span class="line">        <span class="comment"># 到这里输出结果，证明自己创建的两个表是正确的。</span></span><br><span class="line">        <span class="comment">#print(W)</span></span><br><span class="line">        <span class="comment">#print(V)</span></span><br><span class="line">        <span class="comment"># 新建两个数组,用于存存放</span></span><br><span class="line">        W_lst = []</span><br><span class="line">        V_lst = []</span><br><span class="line">        <span class="comment"># 在W字典中遍历键</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> W.keys():</span><br><span class="line">            <span class="comment"># key是在main_key里面的</span></span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> main_key:</span><br><span class="line">                W_lst.append(W[key])</span><br><span class="line">                V_lst.append(V[key])</span><br><span class="line">        <span class="comment">#print(W_lst)</span></span><br><span class="line">        <span class="comment">#print(V_lst)</span></span><br><span class="line">        m = <span class="built_in">len</span>(W_lst)</span><br><span class="line">        <span class="comment"># 构造一个二维数组</span></span><br><span class="line">        <span class="comment"># 开始转化成为0-1背包问题</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*(total+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):  <span class="comment"># 每几件物品</span></span><br><span class="line">            w1 = W_lst[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">            w2 = W_lst[i-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">            w3 = W_lst[i-<span class="number">1</span>][<span class="number">2</span>]</span><br><span class="line">            v1 = V_lst[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">            v2 = V_lst[i-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">            v3 = V_lst[i-<span class="number">1</span>][<span class="number">2</span>] </span><br><span class="line">            <span class="comment"># 这里对j的遍历很关键</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(total+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 1.不放入的情况</span></span><br><span class="line">                <span class="comment"># 当前价格j不能容下第i个主件时,价值为上一个物品的对应价格的价值</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="comment"># 2. 放入一个主件</span></span><br><span class="line">                <span class="comment"># 当前价格j可以容下第i个主件时,比较（上一个物品对应价格的价值）</span></span><br><span class="line">                <span class="keyword">if</span> j -w1&gt;=<span class="number">0</span>:  </span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j],dp[i-<span class="number">1</span>][j-w1] +v1)</span><br><span class="line">                <span class="comment"># 1个主件+1附件</span></span><br><span class="line">                <span class="comment"># 在确定主件可容纳，并做相应计算之后,判断附件的容纳情况，如果主件都没有办法容纳，则附件必定不可容纳</span></span><br><span class="line">                <span class="keyword">if</span> j - w1-w2 &gt;=<span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 当可以容下第i个主件和此主件的第1个附件时，此时需要在比大小时加入当前最优，保证添加附件的结果不会反而更小</span></span><br><span class="line">                    <span class="comment"># 比较（当前价格对应上一物品的价值）与（主键价值+附件1价值+上一物品在价格（j-主键价格-附件1价格）时对应的价值）</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j],dp[i-<span class="number">1</span>][j-w1-w2] +v1+v2)</span><br><span class="line">                <span class="comment"># 一个主件+附件2</span></span><br><span class="line">                <span class="keyword">if</span> j - w1 -w3 &gt;=<span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 可以容下第i个主件和此主件的第2个附件，此时也需要在比大小时加入当前最优，保证添加附件的结果不会反而更小</span></span><br><span class="line">                    <span class="comment"># 比较（当前价格对应上一物品的价值）与（主键价值+附件2价值+上一物品在价格（j-主键价格-附件2价格）时对应的价值）</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j],dp[i-<span class="number">1</span>][j-w1-w3] + v1 + v3)</span><br><span class="line">                <span class="comment"># 一个主件 + 附件1+ 附件2</span></span><br><span class="line">                <span class="comment"># 根据3件物品价格之和必然大于等于2件物品的规则，只有在能容纳主件和附件2时，才有判断全部容纳可能性的必要</span></span><br><span class="line">                <span class="keyword">if</span> j - w1 - w2 - w3 &gt;=<span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 当判断通过，则判断当前值与上物品计算当前价格价值与当前3物品情况价值中最大值，同时还要比较目前最优值</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j],dp[i-<span class="number">1</span>][j-w1-w2-w3] + v1 + v2 +v3)</span><br><span class="line">        <span class="comment"># 打印最后的结果</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">int</span>(dp[m][total]*<span class="number">10</span>))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
自己动手实操的时候就发现问题所在了<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果不对数据做先除以10的操作，会有一部分数据通不过，因为循环过大</span></span><br><span class="line"><span class="comment"># 输入总钱数N，物品的总数m</span></span><br><span class="line">N,m=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line"><span class="comment"># 新建价格和价值的二维数组,便于后期存放数据</span></span><br><span class="line"><span class="comment"># 对于每一个二维数组，总共有m行，对于每一行都有3列，分别表示主件，附件1、附件2</span></span><br><span class="line">W=[[<span class="number">0</span>]*<span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">V=[[<span class="number">0</span>]*<span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"><span class="comment"># 接下来将数据依次的存放入两个二维数组中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    <span class="comment"># 输入m行的基本数据,其中每一行包含三项数据：物品价格、物品的满意度，是主件/附件(如果是附件会注明所属主件所在的物品编号)</span></span><br><span class="line">    v,p,q=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    <span class="comment"># 如果发现q==0，则说明当前商品是一个存粹的主件没有附件</span></span><br><span class="line">    <span class="keyword">if</span> q==<span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 将价格放入表中</span></span><br><span class="line">        W[i][<span class="number">0</span>] =v</span><br><span class="line">        <span class="comment"># 将价值放入表中</span></span><br><span class="line">        V[i][<span class="number">0</span>] =v*p</span><br><span class="line">    <span class="comment"># 此时q!=0,说明存在附件的情况</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 因为存入数据时候是一个个存放的,对于有附件的情况，这个时候需要再看相应所属的主件所在的物品编号</span></span><br><span class="line">        <span class="comment"># 这里有一个坑，主件的编号是从1~m的范围，但是数组的索引是从0~m-1这个范围</span></span><br><span class="line">        <span class="comment"># 也即q在1-m这个范围（含m）,数组的索引在0~m-1这个范围（含m-1）</span></span><br><span class="line">        <span class="comment"># W[q-1][1]==0表明：这个附件是附件1，并且是从属于第q个物品编号</span></span><br><span class="line">        <span class="keyword">if</span> W[q-<span class="number">1</span>][<span class="number">1</span>]==<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 存入数据</span></span><br><span class="line">            W[q-<span class="number">1</span>][<span class="number">1</span>]=v</span><br><span class="line">            V[q-<span class="number">1</span>][<span class="number">1</span>]=v*p</span><br><span class="line">        <span class="comment"># 表明此时是：W[q-1][2]==0，是有第二个附件的情况</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 存入第二个附件数据放入两张表中</span></span><br><span class="line">            W[q-<span class="number">1</span>][<span class="number">2</span>]=v</span><br><span class="line">            V[q-<span class="number">1</span>][<span class="number">2</span>]=v*p</span><br><span class="line"><span class="comment"># 检验数据存放是否正确</span></span><br><span class="line"><span class="comment">#print(W)</span></span><br><span class="line"><span class="comment">#print(V)</span></span><br><span class="line"><span class="comment"># 新建两个数组，用来存放剔除之后的数据</span></span><br><span class="line">lst_W,lst_V=[],[]</span><br><span class="line"><span class="comment"># 把表中数据为0的给剔除掉：0的数据表示只有附件的的情况，不会单独存放的</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    <span class="keyword">if</span> W[i] !=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]:</span><br><span class="line">        lst_W.append(W[i])</span><br><span class="line">        lst_V.append(V[i])</span><br><span class="line"><span class="comment">#print(lst_W)</span></span><br><span class="line"><span class="comment">#print(lst_V)</span></span><br><span class="line"><span class="comment"># 接下就是转化为0-1背包的问题</span></span><br><span class="line"><span class="comment"># 在总钱数满足的情况下，所能够得到的最大的价值</span></span><br><span class="line"><span class="comment"># 由于上面已经对数据做了处理</span></span><br><span class="line"><span class="comment"># 处理之后数组的长度</span></span><br><span class="line"><span class="comment"># 然后用到动态规划的思路开始选商品</span></span><br><span class="line"><span class="comment"># 商品的件数为i，李强的总钱数为j</span></span><br><span class="line"><span class="comment"># dp[i][j]表示：在能够买前i件商品的时候所能获得的最大满意度</span></span><br><span class="line"><span class="comment"># 如果买不起第i件商品，则dp[i][j]=dp[i-1][j]</span></span><br><span class="line"><span class="comment"># 如果能够买得起商品的化，可以分两种情况就是讨论，然后取两者的最大值</span></span><br><span class="line"><span class="comment"># 情况一：不买第i件商品，此时dp[i][j]=dp[i-1][j]</span></span><br><span class="line"><span class="comment"># 情况二：买第i件商品，此时需要预留出买第i件商品的钱出来，用买完第i件物品之后的钱再去卖其他的物品</span></span><br><span class="line">length=<span class="built_in">len</span>(lst_W)</span><br><span class="line"><span class="comment"># 建立dp数组应该比较熟悉</span></span><br><span class="line">dp=[[<span class="number">0</span>]*(N+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line"><span class="comment"># print(dp)</span></span><br><span class="line"><span class="comment"># 这里提前对数据做一个预处理</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">    <span class="comment"># 这里对j的取值很讲究，j最大是可以取到N值的</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 边界条件的处理</span></span><br><span class="line">        <span class="comment"># 如果只有0件物品，那么再多的钱也没用。</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 这里提前对数据做一个预处理,提取每种情况单独的价格和价值</span></span><br><span class="line">        w1=lst_W[i][<span class="number">0</span>]</span><br><span class="line">        v1=lst_V[i][<span class="number">0</span>]</span><br><span class="line">        w2=lst_W[i][<span class="number">1</span>]</span><br><span class="line">        v2=lst_V[i][<span class="number">1</span>]</span><br><span class="line">        w3=lst_W[i][<span class="number">2</span>]</span><br><span class="line">        v3=lst_V[i][<span class="number">2</span>]</span><br><span class="line"><span class="comment">#         if j&lt;w1:</span></span><br><span class="line"><span class="comment">#             dp[i][j]=dp[i-1][j]</span></span><br><span class="line">        dp[i][j]=dp[i-<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">if</span> j&gt;=w1:</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i][j], dp[i-<span class="number">1</span>][j-w1] +v1)</span><br><span class="line">        <span class="keyword">if</span> j&gt;=w1+w2:</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i][j], dp[i-<span class="number">1</span>][j-w1-w2] +v1+v2)</span><br><span class="line">        <span class="keyword">if</span> j&gt;=w1+w3:</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i][j], dp[i-<span class="number">1</span>][j-w1-w3] +v1+v3)</span><br><span class="line">        <span class="keyword">if</span> j&gt;=w1+w2+w3:</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i][j], dp[i-<span class="number">1</span>][j-w1-w2-w3] +v1+v2+v3)</span><br><span class="line"><span class="comment"># 打印的时候，也是最大可以取到N值</span></span><br><span class="line"><span class="built_in">print</span>(dp[length-<span class="number">1</span>][N])</span><br><span class="line">```python</span><br><span class="line"><span class="comment">#当对输入的价格做除以10的操作后，最后提交能够通过了，但是要要注意在数据的处理上，因为N/10之后变成了一个浮点型，需要将其转换为整型</span></span><br><span class="line"><span class="comment">#同时对于给定的总的钱数也要做转换为整型的操作，这些都是很容易忽略的地方</span></span><br><span class="line"><span class="comment"># 以下为改进过之后的</span></span><br><span class="line"><span class="comment"># 输入总钱数N，物品的总数m</span></span><br><span class="line">N,m=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line"><span class="comment"># 新建价格和价值的二维数组,便于后期存放数据</span></span><br><span class="line">N=<span class="built_in">int</span>(N/<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 对于每一个二维数组，总共有m行，对于每一行都有3列，分别表示主件，附件1、附件2</span></span><br><span class="line">W=[[<span class="number">0</span>]*<span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">V=[[<span class="number">0</span>]*<span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"><span class="comment"># 接下来将数据依次的存放入两个二维数组中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    v,p,q=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">if</span> q==<span class="number">0</span>:</span><br><span class="line">        W[i][<span class="number">0</span>] =<span class="built_in">int</span>(v/<span class="number">10</span>)</span><br><span class="line">        V[i][<span class="number">0</span>] =<span class="built_in">int</span>(v*p/<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> W[q-<span class="number">1</span>][<span class="number">1</span>]==<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 存入数据</span></span><br><span class="line">            W[q-<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">int</span>(v/<span class="number">10</span>)</span><br><span class="line">            V[q-<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">int</span>(v*p/<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            W[q-<span class="number">1</span>][<span class="number">2</span>]=<span class="built_in">int</span>(v/<span class="number">10</span>)</span><br><span class="line">            V[q-<span class="number">1</span>][<span class="number">2</span>]=<span class="built_in">int</span>(v*p/<span class="number">10</span>)</span><br><span class="line">lst_W,lst_V=[],[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    <span class="keyword">if</span> W[i] !=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]:</span><br><span class="line">        lst_W.append(W[i])</span><br><span class="line">        lst_V.append(V[i])</span><br><span class="line">length=<span class="built_in">len</span>(lst_W)</span><br><span class="line">dp=[[<span class="number">0</span>]*(N+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        w1=lst_W[i][<span class="number">0</span>]</span><br><span class="line">        v1=lst_V[i][<span class="number">0</span>]</span><br><span class="line">        w2=lst_W[i][<span class="number">1</span>]</span><br><span class="line">        v2=lst_V[i][<span class="number">1</span>]</span><br><span class="line">        w3=lst_W[i][<span class="number">2</span>]</span><br><span class="line">        v3=lst_V[i][<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        dp[i][j]=dp[i-<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">if</span> j&gt;=w1:</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i][j], dp[i-<span class="number">1</span>][j-w1] +v1)</span><br><span class="line">        <span class="keyword">if</span> j&gt;=w1+w2:</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i][j], dp[i-<span class="number">1</span>][j-w1-w2] +v1+v2)</span><br><span class="line">        <span class="keyword">if</span> j&gt;=w1+w3:</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i][j], dp[i-<span class="number">1</span>][j-w1-w3] +v1+v3)</span><br><span class="line">        <span class="keyword">if</span> j&gt;=w1+w2+w3:</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i][j], dp[i-<span class="number">1</span>][j-w1-w2-w3] +v1+v2+v3)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(dp[length-<span class="number">1</span>][N]*<span class="number">10</span>))</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="HJ18-识别有效的IP地址和掩码并进行分类统计"><a href="#HJ18-识别有效的IP地址和掩码并进行分类统计" class="headerlink" title="HJ18 识别有效的IP地址和掩码并进行分类统计"></a>HJ18 识别有效的IP地址和掩码并进行分类统计</h1><p>（不会做就算了，不再浪费时间）<br>这道题，说实话就是直接没有看懂，题目的意思读了好久，可能是这里面的知识点太杂了，读了几遍都没有怎么领会。<br>什么是IP地址的分类：<br>子网掩码是什么：<br>私网IP和相应的范围：</p>
<h1 id="HJ19-简单错误记录"><a href="#HJ19-简单错误记录" class="headerlink" title="HJ19 简单错误记录"></a>HJ19 简单错误记录</h1><p>做是做出来了，但是做的磕磕巴巴的，自己的问题也很大，有些操作不能立马在短时间里面就能领会，并且很好的实现出来。（也是知识的盲区，值得有时间再次进行回顾一遍，还不能做到特别熟练地地步）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 附上做题的代码，如果有第二种方式，自己也贴上来，共同帮助解题</span></span><br><span class="line"><span class="comment"># 创建一个哈希表</span></span><br><span class="line">hashmap=<span class="built_in">dict</span>()</span><br><span class="line"><span class="comment"># 创建一个可以计数的数组</span></span><br><span class="line">res =[]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 输入一行数据，将文件名和对应的行数转化为数组</span></span><br><span class="line">        <span class="comment"># 按照\\进行分割，并提取最后的一个索引的元素</span></span><br><span class="line">        <span class="comment"># 最后一个索引的元素为我呢见的路径和出现错误代码的行数，用空格进行连接</span></span><br><span class="line">        a = <span class="built_in">input</span>().split(<span class="string">&#x27;\\&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 将a转化为2部分，放入数组b中，第一个为文件名，第二个为代码行数</span></span><br><span class="line">        b = a.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(b[<span class="number">0</span>])&gt;<span class="number">16</span>:</span><br><span class="line">            b[<span class="number">0</span>]=b[<span class="number">0</span>][-<span class="number">16</span>:]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 再次合并成一个新的字符串c</span></span><br><span class="line">        c = b[<span class="number">0</span>] + <span class="string">&quot; &quot;</span> + b[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">            hashmap[c] =<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hashmap[c] +=<span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">keys=[key <span class="keyword">for</span> key <span class="keyword">in</span> hashmap.keys()]</span><br><span class="line">i=<span class="number">0</span></span><br><span class="line">j= <span class="built_in">len</span>(keys)-<span class="number">8</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">if</span> i&gt;=j:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    hashmap.pop(key)</span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line"><span class="comment"># print(hashmap)</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> hashmap.items():</span><br><span class="line">    <span class="built_in">print</span>(key+ <span class="string">&quot; &quot;</span> +<span class="built_in">str</span>(value))</span><br></pre></td></tr></table></figure>

<h1 id="HJ20-密码验证合格程序"><a href="#HJ20-密码验证合格程序" class="headerlink" title="HJ20 密码验证合格程序"></a>HJ20 密码验证合格程序</h1><p>第一遍看到的时候，说实话题目都没有看懂？？？这题也是一样需要花大力气弄懂<br>字串的定义：定义是弄清楚了，但是没有明白长度大于2的不含公共元素的子串是什么意思，如何用代码的语言来解释？？？这些都是之前刷题的时候并没有碰到过的问题。心累呀，刷题也太难受了。</p>
<p>思路一：判断当长度大于8的时候，四种情况中至少有三种（一次判断是否有四种情况，有一种k就增加1，当k大于等于3时满足），设置一个flag判断是否含有长度大于2的相同子串。在这里是否含有数字、大写字母、小写字母是通过找出字符串中的这些字符，存在res中，通过判断res长度来判断是否存在。</p>
<p>看看别人的思路：<br>题目分析：</p>
<ol>
<li>题目给出我们若干条字符串，其含义是我们经常会注册登录所使用的密码</li>
<li>题目对密码格式进行要求<ol>
<li>第一点：密码必须超过8位</li>
<li>第二点：必须有大写字母、小写字母、数字、符号四种中的三种</li>
<li>第三点：密码不能有重复的公共子串，公共子串长度判定为3个字符及以上</li>
</ol>
</li>
<li>我们要输出其是否符合以上条件的判断结果，OK或者NG<br>思路：</li>
<li>对于第一点在，只要判断是否长度合法就可以</li>
<li>对于第二点：准备要给列表分别表示四种情况的出现与否状态<ol>
<li>如果出现了对应的情况，标记其值为1</li>
<li>最后查看是否标记为1的种类满足三种的要求</li>
</ol>
</li>
<li>对于第三点是处理字符串的问题<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = <span class="built_in">input</span>()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">8</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;NG&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">                <span class="comment"># 如果字符是a~z的小写字母</span></span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span> &lt;= i &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">                    l[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果字符是A~Z的大写字母</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="string">&#x27;A&#x27;</span> &lt;= i &lt;= <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">                    l[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果字符是数字的话</span></span><br><span class="line">                <span class="keyword">elif</span> i.isdigit():</span><br><span class="line">                    l[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果列表的总和小于3的话，直接打印NG</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(l) &lt; <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;NG&#x27;</span>)</span><br><span class="line">            <span class="comment"># 当列表的总和大于等于3的时候</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 对s中的数据进行遍历</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-<span class="number">2</span>):</span><br><span class="line">                    <span class="comment"># 只取三位</span></span><br><span class="line">                    x = s[i:i+<span class="number">3</span>]</span><br><span class="line">                    <span class="comment"># 判断取的这三位是否在后面中出现了，如果出现了，直接打印NG,终止循环</span></span><br><span class="line">                    <span class="keyword">if</span> x <span class="keyword">in</span> s[i+<span class="number">3</span>:]:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;NG&#x27;</span>)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 这里用到了for else语句，当循环能够一直执行的时候，打印OK</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;OK&#x27;</span>)      </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="HJ21-简单密码"><a href="#HJ21-简单密码" class="headerlink" title="HJ21 简单密码"></a>HJ21 简单密码</h1><p>这题看似好像能做，等真正来做的时候，又直接卡壳了，题目的意思并没有完全真正理解。导致做的时候就直接懵逼。在整理之后还要自己再用代码实现一遍(这道题要自己完完全全的实现至少两遍)<br>小写字母的处理：特定类型的字母转换成特定的数字（代码如何实现的问题）<br>大写字母的处理：大写变小写，然后往后移动一位（如何转换成代码语言）<br>主要思路：<br>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40667448/article/details/108508386?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/weixin_40667448/article/details/108508386?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a><br>第一部分：给定字符串，将字符串中凡是小写字母。先将其变换成上诉规则中的数字，其余不变<br>第二部分：将第一部分获得的结果，作为第二部分的输入考虑，需要将大写字母部分，进行移位，以及移位之后将其变换成小写字母</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接按照题目的方式进行暴力的解法，思路上没有什么太大的问题，但是执行起来就是比较的慢</span></span><br><span class="line"><span class="comment"># 输入密码</span></span><br><span class="line">a =<span class="built_in">input</span>()</span><br><span class="line">lst1=[]</span><br><span class="line"><span class="comment"># 将字符串分割后加入数组中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    lst1.append(i)</span><br><span class="line"><span class="comment"># print(lst1)</span></span><br><span class="line"><span class="comment"># 转换其中的小写字母</span></span><br><span class="line"><span class="comment"># 在a中进行字符串的遍历</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lst1)):</span><br><span class="line">    <span class="comment"># 如果i是a b c中的某个值</span></span><br><span class="line">    <span class="keyword">if</span> lst1[i] <span class="keyword">in</span> [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>]:</span><br><span class="line">        <span class="comment"># 把这个值直接变成2</span></span><br><span class="line">        lst1[i]=<span class="string">&quot;2&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> lst1[i] <span class="keyword">in</span> [<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>]:</span><br><span class="line">        <span class="comment"># 把字母直接变成3</span></span><br><span class="line">        lst1[i]=<span class="string">&quot;3&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> lst1[i] <span class="keyword">in</span> [<span class="string">&quot;g&quot;</span>,<span class="string">&quot;h&quot;</span>,<span class="string">&quot;i&quot;</span>]:</span><br><span class="line">        <span class="comment"># 把字母直接变成4</span></span><br><span class="line">        lst1[i]=<span class="string">&quot;4&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> lst1[i] <span class="keyword">in</span> [<span class="string">&quot;j&quot;</span>,<span class="string">&quot;k&quot;</span>,<span class="string">&quot;l&quot;</span>]:</span><br><span class="line">        <span class="comment"># 把字母直接变成5</span></span><br><span class="line">        lst1[i]=<span class="string">&quot;5&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> lst1[i] <span class="keyword">in</span> [<span class="string">&quot;m&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;o&quot;</span>]:</span><br><span class="line">        <span class="comment"># 把字母直接变成6</span></span><br><span class="line">        lst1[i]=<span class="string">&quot;6&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> a[i] <span class="keyword">in</span> [<span class="string">&quot;p&quot;</span>,<span class="string">&quot;q&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="string">&quot;s&quot;</span>]:</span><br><span class="line">        <span class="comment"># 把字母直接变成7</span></span><br><span class="line">        lst1[i]=<span class="string">&quot;7&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> lst1[i] <span class="keyword">in</span> [<span class="string">&quot;t&quot;</span>,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;v&quot;</span>]:</span><br><span class="line">        <span class="comment"># 把字母直接变成8</span></span><br><span class="line">        lst1[i]=<span class="string">&quot;8&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> lst1[i] <span class="keyword">in</span> [<span class="string">&quot;w&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;z&quot;</span>]:</span><br><span class="line">        <span class="comment"># 把字母直接变成9</span></span><br><span class="line">        lst1[i]=<span class="string">&quot;9&quot;</span></span><br><span class="line">    <span class="comment"># 如果都不是，继续下一循环</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"><span class="comment"># lst2表示第一步处理好的字符串</span></span><br><span class="line">lst2=<span class="string">&#x27;&#x27;</span>.join(lst1)</span><br><span class="line"><span class="comment"># print(lst2)</span></span><br><span class="line"><span class="comment"># 如果在字符中出现大写字母，如何进行处理的问题</span></span><br><span class="line"><span class="comment"># 将大写字母后移一位，并且变成小写</span></span><br><span class="line">lst3=[]</span><br><span class="line"><span class="comment"># 定义一个用于字符移位的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="comment"># 创建一个空的字符串，用来装处理好的移位的大写字母对应的字符</span></span><br><span class="line">    new_str=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 移动的位数k</span></span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s :</span><br><span class="line">        <span class="keyword">if</span> i &gt;=<span class="string">&#x27;A&#x27;</span> <span class="keyword">and</span> i &lt;=<span class="string">&#x27;Z&#x27;</span>: </span><br><span class="line">            <span class="comment"># 把对应的ASCII移动k位，用移位后的ASCII和&quot;a&quot;的ASCII之差除以26的余数，然后加上&quot;a&quot;的ASCII得到最终的ASCII</span></span><br><span class="line">            i = ((<span class="built_in">ord</span>(i) + k) - <span class="built_in">ord</span>(<span class="string">&quot;A&quot;</span>)) %<span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">            <span class="comment"># 通过chr()函数，将ASCII值转换为单字符</span></span><br><span class="line">            i = <span class="built_in">chr</span>(i)</span><br><span class="line">        <span class="comment"># 把处理好地字符不断地加入到new_str中</span></span><br><span class="line">        new_str +=i</span><br><span class="line">        <span class="comment">#print(new_str)</span></span><br><span class="line">    <span class="keyword">return</span> new_str</span><br><span class="line"><span class="comment"># 对第一步处理后的进行操作</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lst2)):</span><br><span class="line">    <span class="comment"># 对于发现有大写字母的情况，需要将大写字母进行移位操作，借助fn()将每次移位的值加入到目标数组中</span></span><br><span class="line">    <span class="keyword">if</span> lst2[i] <span class="keyword">in</span> [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;Q&#x27;</span>,<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;T&#x27;</span>,<span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;V&#x27;</span>,<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>,<span class="string">&#x27;Z&#x27;</span>]:</span><br><span class="line">        res = fn(lst2[i])</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        lst3.append(res.lower())</span><br><span class="line">    <span class="comment"># 对于是其他字符的情况，直接添加就行</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lst3.append(lst2[i])</span><br><span class="line"><span class="comment"># 重新将第二步处理好的字符串数组用&#x27;&#x27;.join()连成一个新的字符串</span></span><br><span class="line">new_str = <span class="string">&#x27;&#x27;</span>.join(lst3)</span><br><span class="line"><span class="built_in">print</span>(new_str)</span><br></pre></td></tr></table></figure>
<p>这里再补充第二种方式，充分利用了ASCII的相关知识，但是这里还是不是太好理解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">dic = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">26</span>):</span><br><span class="line">    dic += <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)+i)</span><br><span class="line"><span class="comment"># print(dic)</span></span><br><span class="line">ciphertext = <span class="built_in">input</span>()</span><br><span class="line">password = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ciphertext:</span><br><span class="line">    <span class="comment"># 用issupper()用于检测字符串中所有的字母是否都为大写</span></span><br><span class="line">    <span class="keyword">if</span> i.isupper():</span><br><span class="line">        <span class="comment"># 如果包含该字符串的小写，返回相应的索引值</span></span><br><span class="line">        indx = dic.find(i.lower())</span><br><span class="line">        <span class="comment"># 查看索引值是否小于等于24</span></span><br><span class="line">        <span class="keyword">if</span> indx&lt;=<span class="number">24</span>:</span><br><span class="line">            res = dic[indx+<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 如果是最后一个索引，移位后的结果就是&quot;A&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = dic[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 如果所遍历的是由小写字母所组成的，将小写字母分别指向1~9的数字</span></span><br><span class="line">    <span class="keyword">elif</span> i.islower():</span><br><span class="line">        <span class="comment"># 返回小写对饮的索引值</span></span><br><span class="line">        indx = dic.find(i)</span><br><span class="line">        <span class="keyword">if</span> <span class="number">25</span>&gt;indx&gt;=<span class="number">17</span>:</span><br><span class="line">            indx -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> indx == <span class="number">25</span>:</span><br><span class="line">            indx -= <span class="number">2</span></span><br><span class="line">        res = <span class="built_in">str</span>(<span class="built_in">int</span>(indx/<span class="number">3</span>)+<span class="number">2</span>)</span><br><span class="line">        <span class="comment">#print(res)</span></span><br><span class="line">    <span class="comment"># 如果字符既不是小写字母，也不是大写字母，直接进行相应的添加</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res = i</span><br><span class="line">    <span class="comment"># 把经过处理之后的字符加入到预先准备好的空字符串中</span></span><br><span class="line">    password += res</span><br><span class="line"><span class="built_in">print</span>(password)</span><br></pre></td></tr></table></figure>
<p>在第三次自己做的时候，发现这样做可能更加的快捷</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法如下：</span></span><br><span class="line"><span class="comment"># 1. 先将所有的小写字母变成对应的数字，组成一个新的中间字符串</span></span><br><span class="line"><span class="comment"># 2. 然后对得到的中间的字符串进行大写字母先变成小写再移位的操作</span></span><br><span class="line"><span class="comment"># 操作一：</span></span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    <span class="keyword">if</span> a[i] <span class="keyword">in</span> [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>]:</span><br><span class="line">        a[i] =<span class="string">&quot;2&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> a[i] <span class="keyword">in</span> [<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>]:</span><br><span class="line">        a[i] =<span class="string">&quot;3&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> a[i] <span class="keyword">in</span> [<span class="string">&quot;g&quot;</span>,<span class="string">&quot;h&quot;</span>,<span class="string">&quot;i&quot;</span>]:</span><br><span class="line">        a[i] =<span class="string">&quot;4&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> a[i] <span class="keyword">in</span> [<span class="string">&quot;j&quot;</span>,<span class="string">&quot;k&quot;</span>,<span class="string">&quot;l&quot;</span>]:</span><br><span class="line">        a[i] =<span class="string">&quot;5&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> a[i] <span class="keyword">in</span> [<span class="string">&quot;m&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;o&quot;</span>]:</span><br><span class="line">        a[i] =<span class="string">&quot;6&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> a[i] <span class="keyword">in</span> [<span class="string">&quot;p&quot;</span>,<span class="string">&quot;q&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="string">&quot;s&quot;</span>]:</span><br><span class="line">        a[i] =<span class="string">&quot;7&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> a[i] <span class="keyword">in</span> [<span class="string">&quot;t&quot;</span>,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;v&quot;</span>]:</span><br><span class="line">        a[i] =<span class="string">&quot;8&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> a[i] <span class="keyword">in</span> [<span class="string">&quot;w&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;z&quot;</span>]:</span><br><span class="line">        a[i] =<span class="built_in">str</span>(<span class="number">9</span>)</span><br><span class="line"><span class="comment"># 第二步：将其中的大写先变成小写然后移位</span></span><br><span class="line"><span class="comment"># 补充知识点：A~Z的ASCII为65~90，a~z的ASCII为97~122</span></span><br><span class="line"><span class="comment"># ord()用于将单字符转化为ASCII, chr()用于将ACSII转化为单字符</span></span><br><span class="line"><span class="comment"># 对a中的字符进行遍历</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    <span class="comment"># 如果发现有大写字母</span></span><br><span class="line">    <span class="comment"># 这里还是利用了内置的函数isupper()判断是否是大写字母</span></span><br><span class="line">    <span class="keyword">if</span> a[i].isupper():</span><br><span class="line">        <span class="comment"># 先将字符变为小写,然后进行向后移动一位</span></span><br><span class="line">        a[i]=(<span class="built_in">ord</span>(a[i].lower())+ <span class="number">1</span> -<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>))%<span class="number">26</span> +<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        <span class="comment"># 然后再将ASCII转化为单字符</span></span><br><span class="line">        a[i]=<span class="built_in">chr</span>(a[i])</span><br><span class="line"><span class="comment"># 得到了一个变更好的数组</span></span><br><span class="line"><span class="comment"># 将数组中的每个元素合并输出来</span></span><br><span class="line">res=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    res+=a[i]</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<h1 id="HJ24合唱队"><a href="#HJ24合唱队" class="headerlink" title="HJ24合唱队"></a>HJ24合唱队</h1><p>是最长递增子序列的变体：对原序列从左到右和从右到左分别求出到每个元素的最长递增子序列的长度<br>自己一开始根本没有想到这个层面上来，所以做的也是稀里糊涂的。<br>以下位正确的解题思路：</p>
<ol>
<li>先要得到第一次从左到右计算升序即每个学生左边最多有多少人（包括最大的那个值）</li>
<li>将原数组进行逆序，然后计算每个人的右边最多可以有多少个人（包括它自己）</li>
<li>将两次列表的值相加，得到的就是每个人的左右最多有多少人（包括两次自己）</li>
<li>最大值-1就是最长的排队序列的人数了<br>看到还有的另外的一种解释：寻找峰值的过程，计算峰值左侧的数量以及峰值右侧的数量，并相加寻找最大值的过程，在一开始的过程中所有的值都是峰值，所以初始化为1<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参照最长递增子序列的写法</span></span><br><span class="line"><span class="comment"># 先定义一个求最长子序列的函数,用来统计每个人的最左边出现的人数（善于把抽象的问题具体化）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">nums</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 设置一个dp数组，并将其中的值初始化为1，初始化的定义要明白：就是以本身结尾，左边没有比他小的数的情况</span></span><br><span class="line">        dp=[<span class="number">1</span>]*n</span><br><span class="line">        <span class="comment"># 设置一个数组来记录初始的长度</span></span><br><span class="line">        maxlength=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 设置一个结果数组，用来装到每个元素的最长递增子序列的长度</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="comment"># 对dp数组进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 对原数组进行遍历，其中在遍历的时候不能超过dp中对应的位置</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="comment"># 如果发现nums[i] &gt; nums[j] 并且当前的dp[j]+1要比dp[i]的值要大，说明以最后的一个元素结尾组成的子序列要大一些（这里的比较的过程其实也是一个十分细节的过程，没有用到python的内置的max()来求解。）</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt;nums[j] <span class="keyword">and</span> dp[i] &lt;dp[j] +<span class="number">1</span>:</span><br><span class="line">                    dp[i] = dp[j]+<span class="number">1</span></span><br><span class="line">            <span class="comment"># 在每次遍历完内层循环之后(更新dp[i]的过程中)，都需要比较一下此时dp[i]的值与初始化的1哪个更大</span></span><br><span class="line">            <span class="keyword">if</span> maxlength &lt; dp[i]:</span><br><span class="line">                <span class="comment"># 把更长的子序列的长度赋予给maxlength</span></span><br><span class="line">                maxlength=dp[i]</span><br><span class="line">            res.append(dp[i])</span><br><span class="line">        <span class="comment"># return maxlength</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">N=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line"><span class="comment"># 先求出从左向右的过程中的最长子序列长度的数组</span></span><br><span class="line">lst1=fn(a)</span><br><span class="line"><span class="comment">#print(lst1)</span></span><br><span class="line"><span class="comment"># 再求从右向左的过程中的最长子序列长度的数组</span></span><br><span class="line">b=<span class="built_in">list</span>(num <span class="keyword">for</span> num <span class="keyword">in</span> a[-<span class="number">1</span>::-<span class="number">1</span>])</span><br><span class="line">lst2=fn(b)</span><br><span class="line"><span class="comment">#print(lst2)</span></span><br><span class="line"><span class="comment"># 将lst1与lst2反序后合并</span></span><br><span class="line">lst3=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lst1)):</span><br><span class="line">    lst3.append(lst1[i]+lst2[::-<span class="number">1</span>][i])</span><br><span class="line"><span class="comment"># 求出最后需要出列的人数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a)-<span class="built_in">max</span>(lst3) +<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 这里拿题目中给定的例子来理解</span></span><br><span class="line"><span class="comment"># 题目给定的数，经过转换之后，a=[186, 186, 150, 200, 160, 130, 197, 200]</span></span><br><span class="line"><span class="comment"># 求从左到右数的到每个元素的最长递增子序列  lst1=[1, 1, 1, 2, 2, 1, 3, 4]</span></span><br><span class="line"><span class="comment"># 这里的lst1也可以理解为每个人左边可能出现最多的人</span></span><br><span class="line"><span class="comment"># 然后对lst1进行逆序b=[200, 197, 130, 160, 200, 150, 186, 186]</span></span><br><span class="line"><span class="comment"># 按照同样的方法求出从右向左到每一个元素的最长递增子序列 </span></span><br><span class="line"><span class="comment"># lst2=[1, 1, 1, 2, 3, 2, 3, 3]   反序之后： lst2=[3,3,2,3,2,1,1,1]</span></span><br><span class="line"><span class="comment"># 这里的lst2理解为每个人右边可能出现的最多的人</span></span><br><span class="line"><span class="comment"># 现在需要将两个列表进行合并，注意合并的时候需要将lst2逆序之后再合并得到的最大值-1就得到最大的合唱队人数。（这个人左边的比他小的人数+右边的比他小的人数-多算的本身就是这个合唱队的最大的长度）这里的理解是看了好多的题解之后才慢慢的反应过来的。</span></span><br><span class="line"><span class="comment"># 需要出队的人数=原数组的总数人-维持合唱队需要的人</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="HJ25-数据的分类处理"><a href="#HJ25-数据的分类处理" class="headerlink" title="HJ25-数据的分类处理"></a>HJ25-数据的分类处理</h1><p>描述<br>信息社会，有海量的<strong>数据需要分析处理</strong>，比如公安局分析身份证号码、 QQ 用户、手机号码、银行帐号等信息及活动记录。<br>采集<strong>输入大数据</strong>和<strong>分类规则</strong>，通过大数据分类处理程序，将大数据分类输出。<br>数据范围：1≤I,R≤100  ，输入的整数大小满足 0≤val≤2^31<br><strong>输入描述</strong>：<br>一组输入<strong>整数序列</strong>I和一组规则<strong>整数序列</strong>R，I和R序列的第一个整数为序列的个数（个数不包含第一个整数）；整数范围为0~(2^31)-1，序列个数不限<br><strong>输出描述</strong>：<br>从R依次中取出R<i>，对I进行处理，找到满足条件的I：<br>I整数对应的数字需要<strong>连续包含</strong>R<i>对应的数字。比如R<i>为23，I为231，那么I包含了R<i>，条件满足 。<br>按R<i>从小到大的顺序:<br>(1)先输出R<i>；<br>(2)再输出满足条件的I的个数；<br>(3)然后输出满足条件的I在I序列中的位置索引(从0开始)；<br>(4)最后再输出I。<br>附加条件：<br>(1)R<i>需要从小到大排序。相同的R<i>只需要<strong>输出索引小</strong>的以及满足条件的I，<strong>索引大的需要过滤</strong>掉<br>(2)如果没有满足条件的I，对应的R<i>不用输出<br>(3)最后需要在输出序列的第一个整数位置记录后续整数序列的个数(不包含“个数”本身)</p>
<h1 id="HJ26字符串的排序"><a href="#HJ26字符串的排序" class="headerlink" title="HJ26字符串的排序"></a>HJ26字符串的排序</h1><p>这道题也是值得整理的，也是在不断熟悉函数的过程，同时更加熟悉如何处理字符串的问题</p>
<ol>
<li>主要是这里处理的思想，前两个要求很好满足，只需将字符串转化成列表，然后按照将同时改为大写（或小写）来对原序列进行排序，用到了sort函数的高级用法。</li>
<li>合理的用到了for i ,v in enumerate的用法，是既可以返回索引又可以返回值的操作。</li>
<li>这里地第三点需要非英文字母保持在原味地写法很好，没有用到正则表达式地一些写法（自己暂时也还没有看那么多东西）</li>
<li>处理地时候先将非字母字符填充好，然后把带字母地排好序，然后按照顺序，从排好序地数组中弹出第一个元素，按照顺序加入到空缺位置。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">list</span>(<span class="built_in">input</span>())</span><br><span class="line">s=[]</span><br><span class="line">res=[<span class="number">0</span>]*<span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(a):</span><br><span class="line">    <span class="comment"># 如果v是字母的</span></span><br><span class="line">    <span class="keyword">if</span> v.isalpha():</span><br><span class="line">        s.append(v)</span><br><span class="line">    <span class="comment"># 如果v不是字母,把这个元素放在固定的位置不动</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res[i]=v</span><br><span class="line"><span class="comment"># 对s排序</span></span><br><span class="line">s.sort(key=<span class="keyword">lambda</span> x: x.upper())</span><br><span class="line"><span class="comment">#print(res)</span></span><br><span class="line"><span class="comment">#print(s)</span></span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(res):</span><br><span class="line">    <span class="comment"># 如果不是v(对于not v这样的写法，程序会自动地返回0)</span></span><br><span class="line">    <span class="comment"># 所以这里地v==0和not v,虽然形式上不一样，但是结果都是返回地0地情况</span></span><br><span class="line">    <span class="comment"># if v==0:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> v:</span><br><span class="line">        <span class="comment"># 将s的第一个元素作为此时的值</span></span><br><span class="line">        res[i]=s.pop(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 然后把这两个连在一起</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(res))</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="HJ29-字符串的加解密"><a href="#HJ29-字符串的加解密" class="headerlink" title="HJ29-字符串的加解密"></a>HJ29-字符串的加解密</h1><p>题目的描述还是比较的简单：<br>加密方法为：<br> 当内容是英文字母时则用该英文字母的后一个字母替换，同时字母变换大小写,如字母a时则替换为B；字母Z时则替换为a；<br>当内容是数字时则把该数字加1，如0替换1，1替换2，9替换0；<br>其他字符不做变化。<br> 解密方法为加密的逆过程。<br>数据范围：输入的两个字符串长度满足 1≤n≤1000，保证输入的字符串都是只由大小写字母或者数字组成<br>解题思路：</p>
<ol>
<li>用到的不同的字符对应的ASCII的范围:48<del>57  65</del>90  97~122</li>
<li>用到了几个重要的函数：ord() chr()   isdigit()  isupper()  isalpha()</li>
<li>关于循环取模的用法：自己体会<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解题思路：分别写一个加密的函数和一个解密的函数</span></span><br><span class="line"><span class="comment"># 定义一个加密的函数jiami</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jiami</span>(<span class="params">s1</span>):</span><br><span class="line">    res1=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 对字符串进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s1:</span><br><span class="line">        <span class="comment"># 如果发现是英文字母</span></span><br><span class="line">        <span class="comment"># 小写的英文字母的ASCII码是65~90</span></span><br><span class="line">        <span class="comment"># 大写的英文字母的ASCII是97~122</span></span><br><span class="line">        <span class="comment"># 0~9的ASCII是48~57</span></span><br><span class="line">        <span class="keyword">if</span> c.isalpha():</span><br><span class="line">            <span class="keyword">if</span> <span class="number">65</span>&lt;=<span class="built_in">ord</span>(c)&lt;=<span class="number">90</span>:</span><br><span class="line">                <span class="comment"># 先把字符转换为ASCII</span></span><br><span class="line">                temp=<span class="built_in">ord</span>(c)</span><br><span class="line">                <span class="comment"># print(temp)</span></span><br><span class="line">                <span class="comment"># 然后将ASCII向后移动一位，变成小写字母，然后转换为单字符</span></span><br><span class="line">                c=<span class="built_in">chr</span>((temp+<span class="number">1</span>-<span class="number">65</span>)%<span class="number">26</span>+<span class="number">97</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="number">97</span>&lt;=<span class="built_in">ord</span>(c)&lt;=<span class="number">122</span>:</span><br><span class="line">                <span class="comment"># 先把字符转换为ASCII</span></span><br><span class="line">                temp=<span class="built_in">ord</span>(c)</span><br><span class="line">                <span class="comment"># print(temp)</span></span><br><span class="line">                <span class="comment"># 然后将ASCII向后移动一位，变成大写字母，然后转换为单字符</span></span><br><span class="line">                c=<span class="built_in">chr</span>((temp+<span class="number">1</span>-<span class="number">97</span>)%<span class="number">26</span>+<span class="number">65</span>)</span><br><span class="line">        <span class="comment"># 说明是数字</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp=<span class="built_in">ord</span>(c)</span><br><span class="line">            c=<span class="built_in">chr</span>((temp+<span class="number">1</span>-<span class="number">48</span>)%<span class="number">10</span>+<span class="number">48</span>)</span><br><span class="line">        res1+=c</span><br><span class="line">    <span class="keyword">return</span> res1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个解密的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jiemi</span>(<span class="params">s2</span>):</span><br><span class="line">    res2=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 对字符串进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s2:</span><br><span class="line">        <span class="comment"># 如果发现是英文字母</span></span><br><span class="line">        <span class="comment"># 小写的英文字母的ASCII码是65~90</span></span><br><span class="line">        <span class="comment"># 大写的英文字母的ASCII是97~122</span></span><br><span class="line">        <span class="keyword">if</span> c.isalpha():</span><br><span class="line">            <span class="comment"># 是大写字母</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">65</span>&lt;=<span class="built_in">ord</span>(c)&lt;=<span class="number">90</span>:</span><br><span class="line">                <span class="comment"># 先把字符转换为ASCII</span></span><br><span class="line">                temp=<span class="built_in">ord</span>(c)</span><br><span class="line">                <span class="comment"># 然后将ASCII向后移动一位，并变成小写，然后转换为单字符</span></span><br><span class="line">                c=<span class="built_in">chr</span>((temp-<span class="number">1</span>-<span class="number">65</span>)%<span class="number">26</span>+<span class="number">97</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="number">97</span>&lt;=<span class="built_in">ord</span>(c)&lt;=<span class="number">122</span>:</span><br><span class="line">                <span class="comment"># 先把字符转换为ASCII</span></span><br><span class="line">                temp=<span class="built_in">ord</span>(c)</span><br><span class="line">                <span class="comment"># 然后将ASCII向后移动一位，并变成大写，然后转换为单字符</span></span><br><span class="line">                c=<span class="built_in">chr</span>((temp-<span class="number">1</span>-<span class="number">97</span>)%<span class="number">26</span>+<span class="number">65</span>)</span><br><span class="line">        <span class="comment"># 说明是数字</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp=<span class="built_in">ord</span>(c)</span><br><span class="line">            c=<span class="built_in">chr</span>((temp-<span class="number">1</span>-<span class="number">48</span>)%<span class="number">10</span>+<span class="number">48</span>)</span><br><span class="line">            <span class="comment"># print(c)</span></span><br><span class="line">        res2+=c</span><br><span class="line">    <span class="keyword">return</span> res2</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s1=<span class="built_in">input</span>()</span><br><span class="line">        s2=<span class="built_in">input</span>()</span><br><span class="line">        <span class="built_in">print</span>(jiami(s1))</span><br><span class="line">        <span class="built_in">print</span>(jiemi(s2))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="HJ33整数与ip地址间的转换"><a href="#HJ33整数与ip地址间的转换" class="headerlink" title="HJ33整数与ip地址间的转换"></a>HJ33整数与ip地址间的转换</h1><p>这道题也是值得整理的，主要还是对字符串的处理上面，是两个过程：整数与IP地址之间的互换<br>值得自己再重新写一遍，而且有很多需要注意的细节的地方。<br>前置知识需要处理：<br>ip地址：是一个<strong>32位的二进制数</strong>，通常被分割为4个“8进制的数”，通常用”点分十进制”表示成（a.c.c.d）的形式，其中a b c d都是<strong>0~255之间的10进制的整数</strong>。<br>ip地址的组成重点：</p>
<ol>
<li>网络部分(网络位)：直接决定了可以分配的网络计算方法：2^网络号位数-2</li>
<li>主机部分(主机位)：决定了网络中的最大主机数计算方法：2^主机号位数-2</li>
<li>网络地址：用来表示一个网络，主机位取值为0：例如192.168.1.0&#x2F;24</li>
<li>广播地址：用于在一个网络内一对所有的通信。主机部分全部换成1。</li>
<li>子网掩码：用于<strong>区分</strong>IP地址中的<strong>网络部分</strong>和<strong>主机部分</strong>，子网掩码 在 网络位的 全部按 1</li>
<li>默认网关：就是一个网络连接到另一个网络的“<strong>关口</strong>”，一般情况下网关的IP就是所在网络的**路由器的IP **<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 用.分隔字符串</span></span><br><span class="line">        s1=<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split(<span class="string">&#x27;.&#x27;</span>)))</span><br><span class="line">        s2=<span class="built_in">input</span>()</span><br><span class="line">        <span class="comment"># print(s)</span></span><br><span class="line">        <span class="comment"># 把每段数字转化为二进制数</span></span><br><span class="line">        <span class="comment"># 10对应的二进制： 00001010</span></span><br><span class="line">        <span class="comment"># 0对应的二进制：  00000000</span></span><br><span class="line">        <span class="comment"># 3对应的二进制：  00000011</span></span><br><span class="line">        <span class="comment"># 193对应的二进制：11000001</span></span><br><span class="line">        <span class="comment"># 将ip地址转换为整数的过程</span></span><br><span class="line">        res1=<span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> c1 <span class="keyword">in</span> s1:</span><br><span class="line">            temp=<span class="string">&#x27;&#123;:08b&#125;&#x27;</span>.<span class="built_in">format</span>(c1)</span><br><span class="line">            <span class="comment"># print(temp)</span></span><br><span class="line">            res1+=temp</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="comment"># 组成的二进制数整体转化为十进制</span></span><br><span class="line">        ans1=<span class="built_in">int</span>(<span class="built_in">str</span>(res1),<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># print(ans1)</span></span><br><span class="line">        <span class="comment"># 将整数转化为ip地址的过程</span></span><br><span class="line">        res2=[]</span><br><span class="line">        <span class="comment"># 将10进制转为2进制</span></span><br><span class="line">        temp2=<span class="built_in">bin</span>(<span class="built_in">int</span>(s2,<span class="number">10</span>))[<span class="number">2</span>:]</span><br><span class="line">        <span class="comment"># 如果长度小于32位，高位需要用0来填充</span></span><br><span class="line">        temp2 = <span class="string">&#x27;0&#x27;</span>*(<span class="number">32</span>-<span class="built_in">len</span>(temp2)) + temp2 <span class="keyword">if</span> <span class="built_in">len</span>(temp2)&lt;<span class="number">32</span> <span class="keyword">else</span> temp2</span><br><span class="line">        <span class="comment"># print(temp2)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            temp=temp2[<span class="number">8</span>*i:<span class="number">8</span>*i+<span class="number">8</span>]</span><br><span class="line">            temp=<span class="built_in">str</span>(<span class="built_in">int</span>(temp,<span class="number">2</span>))</span><br><span class="line">            res2.append(temp)</span><br><span class="line">        <span class="comment"># print(res2)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;.&#x27;</span>.join(res2))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="HJ35-蛇形矩阵"><a href="#HJ35-蛇形矩阵" class="headerlink" title="HJ35 蛇形矩阵"></a>HJ35 蛇形矩阵</h1><p>这道题做的时候咋一做的还真是把我难住了，并且还没有相应的思路，在短时间捏确实没有想出什么比较好的方法。以下都是提供的几种方式，我认为都是可以借鉴的，可以帮助自己打开自己的思路，遇到类似的题目的时候可以真正做到举一反三。<br>方式一是一比较巧的方式：<br>主要要找规律，主要找到第一行<br>第1行：相差是逐渐递增，相差2 3 4 5<br>第2行：第一行去掉第一个数，然后减1（这里的代码实现起来同样也是很巧妙的一种方式，利用上衣循环过程中生成的列表并且这里的列表都是采用的列表生成式的写法，包括在打印输出的时候，每一行矩阵的换行问题。里面的每一行代码都不能含糊）<br>后面的行数以此类推</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 观察到第一行的数相差的值是有规律的</span></span><br><span class="line"><span class="comment"># 后面的每一行都是在上一行的基础上除去第一个数之后再+1</span></span><br><span class="line"><span class="comment"># 有n行的矩阵</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        <span class="comment"># 定义一个矩阵</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 先打印出第一行</span></span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">1</span>:</span><br><span class="line">                res=[(<span class="number">1</span>+i)*i//<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line">            <span class="comment"># 然后再组装剩下的n-1行的数据</span></span><br><span class="line">            <span class="comment"># 将上一行的数据剔除第一个数，然后把每一个数减1:res[1:]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res=[num-<span class="number">1</span> <span class="keyword">for</span> num <span class="keyword">in</span> res[<span class="number">1</span>:]]</span><br><span class="line">            <span class="comment"># print(&#x27; &#x27;.join(map(str,res)))</span></span><br><span class="line">            <span class="comment"># print(res)</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res)):</span><br><span class="line">                <span class="built_in">print</span>(res[j],end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>方法二：直接硬找行与列之间的关系（参照别人的解答，确实是十分优秀的，尽管可能自己一时半会也想不出来，但是要有这样的思路）<br>第一行的规律符合累加求和：(1+n) *n&#x2F;&#x2F;2<br>第二行的规律是第一行的((1+n) *n&#x2F;&#x2F;2) -1<br>第三行的规律是第一行的((1+n) *n&#x2F;&#x2F;2) -2<br>第四行的规律是第一行的((1+n) *n&#x2F;&#x2F;2) -3<br>当i&#x3D; 1的时候，j&#x3D;1,2,3,4进入循环<br>当i&#x3D;2的时候，j&#x3D;2,3,4<br>当i&#x3D;3的时候，j&#x3D;3,4<br>当i&#x3D;4的时候，j&#x3D;4</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 第一行：累加和的规律n+1)*n//2</span></span><br><span class="line">        <span class="comment"># 第二行：在第一行的基础上(1+n) *n//2-1</span></span><br><span class="line">        <span class="comment"># 第三行：在第一行的基础上-2</span></span><br><span class="line">        <span class="comment"># 第四行：在第一行的基础上-3</span></span><br><span class="line">        n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        <span class="comment"># i表示行数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 表示当前行有多少列</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n+<span class="number">1</span>):</span><br><span class="line">                <span class="built_in">print</span>((<span class="number">1</span>+j)*j//<span class="number">2</span>-i+<span class="number">1</span>,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="comment"># 当一层循环完之后，需要换行，开始循环下一论打印下一行</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>这里还有第三种解法<br>直接正向进行输出，我觉得这里的理解就更加的不好操作了，真的只有膜拜的份了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">5</span></span><br><span class="line"><span class="comment"># 计数器</span></span><br><span class="line">count=<span class="number">0</span></span><br><span class="line"><span class="comment"># 先生成一个特定矩阵的容器</span></span><br><span class="line"><span class="comment"># 这个技巧必须要学会（是常规矩阵生成体的一种变式）</span></span><br><span class="line">res=[[<span class="number">0</span>]*(n-i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"><span class="comment"># 下面来开始填入数据</span></span><br><span class="line"><span class="comment"># 我们通过找规律发现，如果是按照三角形塔的形式来输出的话</span></span><br><span class="line"><span class="comment"># 直接把这个矩阵逆时针旋转45度就可以得到目标矩阵</span></span><br><span class="line"><span class="comment"># 在旋转的过程中原来的行和列与现在的行和列有一定的关系</span></span><br><span class="line"><span class="comment"># 列前后不变，行有变换</span></span><br><span class="line"><span class="comment"># 这两个循环是冲着生成塔三角的形式去的</span></span><br><span class="line">temp=[[<span class="number">0</span>]*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]    </span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>):</span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">        temp[i][j]=count</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"><span class="comment"># [1, 3, 6, 10, 15] [2, 5, 9, 14] [4, 8, 13] [7, 12] [11]</span></span><br><span class="line"><span class="comment"># 这样其实就已经将这个矩阵给求出来了</span></span><br></pre></td></tr></table></figure>
<p>完整的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">int</span>(<span class="keyword">in</span>[put())</span><br><span class="line"><span class="comment"># 计数器</span></span><br><span class="line">count=<span class="number">0</span></span><br><span class="line">res=[[<span class="number">0</span>]*(n-i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="comment"># 在res中填充元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>):</span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">        res[i-j][j]=count</span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"><span class="comment"># res=[[1, 3, 6, 10, 15], [2, 5, 9, 14], [4, 8, 13], [7, 12], [11]]</span></span><br><span class="line"><span class="comment"># 现在把结果矩阵的元素按照行输出来，元素与元素之间用空格隔开</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> res:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="built_in">print</span>(i,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment"># 这里也可以直接用map(srt,res)，可以一步到位，十分的方便(s本身也就是一个可以迭代的)</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,s)))</span><br></pre></td></tr></table></figure>
<h1 id="HJ37-统计每个月兔子的总数"><a href="#HJ37-统计每个月兔子的总数" class="headerlink" title="HJ37-统计每个月兔子的总数"></a>HJ37-统计每个月兔子的总数</h1><p>自己做了时候好像已经找了规律，但是写的时候还是有点摸不着头脑的样子（显然规律找错了）<br>用到动态规划和循环的解法（其实这里的解法很多很多，而且这道题已经快做烂了）<br>代码不再贴了，主要做了很多的次数了。</p>
<h1 id="字符串加解密"><a href="#字符串加解密" class="headerlink" title="字符串加解密"></a>字符串加解密</h1><p>直接写思路，题目估计在笔试前是没有时间做了。读懂题目<br>加密方法：</p>
<ol>
<li>当内容是英文的时候，用英文字母的后一个字母替换（以26为一个轮换），同时字母变换大小写</li>
<li>当 内容是数字时，把数字+1（这肯定要做一个以9为一个循环的判断）</li>
<li>其他字符不做变化<br>解密方法：加密方法的逆过程<br>这题和21题总的来说是比较像的。</li>
</ol>
<h1 id="HJ43迷宫问题"><a href="#HJ43迷宫问题" class="headerlink" title="HJ43迷宫问题"></a>HJ43迷宫问题</h1><p>第一次写这道题，想着是用深度优先搜索地，发现这里地模式是ACM模式，所以函数调用不成功，后面调试都进行不下去了。还是想总结出自己特有地思路，和之前听地视频课地内容能够很好地结合起来才会变成自己的东西。<br>借鉴别人的思路，把别人的代码先弄懂（找准一个点看下去就行）<br>N*M的一个矩阵，表示一个迷宫，其中1表示墙壁，0表示可以走的路，只能横或竖着走，不能斜着走，要求编程找出从左下角到右下角的最短路径。<br>在回顾这道题的时候，又把岛屿问题以及排列I和排列II的问题又回顾了一遍，代码还是不够完全熟练掌握。<br>废了好大的劲终于把这道题给弄懂了，剩下的就是不断地熟悉再熟悉地过程了（代码一定要滚瓜烂熟，烂熟于心才行，这题地代码也是多多多地跑几遍才行）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 先把dsf的模板搬上来，不会也要强行让自己掌握</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x,y,lst,mark,path</span>):</span><br><span class="line">            <span class="comment"># 循环遍历当前位置的上下左右四个方向</span></span><br><span class="line">            <span class="comment">#定义方向向量</span></span><br><span class="line">            directions=[(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>)]</span><br><span class="line">            <span class="comment"># 当遍历到最后一行最后一列是，递归结束，输出这条路径上的所有值</span></span><br><span class="line">            <span class="keyword">if</span> x==<span class="built_in">len</span>(mark)-<span class="number">1</span> <span class="keyword">and</span> y==<span class="built_in">len</span>(mark[<span class="number">0</span>])-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> i, j <span class="keyword">in</span> path:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;(&#x27;</span> + <span class="built_in">str</span>(i) + <span class="string">&#x27;,&#x27;</span> + <span class="built_in">str</span>(j) + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> dx,dy <span class="keyword">in</span> directions:</span><br><span class="line">                <span class="comment"># 定义新的行以及新的列</span></span><br><span class="line">                newX,newY=x+dx,y+dy</span><br><span class="line">                <span class="comment"># 如果新的行与新的列超出数组的边界</span></span><br><span class="line">                <span class="keyword">if</span> newX&lt;<span class="number">0</span> <span class="keyword">or</span> newX&gt;=<span class="built_in">len</span>(mark) <span class="keyword">or</span> newY&lt;<span class="number">0</span> <span class="keyword">or</span> newY&gt;=<span class="built_in">len</span>(mark[<span class="number">0</span>]):</span><br><span class="line">                    <span class="comment">#跳出当前的位置</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 如果发现这个位置是0（表示可以走得通），并且这个位置又没有被标记过</span></span><br><span class="line">                <span class="keyword">if</span> lst[newX][newY]==<span class="number">0</span> <span class="keyword">and</span> mark[newX][newY]==<span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 当前搜索在mark中标记为1，代表已经遍历过了</span></span><br><span class="line">                    mark[newX][newY]=<span class="number">1</span></span><br><span class="line">                    <span class="comment"># 把该值添加到路径中去</span></span><br><span class="line">                    path.append((newX,newY))</span><br><span class="line">                    <span class="comment">#print(path)</span></span><br><span class="line">                    <span class="comment"># 递归进行相应的搜素</span></span><br><span class="line">                    dfs(newX,newY,lst,mark,path)</span><br><span class="line">                    <span class="comment"># 标记重新还原,表示没有被访问</span></span><br><span class="line">                    mark[newX][newY]=<span class="number">0</span></span><br><span class="line">                    path.pop()</span><br><span class="line">        <span class="comment"># 输入行数和列数</span></span><br><span class="line">        n,m=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">        <span class="comment"># 定义一个数组用来放输入的数据</span></span><br><span class="line">        lst=[]</span><br><span class="line">        path=[(<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line">        <span class="comment"># 定义一个mark数组，标记已经搜索的位置</span></span><br><span class="line">        mark=[[<span class="number">0</span>]*m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line"><span class="comment">#             a = list(map(int,input().split()))</span></span><br><span class="line"><span class="comment">#             lst.append(a)</span></span><br><span class="line">            lst.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())))</span><br><span class="line">        <span class="comment">#print(lst)</span></span><br><span class="line">        <span class="comment"># 从坐标(0,0)开始进行搜索</span></span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,lst,mark,path)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span>          </span><br></pre></td></tr></table></figure>
<p>在第二遍做的时候就发现，有的很小的东西出现错误，机会是完全靠的肌肉肌肉，把题目给背下来了，没有认真的去检查，但是相对来说已经有了很大的进步，总得来还算比较的合理。今天或者明天再做第三遍（不仅仅是代码的肌肉记忆，也是思路的肌肉记忆。）<br>出错的几个点：</p>
<ol>
<li><img src="https://runnerxr.github.io//post-images/1651409575289.png">这三行代码再写的时候打了一下蹬，说明在语法上面还是不够特别的熟悉。path是一个数组，数组里面的是元组，目的是取出元组。</li>
<li><img src="https://runnerxr.github.io//post-images/1651409821187.png">这五行代码当时写的不是特别的笃定：<ol>
<li>一旦满足条件，就标记已访问</li>
<li>随后把符合条件的加入到路径数组中</li>
<li>然后在当前的基础上进行下一轮的搜索</li>
<li>下一轮搜索结束之后，将当前的标记改回来</li>
<li>将当前的元素弹出原本加入的路径</li>
</ol>
</li>
</ol>
<h1 id="HJ48-从单向链表中删除指定值的节点"><a href="#HJ48-从单向链表中删除指定值的节点" class="headerlink" title="HJ48-从单向链表中删除指定值的节点"></a>HJ48-从单向链表中删除指定值的节点</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参考题解的一些做法</span></span><br><span class="line"><span class="comment"># 纯当学习记录</span></span><br><span class="line"><span class="comment">#方法一：逆向翻转链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data=<span class="number">0</span></span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 定义一个头节点</span></span><br><span class="line">        head = ListNode()</span><br><span class="line">        <span class="comment"># 输入链表的结点个数</span></span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">        <span class="comment"># print(a)</span></span><br><span class="line">        k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        <span class="comment"># 经过一个循环之后，头节点指向倒数第k个节点</span></span><br><span class="line">        <span class="keyword">while</span> k:</span><br><span class="line">            <span class="comment"># 让head的next节点不断地指向从列表中弹出的元素</span></span><br><span class="line">            <span class="comment"># 这里地定义很巧妙</span></span><br><span class="line">            head.<span class="built_in">next</span> = ListNode(a.pop())</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(head.data)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p><strong>方法二（写的稍微多点，完全按照定义来）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,data</span>):</span><br><span class="line">        self.data=data</span><br><span class="line">        self.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个链表类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 定义链表类的方法,并初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,node=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># 一个私有的head属性，指向None</span></span><br><span class="line">        self.__head=<span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 判断链表是否为空</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isempty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__head==<span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在链表的尾部添加节点的方法（尾插法）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self,item</span>):</span><br><span class="line">        node=ListNode(item)</span><br><span class="line">        <span class="comment"># 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> self.isempty():</span><br><span class="line">            <span class="comment"># 直接让self.__head指向node</span></span><br><span class="line">            self.__head=node</span><br><span class="line">        <span class="comment"># 链表不为空</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur=self.__head</span><br><span class="line">            <span class="comment"># 这个时候的循环判断条件发生变化</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span>!=<span class="literal">None</span>:</span><br><span class="line">                cur=cur.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 循环结束的时候cur.next指向为None</span></span><br><span class="line">            <span class="comment"># 修改最后一个节点的指向，将cur.next指向node </span></span><br><span class="line">            cur.<span class="built_in">next</span>=node</span><br><span class="line">			</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pos_search</span>(<span class="params">self,length,pos</span>):</span><br><span class="line">        cur=self.__head</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 如果pos是负数的情况</span></span><br><span class="line">        <span class="keyword">if</span> pos&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> cur!=<span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 计数+1</span></span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count==length-pos+<span class="number">1</span>:</span><br><span class="line">                    <span class="built_in">print</span>(cur.data)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur=cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 输入链表的结点个数</span></span><br><span class="line">        n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        a=<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>)))</span><br><span class="line">        k=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        sll=SingleLinkList()</span><br><span class="line">        <span class="comment"># 把单向链表的值全部加进来</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            temp=a[i]</span><br><span class="line">            sll.append(temp)</span><br><span class="line">        <span class="comment"># 接下来开始去查找倒数第K个指针对应的值</span></span><br><span class="line">        sll.pos_search(n,k)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h1 id="HJ50-四则运算"><a href="#HJ50-四则运算" class="headerlink" title="HJ50-四则运算"></a>HJ50-四则运算</h1><p>输入一个表达式（用字符串表示），求这个表达式的值。<br>保证字符串中的有效字符包括[‘0’-‘9’],‘+’,‘-’, ‘*’,‘&#x2F;’ ,‘(’， ‘)’,‘[’, ‘]’,‘{’ ,‘}’。且表达式一定合法。<br>数据范围：表达式计算结果和过程中满足 ∣val∣≤1000 ，字符串长度满足 1≤n≤1000<br>输入描述：<br>输入一个算术表达式<br>输出描述：<br>得到计算结果<br>做题分析：刚开始得到这道题也是一筹莫展，考点有字符串、基础数学、栈的相关知识<br>总的运算规则：</p>
<ol>
<li>先算括号里面的，并且括号有一个优先级</li>
<li>在括号里面的数组，先算乘除，再算加减</li>
<li>在括号外面的同级的要按照从左到右的顺序来算</li>
</ol>
<h1 id="HJ51-输出单向链表中倒数第k个结点"><a href="#HJ51-输出单向链表中倒数第k个结点" class="headerlink" title="HJ51-输出单向链表中倒数第k个结点"></a>HJ51-输出单向链表中倒数第k个结点</h1><p>这道题是务必要掌握的，没有任何的理由，必须拿下，原来这道题自己是做过的，但是这里更考验完整的代码能力，所以还是没有那么好做。<br>输入一个链表，输出倒数第k个结点，链表的倒数第一个结点为链表的尾指针</p>
<ol>
<li>需要构建链表</li>
<li>构建后需要忘记链表长度</li>
<li>正常返回第k个节点指针，异常返回空指针<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码如下</span></span><br><span class="line"><span class="comment"># 利用列表的知识来求解（此份代码是引用别人的）</span></span><br><span class="line"><span class="comment"># 这种方式是在充分理解概念之后，用十分精简凝练的代码写出来的</span></span><br><span class="line"><span class="comment"># 需要自己写一个结点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        l, s, k, head = <span class="built_in">int</span>(<span class="built_in">input</span>()), <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())), <span class="built_in">int</span>(<span class="built_in">input</span>()), Node()</span><br><span class="line">        <span class="keyword">while</span> k:</span><br><span class="line">            head.<span class="built_in">next</span> = Node(s.pop())</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(head.val)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="HJ53-杨辉三角的变形"><a href="#HJ53-杨辉三角的变形" class="headerlink" title="HJ53-杨辉三角的变形"></a>HJ53-杨辉三角的变形</h1><p>发现规律，从第三行开始，2324的循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">            <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 从第三行开始分别是 2 3 2 4 2 5 </span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">            <span class="built_in">print</span>(temp[(n-<span class="number">3</span>)%<span class="number">4</span>])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h1 id="HJ54-表达式求值-x2F-BM49"><a href="#HJ54-表达式求值-x2F-BM49" class="headerlink" title="HJ54-表达式求值&#x2F;BM49"></a>HJ54-表达式求值&#x2F;BM49</h1><p>这道题和BM49题基本上一模一样的<br>描述<br>给定一个字符串描述的算术表达式，计算出结果值。<br>输入字符串长度不超过 100 ，合法的字符包括 ”+, -, *, &#x2F;, (, )” ， ”0-9” 。<br>数据范围：运算过程中和最终结果均满足 ∣val∣≤231−1，即只进行整型运算，确保输入的表达式合法<br>输入描述：<br>输入算术表达式<br>输出描述：<br>计算出结果值</p>
<p>其实在做这道题的时候也发现一些比较好的思路，值得自己去学习：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 待记录比较好的解法</span></span><br></pre></td></tr></table></figure>
<h1 id="HJ-完全数计算"><a href="#HJ-完全数计算" class="headerlink" title="HJ-完全数计算"></a>HJ-完全数计算</h1><p>也主要是思路<br>描述<br>完全数（Perfect number），又称完美数或完备数，是一些特殊的自然数。<br>它所有的真因子（即除了自身以外的约数）的和（即因子函数），恰好等于它本身。<br>例如：28，它有约数1、2、4、7、14、28，除去它本身28外，其余5个数相加，1+2+4+7+14&#x3D;28。<br>输入n，请输出n以内(含n)完全数的个数。<br>数据范围： 1≤n≤5×105<br>可以尝试看看其他人的解法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 首先需要明白完全数的定义：除自己以外的约束之和==它本身，即需要把相应的约数全部给枚举说出</span></span><br><span class="line">        <span class="comment"># 然后给出一个判断，是否之和等于它本身</span></span><br><span class="line">        <span class="comment"># 对于符合这个条件的数用count数组+1</span></span><br><span class="line">        n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 以下求的是某个具体的数的全部的约数 </span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">n</span>):</span><br><span class="line">            res=[]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> n%i==<span class="number">0</span>:</span><br><span class="line">                    res.append(i)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(res) </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> fn(i)==i:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(count)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>


<h1 id="HJ70-矩阵乘法计算量估算"><a href="#HJ70-矩阵乘法计算量估算" class="headerlink" title="HJ70-矩阵乘法计算量估算"></a>HJ70-矩阵乘法计算量估算</h1><p>这道题在利用栈的题目里面算相对简单的。这里需要注意的地方是计算的法则为一个字符串，它是由左右括号和大写字母组成的，这里就存在一个数字与ASCII的相互转换的问题，A<del>Z对应的ASCII是65</del>90，关键还是在处理矩阵以及矩阵的技巧上面，这个很考验基本功和思维能力；然后还有就是基本的矩阵相乘的数学知识的问题；还有对右括号的处理的问题（下面的两种写法一种处理了，一种并没有处理）；算完括号内的值之后在更新值的过程也是一大特点。（这里是自己不做题就根本想不到的地方）<br>这种用两种写法来写</p>
<ol>
<li>用字典的形式来存储矩阵</li>
<li>直接用数组的形式来存储矩阵<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用字典的形式来存储矩阵，其中key为对应的字母转化为ASCII之后的值</span></span><br><span class="line"><span class="comment"># 这里有一个好处是预先就将字典的key给出了，给每个矩阵都按顺序配了A~Zkey值</span></span><br><span class="line"><span class="comment"># 做了之后发现这样的方法不是特别的好，容易和输入的字母混淆</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        mdict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            mdict[<span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)+i)] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().strip().split()))<span class="comment">## 用strip()先去掉可能隐藏的末尾空格。再split(),防止map不过去</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># s表示输入的矩阵表达式</span></span><br><span class="line">        <span class="comment"># 注意这里s的表达式中非括号的数字是大写字母</span></span><br><span class="line">        <span class="comment">#  ((AB)C)</span></span><br><span class="line">        <span class="comment">#  (A(BC))</span></span><br><span class="line">        <span class="comment">#  (A(B(C(D(E(F(GH)))))))</span></span><br><span class="line">        s = <span class="built_in">input</span>()</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment">#不遇到&#x27;)&#x27;就一直压栈</span></span><br><span class="line">            <span class="keyword">if</span> i != <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                temp.append(i)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#直接遇到&#x27;)&#x27;,把前两个弹出来计算乘法运算量</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                C = temp.pop()</span><br><span class="line">                B = temp.pop()</span><br><span class="line">                <span class="comment"># 弹掉前括号&#x27;(&#x27;</span></span><br><span class="line">                temp.pop()</span><br><span class="line">                result+= mdict[B][<span class="number">0</span>] * mdict[B][<span class="number">1</span>] * mdict[C][<span class="number">1</span>] </span><br><span class="line">                mdict[B] = [mdict[B][<span class="number">0</span>], mdict[C][<span class="number">1</span>]]<span class="comment">#把当前乘积的结果存储起来</span></span><br><span class="line">                temp.append(B)<span class="comment">#把当前乘积结果入栈</span></span><br><span class="line">        <span class="comment">#因为有最外圈括号，弹完所有&#x27;)&#x27;即完成整个算式的结果</span></span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接用数组来存储矩阵，其实本质和上面的是差不多的，如果只是改动这一点，还上面没有什么差别</span></span><br><span class="line"><span class="comment"># 这里主要是改动了if的判断语句，作为一种选择放在这里</span></span><br><span class="line"><span class="comment"># 实际上是字符是左括号什么也不做；字符是右括号，出栈，字符是字母，入栈。</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        mdict = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 用strip()先去掉可能隐藏的末尾空格。再split(),防止map不过去</span></span><br><span class="line">            mdict.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().strip().split())))</span><br><span class="line">        <span class="comment"># print(mdict)</span></span><br><span class="line">        <span class="comment"># s表示输入的矩阵表达式</span></span><br><span class="line">        <span class="comment"># 注意这里s的表达式中非括号的数字是</span></span><br><span class="line">        s = <span class="built_in">input</span>()</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 如果发现是字母就加进去</span></span><br><span class="line">            <span class="comment"># 相比上面的解法，这里排除了加入左括号的情况（默认题目给定的一定是一个有效的字符串）</span></span><br><span class="line">            <span class="keyword">if</span> i.isalpha():</span><br><span class="line">                <span class="comment"># temp.append(i)</span></span><br><span class="line">                <span class="comment"># 把原先是字母的现在全部转换为数字，并且按照A~Z转化为0~25这样的形式来处理</span></span><br><span class="line">                temp.append(mdict[<span class="built_in">ord</span>(i)-<span class="number">65</span>])</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#直接遇到&#x27;)&#x27;,把前两个弹出来计算乘法运算量</span></span><br><span class="line">            <span class="keyword">elif</span> i==<span class="string">&#x27;)&#x27;</span> <span class="keyword">and</span> <span class="built_in">len</span>(temp)&gt;=<span class="number">2</span>: </span><br><span class="line">                <span class="comment"># 第一次弹出的数</span></span><br><span class="line">                b=temp.pop()</span><br><span class="line">                <span class="comment">#print(b)</span></span><br><span class="line">                <span class="comment"># 第二次弹出来的数</span></span><br><span class="line">                a=temp.pop()</span><br><span class="line">                <span class="comment"># print(a)</span></span><br><span class="line">                result +=a[<span class="number">0</span>] * a[<span class="number">1</span>] * b[<span class="number">1</span>]</span><br><span class="line">                temp.append([a[<span class="number">0</span>],b[<span class="number">1</span>]])      </span><br><span class="line">        <span class="comment">#因为有最外圈括号，弹完所有&#x27;)&#x27;即完成整个算式的结果</span></span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="HJ87-密码强度等级"><a href="#HJ87-密码强度等级" class="headerlink" title="HJ87-密码强度等级"></a>HJ87-密码强度等级</h1><p>自己写的代码有点过于冗长了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s=<span class="built_in">input</span>()</span><br><span class="line">        <span class="comment"># 初始化一个分数score，为0分</span></span><br><span class="line">        score=<span class="number">0</span></span><br><span class="line">        n=<span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 分别从5个方面进行对分数的增加</span></span><br><span class="line">        <span class="comment"># 1.对密码长度进行统计</span></span><br><span class="line">        <span class="comment"># 2.对字母大小写的种类进行统计</span></span><br><span class="line">        <span class="comment"># 3.对数字的个数进行统计</span></span><br><span class="line">        <span class="comment"># 4.对符号的个数进行统计</span></span><br><span class="line">        <span class="comment"># 5.对字母.数字以及符号的种类进行统计</span></span><br><span class="line">        <span class="comment"># 对密码长度的判定，然后计算得分</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">4</span>:</span><br><span class="line">            score+=<span class="number">5</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="number">5</span>&lt;=n&lt;=<span class="number">7</span>:</span><br><span class="line">            score+=<span class="number">10</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            score+=<span class="number">25</span></span><br><span class="line">        <span class="comment"># 对密码中字母的判定</span></span><br><span class="line">        <span class="comment"># 需要对大小写字母进行计数</span></span><br><span class="line">        count_daxie=<span class="number">0</span></span><br><span class="line">        count_xiaoxie=<span class="number">0</span></span><br><span class="line">        count_num=<span class="number">0</span></span><br><span class="line">        count_other=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c.isalpha():</span><br><span class="line">                <span class="keyword">if</span> c.isupper():</span><br><span class="line">                    count_daxie+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    count_xiaoxie+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果发现c是数字统计数字的个数</span></span><br><span class="line">            <span class="keyword">elif</span> c.isdigit():</span><br><span class="line">                count_num+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 既不是字母，也不是数字，是其他的符号</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count_other+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 循环结束之后对各项都有了一定的统计</span></span><br><span class="line">        <span class="keyword">if</span> (count_daxie!=<span class="number">0</span> <span class="keyword">and</span> count_xiaoxie==<span class="number">0</span>) <span class="keyword">or</span> (count_daxie==<span class="number">0</span> <span class="keyword">and</span> count_xiaoxie!=<span class="number">0</span>):</span><br><span class="line">            score+=<span class="number">10</span></span><br><span class="line">        <span class="keyword">elif</span> count_daxie!=<span class="number">0</span> <span class="keyword">and</span> count_xiaoxie!=<span class="number">0</span>:</span><br><span class="line">            score+=<span class="number">20</span></span><br><span class="line">        <span class="keyword">if</span> count_num==<span class="number">1</span>:</span><br><span class="line">            score+=<span class="number">10</span></span><br><span class="line">        <span class="keyword">elif</span> count_num&gt;<span class="number">1</span>:</span><br><span class="line">            score+=<span class="number">20</span></span><br><span class="line">        <span class="keyword">if</span> count_other==<span class="number">1</span>:</span><br><span class="line">            score+=<span class="number">10</span></span><br><span class="line">        <span class="keyword">elif</span> count_other&gt;<span class="number">1</span>:</span><br><span class="line">            score+=<span class="number">25</span></span><br><span class="line">        <span class="comment"># 怎么体现种类</span></span><br><span class="line">        count_alpha=count_daxie+count_xiaoxie</span><br><span class="line">        <span class="comment"># 字母+数字</span></span><br><span class="line">        <span class="keyword">if</span> count_alpha+count_num==n <span class="keyword">and</span> count_num!=<span class="number">0</span>:</span><br><span class="line">            score+=<span class="number">2</span></span><br><span class="line">        <span class="comment"># 字母+数字+符号</span></span><br><span class="line">        <span class="keyword">elif</span> count_alpha+count_num+count_other==n <span class="keyword">and</span> count_daxie==<span class="number">0</span> <span class="keyword">or</span> count_xiaoxie==<span class="number">0</span>  <span class="keyword">and</span> count_num!=<span class="number">0</span> <span class="keyword">and</span> count_other!=<span class="number">0</span>:</span><br><span class="line">            score+=<span class="number">3</span></span><br><span class="line">        <span class="keyword">elif</span> count_daxie+count_xiaoxie+count_num+count_other==n <span class="keyword">and</span> count_daxie!=<span class="number">0</span> <span class="keyword">and</span> count_xiaoxie!=<span class="number">0</span> <span class="keyword">and</span> count_num!=<span class="number">0</span> <span class="keyword">and</span> count_other!=<span class="number">0</span>:</span><br><span class="line">            score+=<span class="number">5</span></span><br><span class="line">        <span class="comment"># print(score)</span></span><br><span class="line">        <span class="comment"># 开始对密码进行强度的评定</span></span><br><span class="line">        <span class="keyword">if</span> score &gt;=<span class="number">90</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;VERY_SECURE&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="number">80</span>&lt;=score&lt;<span class="number">90</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;SECURE&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="number">70</span>&lt;=score&lt;<span class="number">80</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;VERY_STRONG&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="number">60</span>&lt;=score&lt;<span class="number">70</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;STRONG&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="number">50</span>&lt;=score&lt;<span class="number">60</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;AVERAGE&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="number">25</span>&lt;=score&lt;<span class="number">50</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;WEAK&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="number">0</span>&lt;=score&lt;<span class="number">25</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;VERY_WEAK&#x27;</span>)        </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h1 id="HJ86-求最大连续的bit数"><a href="#HJ86-求最大连续的bit数" class="headerlink" title="HJ86- 求最大连续的bit数"></a>HJ86- 求最大连续的bit数</h1><p>主要是学习里面的思路，当然代码的实现也很重要<br>比如方法一里面采用0分隔的方法，然后找出最长的那个字符（就是出现最多1的情况）</p>
<h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># split()一下之后用下set去掉多个分割出来的空值排个序就好了吧</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        temp=<span class="built_in">bin</span>(n)[<span class="number">2</span>:]</span><br><span class="line">        <span class="comment"># print(temp)</span></span><br><span class="line">        <span class="comment"># 按照0的位置进行相应的切分</span></span><br><span class="line">        temp=<span class="built_in">list</span>(<span class="built_in">set</span>(temp.split(<span class="string">&#x27;0&#x27;</span>)))</span><br><span class="line">        <span class="comment"># 然后按照长度进行排序</span></span><br><span class="line">        temp.sort(key=<span class="keyword">lambda</span> x:<span class="built_in">len</span>(x),reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">len</span>(temp[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="方法二：采用位运算的思路解题"><a href="#方法二：采用位运算的思路解题" class="headerlink" title="方法二：采用位运算的思路解题"></a>方法二：采用位运算的思路解题</h2><p>要能想到这种方法以及里面的思想</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        temp=<span class="built_in">bin</span>(n)[<span class="number">2</span>:]</span><br><span class="line">        <span class="comment"># print(temp)</span></span><br><span class="line">        nums=[<span class="built_in">int</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> temp]</span><br><span class="line">        maxCount=count=<span class="number">0</span></span><br><span class="line">        length=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 对数进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">1</span>&amp;nums[i]==<span class="number">1</span>:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 每次更新最大的长度</span></span><br><span class="line">                maxCount=<span class="built_in">max</span>(maxCount,count)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count=<span class="number">0</span></span><br><span class="line">        <span class="built_in">print</span>(maxCount)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="采用一次遍历的方法"><a href="#采用一次遍历的方法" class="headerlink" title="采用一次遍历的方法"></a>采用一次遍历的方法</h2><p>这种方法应该才是最常规的方法了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        temp=<span class="built_in">bin</span>(n)[<span class="number">2</span>:]</span><br><span class="line">        <span class="comment"># 将位运算的字符转化为列表</span></span><br><span class="line">        <span class="comment"># print(temp)</span></span><br><span class="line">        nums=[<span class="built_in">int</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> temp]</span><br><span class="line">        <span class="comment"># print(nums)</span></span><br><span class="line">        maxCount=count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num==<span class="number">1</span>:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                maxCount=<span class="built_in">max</span>(maxCount,count)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 重置计数</span></span><br><span class="line">                count=<span class="number">0</span></span><br><span class="line">        <span class="built_in">print</span>(maxCount)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h1 id="HJ96-表示数字"><a href="#HJ96-表示数字" class="headerlink" title="HJ96-表示数字"></a>HJ96-表示数字</h1><p>描述<br>将一个字符中所有的整数前后加上符号“<em>”，其他字符保持不变。连续的数字视为一个整数。<br>数据范围：字符串长度满足 1≤n≤100 1 \le n \le 100 \ 1≤n≤100<br>输入描述：<br>输入一个字符串<br>输出描述：<br>字符中所有出现的数字前后加上符号“</em>”，其他字符保持不变<br>示例1<br>输入：<br>Jkdi234klowe90a3<br>输出：<br>Jkdi<em>234</em>klowe<em>90</em>a<em>3</em><br>这里自己参考别人的思路给了两种方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s=<span class="built_in">input</span>()</span><br><span class="line">        n=<span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 记录当前遍历的字符的前一个字符</span></span><br><span class="line">        char_pre=<span class="string">&#x27;&#x27;</span></span><br><span class="line">        res=<span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 如果当前遇到的数字</span></span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                <span class="comment"># 判断前面是否为数字，如果不是，说明这个数字就是开头的数字，加一个*</span></span><br><span class="line">                <span class="keyword">if</span> char_pre.isdigit()==<span class="literal">False</span>:</span><br><span class="line">                    res+=<span class="string">&#x27;*&#x27;</span></span><br><span class="line">            <span class="comment"># 如果当前遇到的不是数字，查看前面的数字是否是数字，如果是表示数字的结束，加入一个*</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> char_pre.isdigit():</span><br><span class="line">                    res+=<span class="string">&#x27;*&#x27;</span></span><br><span class="line">            <span class="comment"># 把当前的字符带出来</span></span><br><span class="line">            res+=c</span><br><span class="line">            <span class="comment"># 当前字符更新到前字符</span></span><br><span class="line">            char_pre=c</span><br><span class="line">        <span class="comment"># 循环结束，查看最后一个字符是不是数字</span></span><br><span class="line">        <span class="keyword">if</span> s[-<span class="number">1</span>].isdigit():</span><br><span class="line">            res+=<span class="string">&#x27;*&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 将所有出现数字的前后都加上*</span></span><br><span class="line">        <span class="comment"># 循环完毕后将**用replace函数转换为&#x27;&#x27;</span></span><br><span class="line">        s=<span class="built_in">input</span>()</span><br><span class="line">        res=<span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 考虑到原本就有*的存在，先把*替换成一个不可能出现的字符</span></span><br><span class="line">        s=s.replace(<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;熊锐&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                res+=<span class="string">&#x27;*&#x27;</span> + c + <span class="string">&#x27;*&#x27;</span></span><br><span class="line">                <span class="comment"># print(res)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res+=c</span><br><span class="line">        res=res.replace(<span class="string">&#x27;**&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="comment"># 在打印输出的阶段再把特殊字符更正回来</span></span><br><span class="line">        <span class="built_in">print</span>(res.replace(<span class="string">&#x27;熊锐&#x27;</span>,<span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h1 id="HJ107-求解立方根"><a href="#HJ107-求解立方根" class="headerlink" title="HJ107-求解立方根"></a>HJ107-求解立方根</h1><p>采用下面的几种方法：</p>
<h2 id="采用二分法："><a href="#采用二分法：" class="headerlink" title="采用二分法："></a>采用二分法：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a=<span class="built_in">float</span>(<span class="built_in">input</span>()) <span class="comment"># 获取输入的实数a</span></span><br><span class="line">        e=<span class="number">0.0001</span> <span class="comment"># 设定一个精度值</span></span><br><span class="line">        low=<span class="built_in">min</span>(-<span class="number">1.0</span>,a)</span><br><span class="line">        high=<span class="built_in">max</span>(<span class="number">1.0</span>,a)</span><br><span class="line">        ans=(low+high)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">abs</span>(ans**<span class="number">3</span>-a)&gt;=e:</span><br><span class="line">            <span class="comment"># 如果ans**3&lt;a，说明此时的值偏小</span></span><br><span class="line">            <span class="keyword">if</span> ans**<span class="number">3</span>&lt;a:</span><br><span class="line">                low=ans</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high=ans</span><br><span class="line">            ans=(low+high)/<span class="number">2</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;:.1f&#125;&#x27;</span>.<span class="built_in">format</span>(ans))  </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>#采用牛顿迭代法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a=<span class="built_in">float</span>(<span class="built_in">input</span>()) <span class="comment"># 获取输入的实数a</span></span><br><span class="line">        e=<span class="number">0.0001</span> <span class="comment"># 设定一个精度值</span></span><br><span class="line">        <span class="comment"># 用最初始的值作为初始值</span></span><br><span class="line">        last=a</span><br><span class="line">        <span class="comment"># 用迭代公式求解下一个更接近的值</span></span><br><span class="line">        <span class="comment"># 公式是通过泰勒展开式取前两项展开得来的</span></span><br><span class="line">        ans=last-((last**<span class="number">3</span>-a)/(<span class="number">3</span>*last**<span class="number">2</span>))</span><br><span class="line">        <span class="comment"># 当ans**3-last的精度值不满足要求的时候,进行循环迭代,使其满足相应的精度要求</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">abs</span>(ans-last)&gt;=e:</span><br><span class="line">            last=ans</span><br><span class="line">            ans=last-((last**<span class="number">3</span>-a)/(<span class="number">3</span>*last**<span class="number">2</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;:.1f&#125;&#x27;</span>.<span class="built_in">format</span>(ans))  </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="采用库函数"><a href="#采用库函数" class="headerlink" title="采用库函数"></a>采用库函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a=<span class="built_in">float</span>(<span class="built_in">input</span>())</span><br><span class="line">        <span class="keyword">if</span> a&gt;=<span class="number">0</span>:</span><br><span class="line">            res=<span class="string">&#x27;&#123;:.1f&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">pow</span>(a,<span class="number">1</span>/<span class="number">3</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res=<span class="string">&#x27;&#123;:.1f&#125;&#x27;</span>.<span class="built_in">format</span>(-<span class="built_in">pow</span>(-a,<span class="number">1</span>/<span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>在用库函数的时候，看到别处的题解，觉得非常好，可以将代码进行一些相应的简化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a=<span class="built_in">float</span>(<span class="built_in">input</span>())</span><br><span class="line">        s=-<span class="number">1</span> <span class="keyword">if</span> a&lt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        res=<span class="string">&#x27;&#123;:.1f&#125;&#x27;</span>.<span class="built_in">format</span>(s*<span class="built_in">pow</span>(s*a,<span class="number">1</span>/<span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/07/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E5%9F%BA%E7%A1%80%E9%A2%98%E5%80%BC%E5%BE%97%E8%AE%B0%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%88%E5%80%BC%E5%BE%97%E5%B0%B1%E6%95%B4%E7%90%86%EF%BC%89/" data-id="claqu8zzz002xiwtkcxske1qa" data-title="牛客网刷基础题值得记录的一些问题（值得就整理）" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" rel="tag">python知识小记</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/03/08/%E5%85%B3%E4%BA%8E%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A1%8D%E7%94%9F%E7%9A%84%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%B8%80(important)/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          关于栈与队列基础知识及相关衍生的题目汇总一(important)
        
      </div>
    </a>
  
  
    <a href="/2022/03/06/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A1%8D%E7%94%9F%E7%9A%84%E9%A2%98%E7%9B%AE/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">链表的基础以及相关衍生的题目</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gridea/" rel="tag">Gridea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" rel="tag">python知识小记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99%E7%9A%84%E5%B0%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/" rel="tag">工作之余的小的编程小知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" rel="tag">算法专栏（用python注写）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0/" rel="tag">读书摘记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Gridea/" style="font-size: 10px;">Gridea</a> <a href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" style="font-size: 13.33px;">python知识小记</a> <a href="/tags/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99%E7%9A%84%E5%B0%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/" style="font-size: 16.67px;">工作之余的小的编程小知识</a> <a href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" style="font-size: 20px;">算法专栏（用python注写）</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0/" style="font-size: 10px;">读书摘记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/21/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2022/11/12/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%BA%94%E7%9A%84%E5%90%8C%E6%AD%A5/">搭建自己的博客并进行相应的同步</a>
          </li>
        
          <li>
            <a href="/2022/10/03/vs%20code%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%B7%A5%E5%85%B7%E5%8C%85/">关于vs code导入本地工具包和消除&#39;import [module] could not be resolved in pylance&#39;</a>
          </li>
        
          <li>
            <a href="/2022/09/25/%E5%85%B3%E4%BA%8Ematalab%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">关于matalab的数据分析</a>
          </li>
        
          <li>
            <a href="/2022/07/30/%E5%85%B3%E4%BA%8Epython%E7%88%AC%E8%99%AB%E4%B8%80%E7%82%B9%E5%B0%8F%E7%9A%84%E6%95%B4%E7%90%86/">关于python爬虫一点小的整理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>