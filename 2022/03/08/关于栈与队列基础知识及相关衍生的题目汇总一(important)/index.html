<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>
        bear的生活随笔
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico" />
    <link rel="stylesheet" href="/css/style/github.min.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <div class="container">
        <div class="header">
    <!-- <div class="logo">
        <a href="/">bear的生活随笔</a>
    </div> -->
    <div class="logo">
        <img src="/images/logo.png" alt="Logo">
    </div>
    <div class="nav">
        <ul class="menu">
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">
                        Home
                    </a>
                </li>
            
                <li class="menu-item">
                    <a target="_blank" rel="noopener" href="https://github.com/loveminimal" class="menu-item-link">
                        Github
                    </a>
                </li>
                
        </ul>
    </div>
</div>
        <div class="article">
    <!-- <div class="article-title">
        <h2>
            关于栈与队列基础知识及相关衍生的题目汇总一(important)
        </h2>
    </div> -->
    <div class="article-meta">
        <div class="article-date">
            <i class="fas fa-edit"></i>
            2022/03/08 Tue 10:46&nbsp;&nbsp;&nbsp;
            <span class="just-a-temp"><span>
            <i class="fas fa-redo"></i>
            2022/06/06 Mon 21:32
        </div>
    </div>
    <div class="article-content">
        <p>栈与队列通常放到一起来学习，也是基础中的基础，概念一定要十分的清晰明了</p>
<h1 id="栈是先进后出的线性表"><a href="#栈是先进后出的线性表" class="headerlink" title="栈是先进后出的线性表"></a>栈是先进后出的线性表</h1><p>s.top():获取栈底元素<br>s.empty():判断栈是否为空<br>s.push():往栈中添加一个元素<br>s.pop():栈顶元素的弹出<br>s.size()：获取栈的长度</p>
<hr>
<h1 id="构建一个栈（基础）"><a href="#构建一个栈（基础）" class="headerlink" title="构建一个栈（基础）"></a>构建一个栈（基础）</h1><pre><code class="python">class Stack(object):
    #定义初始化方法
    def __init__(self):
        #初始化一个空列表
        self.__list=[]

    # 入栈和出栈的函数体现了先进后出的理念
    # 入栈：将一个元素加入栈顶
    def push(self,item):
        self.__list.append(item)

    #出栈：将一个元素从栈顶删除
    def pop(self):
        return self.__list.pop()

    #返回栈顶元素
    def peek(self):
        return self.__list[len(self.__list)-1]

    #判断栈是否为空
    def is_empty(self):
        return self.__list == []

    #计算栈的大小
    def size(self):
        return len(self.__list)

if __name__ == &#39;__main__&#39;:
    stack=Stack()
    print(&#39;是否空栈吗&#39;,stack.is_empty())
    #压栈
    stack.push(1)
    stack.push(2)
    stack.push(3)
    stack.push(4)
    print(&#39;是否空栈吗&#39;, stack.is_empty())
    print(&#39;栈的长度：&#39;,stack.size())
    #弹出
    print(stack.pop())
    print(stack.pop())
    print(stack.pop())
    print(stack.pop())
    # 打印结果
    是否空栈吗 True
是否空栈吗 False
栈的长度： 4
4
3
2
1
</code></pre>
<h1 id="队列是先进先出的线性表"><a href="#队列是先进先出的线性表" class="headerlink" title="队列是先进先出的线性表"></a>队列是先进先出的线性表</h1><p>q.front():获取队列的队头元素<br>q.push():在队尾添加一个新的元素进队列中<br>q.pop()：把我们的队头元素进行弹出<br>q.empty()：判断我们的队列是否为空<br>q.size():去求队列中的元素的个数</p>
<h1 id="python标准库中包含四种队列："><a href="#python标准库中包含四种队列：" class="headerlink" title="python标准库中包含四种队列："></a>python标准库中包含四种队列：</h1><ol>
<li>queue.Queue</li>
<li>asyncio.Queue </li>
<li>multiprocessing.Queue</li>
<li>collections.deque</li>
</ol>
<p>下面的这这张图很好的展示了这样的一个过程，它们的方式确实不太一样，不要弄混淆了<br><img src="https://runnerxr.github.io//post-images/1653788994859.png"></p>
<h1 id="构建一个单端队列（基础必须掌握-顺序存储）"><a href="#构建一个单端队列（基础必须掌握-顺序存储）" class="headerlink" title="构建一个单端队列（基础必须掌握-顺序存储）"></a>构建一个单端队列（基础必须掌握-顺序存储）</h1><h2 id="第一种创建方式：用列表创建"><a href="#第一种创建方式：用列表创建" class="headerlink" title="第一种创建方式：用列表创建"></a>第一种创建方式：用列表创建</h2><p>这个知识点是自己必须要掌握的点：将<strong>列表的末尾</strong>当作<strong>队列的头部</strong>，<strong>队列的尾部</strong>是列表<strong>下标为0</strong>的位置，主要实现以下几个函数：<strong>进队</strong>、<strong>出队</strong>、<strong>判断是否为空</strong>、<strong>计算队列的长度</strong></p>
<pre><code class="python">class Queue:
    def __init__(self):
        self.queue=[]
    
    # 进队和出队的函数体现了队列的先进先出的特点
    # 进队：将元素添加到队尾
    def enqueue(self,item):
        self.queue.insert(0,item)  

    # 出队：将元素从队头删除
    def dequeue(self):
        self.queue.pop() 

    # 判断队列是否为空
    def is_empty(self):
        return self.queue==[]

    # 计算队列的大小
    def size(self):
        return len(self.queue)
    
if __name__ == &#39;__main__&#39;:
    queue=Queue()
    queue.enqueue(10)
    queue.enqueue(20)
    queue.enqueue(30)
    #判断队列是否空
    print(queue.is_empty())
    print(&#39;队列大小&#39;,queue.size())
    print(&#39;-----出队---------&#39;)
    print(queue.dequeue())
    print(queue.dequeue())
    print(queue.dequeue())
# 打印结果如下：
False
队列大小 3
-----出队---------
None
None
None
</code></pre>
<h2 id="第二种创建方式：python中的模块的方式"><a href="#第二种创建方式：python中的模块的方式" class="headerlink" title="第二种创建方式：python中的模块的方式"></a>第二种创建方式：python中的模块的方式</h2><p>略</p>
<h1 id="构建一个双端队列"><a href="#构建一个双端队列" class="headerlink" title="构建一个双端队列"></a>构建一个双端队列</h1><p>这里既然讲到了双端队列的问题，就做一点相应的知识整理：<br>deque是双端队列（double-ended queue）的缩写，由于两端都能编辑(<strong>有两个头部和尾部</strong>，可以在<strong>双端</strong>进行数据的<strong>插入</strong>和<strong>删除</strong>)，deque既可以用来实现栈（stack）也可以用来实现队列（queue），栈与队列的完美结合。<br>deque支持丰富的操作方法，主要方法如图：<img src="https://runnerxr.github.io//post-images/1646804844746.png"><br>相比于list实现的队列，deque实现拥有更低的时间和空间复杂度。<br>list实现在出队（pop）和插入（insert）时的空间复杂度大约为O(n)，<br>deque在出队（pop）和入队（append）时的时间复杂度是O(1)。<br>细部剩余知识详见：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lincappu/p/12890765.html">https://www.cnblogs.com/lincappu/p/12890765.html</a><br><a target="_blank" rel="noopener" href="https://www.jb51.net/article/183382.htm">https://www.jb51.net/article/183382.htm</a>  </p>
<h2 id="第一种创建方式：用python内置的双端队列模块"><a href="#第一种创建方式：用python内置的双端队列模块" class="headerlink" title="第一种创建方式：用python内置的双端队列模块"></a>第一种创建方式：用python内置的双端队列模块</h2><p><strong>创建双向对队列：</strong></p>
<pre><code class="python">import collections
d = collections.deque()
</code></pre>
<p><strong>append(往右边添加一个元素)</strong></p>
<pre><code class="python">import collections
d = collections.deque()
d.append(1)
d.append(2)
print(d)
# 打印结果
deque([1, 2])
</code></pre>
<p><strong>appendleft（往左边添加一个元素）</strong></p>
<pre><code class="python">import collections
d = collections.deque()
d.append(1)
d.appendleft(2)
print(d)
# 打印结果
deque([2, 1])
</code></pre>
<p><strong>clear(清空队列)</strong></p>
<pre><code class="python">import collections
d=collections.deque()
d.append(1)
d.clear()
print(d)
# 打印结果
deque([])
</code></pre>
<p><strong>copy(浅拷贝)</strong></p>
<pre><code class="python">import collections
d=collections.deque()
d.append(1)
new_d=d.copy()
print(new_d)
# 打印结果
deque([1])
</code></pre>
<p><strong>count(返回指定元素的出现次数)</strong></p>
<pre><code class="python">import collections
d=collections.deque()
d.append(1)
d.append(1)
print(d.count(1))
# 打印结果
2
</code></pre>
<h2 id="第二种创建方式：使用列表来创建"><a href="#第二种创建方式：使用列表来创建" class="headerlink" title="第二种创建方式：使用列表来创建"></a>第二种创建方式：使用列表来创建</h2><p>将<strong>列表的末尾</strong>作为双端队列的<strong>前端</strong>，列表中<strong>下标索引为0</strong>的位置作为双端队列的<strong>后端</strong>（和列表的模拟十分相似）</p>
<pre><code class="python"># 用列表来实现一个双端队列
class Deque:
    # 构造方法创建一个空列表
    def __init__(self):
        self.deque=[]
    
    # 向双端队列的两端添加元素
    # 通过append()向列表的末尾添加（即向双端队列的前端添加）
    # 通过insert()向列表的索引为0的位置添加（即向双端队列的后端添加）
    def addFront(self,item):
        self.deque.append(item)
    def addRear(self,item):
        self.deque.insert(0,item)
    
    # 通过pop()移除列表的末尾元素（即删除前端元素）
    # 通过pop(0)移除列表的索引为0的元素（即删除后端元素）
    def deleteFront(self):
        return self.deque.pop()
    def deleteRear(self):
        return self.deque.pop(0)
    
    # 返回双端队列的前端元素
    # 返回双端队列的后端元素
    def displayFront(self):
        return self.deque[len(self.deque)-1]
    def displayRear(self):
        return self.deque[0]

    # 判断双端队列是否为空
    def is_empty(self):
        return self.deque==[]
    
    # 返回双端队列的数目
    def size(self):
        return len(self.deque)
    

# 测试如下：
# 创建一个空的双端队列，即创建一个对象，对象名称=类名称()
d=Deque()
print(d.is_empty()) # 判断双端队列是否为空
print(d.size())  # 统计双端队列的长度
d.addFront(123)  # 向双端队列的前端添加元素
d.addFront(456)
d.addRear(&#39;xr&#39;)  # 向双端队列的后端添加元素
d.addRear(&#39;1996-07-26&#39;) 
print(d.size())
print(d.displayFront())
print(d.displayRear())
print(&#39;-------&#39;)
d.deleteFront()  # 删除双端队列的前端元素
print(d.size())
print(d.displayFront())
d.deleteRear()  # 删除双端队列的后端元素
print(d.size())
print(d.displayRear())
print(d.is_empty())
# 打印结果如下：
True
0
4
456       
1996-07-26
-------   
3
123       
2
xr
False
</code></pre>
<p>以下为主要的几道题目：</p>
<ol>
<li>leetcoad155-最小栈（基础题）</li>
<li>leetcoad232-用两个栈实现队列（基础题）</li>
<li>leetcoad225-用队列实现栈（基础题）</li>
<li>leetcoad42-接雨水</li>
<li></li>
</ol>
<h1 id="leetcoad155-最小栈（easy-值得好好回顾）"><a href="#leetcoad155-最小栈（easy-值得好好回顾）" class="headerlink" title="leetcoad155-最小栈（easy-值得好好回顾）"></a>leetcoad155-最小栈（easy-值得好好回顾）</h1><ol>
<li>需要在常数时间内找到最小的元素，不能够使用遍历，遍历是O(n)级别的，通过辅助栈进行解决（空间换时间）:这里的理解非常到位，值得自己去整理与反思</li>
<li>定义好两个栈<ol>
<li>一个栈叫Stack,负责栈的正常操作</li>
<li>一个栈是min_stack，负责获取 stack 中的最小值(思路的重要性：遍历stack中的所有元素，把升序的数字都删除掉，留下一个从栈底到栈顶降序的栈)</li>
</ol>
</li>
<li>定义一个push函数:（针对普通栈和辅助栈都要执行：普通栈直接加入,最小栈看是不是比原来的元素更下再选择加入）</li>
<li>定义一个pop函数：（针对普通栈和辅助栈都要执行：普通栈直接弹出，最小栈当顶元素和普通栈相等的时候才会弹出）</li>
<li>定义一个top函数：在普通栈中操作，最后一个元素</li>
<li>定义getmim函数：在最小栈中操作，最后一个元素</li>
</ol>
<pre><code class="python">class MinStack:

    def __init__(self):
        &quot;&quot;&quot;
        initialize your data structure here.
        &quot;&quot;&quot;
        # 定义好两个栈，一个栈用作正常操作，一个栈用作获取栈中的最小值
        # stack普通栈，负责栈的正常进出
        self.stack=[]
        # min_stack：用栈顶来保存所有元素的最小值，负责获取和存储stack中的最小值
        self.min_stack=[]

    # 入栈
    def push(self, x: int) -&gt; None:
        # 把先添加的元素放入到stack中
        self.stack.append(x)
        # 判断min_stack是否为空，如果为空，把新的元素添加进来
        if self.min_stack:
            # 获取min_stack的栈顶元素
            top = self.min_stack[-1]
            # 是否加入的元素是小于栈顶元素的
            if x&lt;=top:
                self.min_stack.append(x)
        # 如果min_stack为空的话，直接把元素添加进去。
        else:
            self.min_stack.append(x)

    # 出栈
    def pop(self) -&gt; None:
        # 记录此时出栈的元素
        x = self.stack[-1]

        # stack执行出栈操作
        self.stack.pop()

        # stack中的元素出栈，min_stack同步进行
        # 获取min_stack的栈顶元素
        top=self.min_stack[-1]
        #判断top 是否与stack中弹出的的元素相等，如果相等，需要把min_stack中的栈顶元素一并出栈
        if top ==x:
            self.min_stack.pop()

    # 获取栈顶元素
    def top(self) -&gt; int:
        return self.stack[-1]

    # 获取栈中的最小元素
    def min(self) -&gt; int:
        return self.min_stack[-1]
</code></pre>
<h1 id="leetcoad232-用两个栈实现队列"><a href="#leetcoad232-用两个栈实现队列" class="headerlink" title="leetcoad232-用两个栈实现队列"></a>leetcoad232-用两个栈实现队列</h1><p>这里的关键点我认为有以下几点：（看过动画之后一切都十分的明白了）</p>
<ol>
<li>一个栈负责压入元素，一个栈负责弹出元素（返回队首元素）</li>
<li>压入元素很简单，但弹出元素就很讲究（弹出的过程中，如果不为空直接弹出元素，如果为空，一定要让进入的栈的全部元素都转移到弹出栈中再弹出元素）<ol>
<li>如果负责弹出的栈有元素，直接弹出</li>
<li>如果发现进入的栈不为空，就不停的将一个栈的元素转移到另一个栈中</li>
</ol>
</li>
</ol>
<pre><code class="python">class MyQueue:
    def __init__(self):
        # 定义两个栈
        self.A,self.B=[],[]

    # 将元素推到队列的末尾
    def push(self, x: int) -&gt; None:
        self.A.append(x)
 
    # 移除队首元素
    def pop(self) -&gt; int:
        # 如果栈B为空
        if not self.B:
            while self.A:
                self.B.append(self.A.pop())
        return self.B.pop()
    
    # 返回队列开头的元素(pop和peek的区别，一个是删除，一个是返回)
    def peek(self) -&gt; int:
        if not self.B:
            while self.A:
                self.B.append(self.A.pop())
        return self.B[-1]


    # 定义一个empy函数，如果为空返回true，如果不为空就返回false
    def empty(self) -&gt; bool:
        # 判断是否两个栈都为空
        if not self.A and not self.B:
            return True
        else:
            return False
</code></pre>
<pre><code class="python"># 牛客网上也有相同的题
# -*- coding:utf-8 -*-
class Solution:
    def __init__(self):
        # stack1负责进栈
        # stack2负责出栈
        self.stack1 = []
        self.stack2 = []

    def push(self, node):
        # write code here
        # 将元素加入stack1中，表示队列的入队操作
        self.stack1.append(node)
        # print(self.stack1)
        return

    def pop(self):
        # return xx
        # 将stack2中的元素进行弹出，构成队列的队头元素（先进先出）
        # 如果stack2空的，只要stack1有元素，stack2就不断添加stack1弹出来的元素
        # 入股哟stack2不是空的，直接弹出就行
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
                #print(self.stack1)
                #print(self.stack2)
        return self.stack2.pop()
</code></pre>
<h1 id="leetcoad225-用队列实现栈"><a href="#leetcoad225-用队列实现栈" class="headerlink" title="leetcoad225-用队列实现栈"></a>leetcoad225-用队列实现栈</h1><p>请你仅使用<strong>两个队列</strong>实现一个<strong>后入先出（LIFO）的栈</strong>，并支持<strong>普通栈的全部四种操作</strong>（push、top、pop 和 empty）。<br>实现 MyStack 类：<br>    * void push(int x) 将元素 x 压入栈顶。<br>    * int pop() 移除并返回栈顶元素。<br>    * int top() 返回栈顶元素。<br>    * boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p>
<p>  注意：<br>    * 你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。<br>    * 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p>
<h1 id="leetcoad42-接雨水"><a href="#leetcoad42-接雨水" class="headerlink" title="leetcoad42-接雨水"></a>leetcoad42-接雨水</h1><p>题目描述：给定** n 个非负整数<strong>表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，</strong>下雨之后能接多少雨水**。<br>示例：<br><img src="https://runnerxr.github.io//post-images/1653317536073.png"><br>输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。<br>思路：这道题用到了单调递增栈的思想（之所以放在这里就是这个原因，题目本身并不简单，但是重在里面的思维的点）</p>

    </div>

    <div class="totop">ToTOP</div>
</div>
        <div class="footer">
    <a href="#">
        2018 <i class="fab fa-studiovinari"></i> bear <i class="fas fa-angle-double-up"></i>
    </a>
</div>


<script src="/js/totop.js"></script>


<script src="/js/search.js"></script>

    </div>
</body>

</html>