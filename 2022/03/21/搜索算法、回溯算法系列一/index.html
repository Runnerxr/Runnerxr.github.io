<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>搜索算法、回溯算法系列一 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="深度优先搜索（Depth-First-Search,DFS）类似于树的先序遍历，这种搜素算法尽可能深的去搜索一个图参考链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;subsets&#x2F;solution&#x2F;c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-&#x2F;https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;perm">
<meta property="og:type" content="article">
<meta property="og:title" content="搜索算法、回溯算法系列一">
<meta property="og:url" content="http://example.com/2022/03/21/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B8%80/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="深度优先搜索（Depth-First-Search,DFS）类似于树的先序遍历，这种搜素算法尽可能深的去搜索一个图参考链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;subsets&#x2F;solution&#x2F;c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-&#x2F;https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;perm">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1651335354445.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1651335481424.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1651335984684.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1651336156364.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1651411102787.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1651411240693.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1650609416171.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1649694805789.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1652361154485.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1652362914174.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1652363742876.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1652364640585.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1652364808224.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1652364824518.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1651336911841.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1651337009639.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1651337042332.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1651415586877.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1651412531168.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1651338150722.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1651338329999.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1651338364547.png">
<meta property="og:image" content="https://runnerxr.github.io/post-images/1651414572252.png">
<meta property="article:published_time" content="2022-03-21T01:50:27.000Z">
<meta property="article:modified_time" content="2022-11-16T15:29:30.923Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://runnerxr.github.io/post-images/1651335354445.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-搜索算法、回溯算法系列一" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/21/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B8%80/" class="article-date">
  <time class="dt-published" datetime="2022-03-21T01:50:27.000Z" itemprop="datePublished">2022-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      搜索算法、回溯算法系列一
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="深度优先搜索（Depth-First-Search-DFS）"><a href="#深度优先搜索（Depth-First-Search-DFS）" class="headerlink" title="深度优先搜索（Depth-First-Search,DFS）"></a>深度优先搜索（Depth-First-Search,DFS）</h1><p>类似于树的先序遍历，这种搜素算法尽可能深的去搜索一个图<br>参考链接：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/">https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/</a></p>
<h2 id="DFS和回溯算法的区别："><a href="#DFS和回溯算法的区别：" class="headerlink" title="DFS和回溯算法的区别："></a>DFS和回溯算法的区别：</h2><p>DFS:一种用于遍历或搜索树或图的算法，尽可能深的搜索树的分支，当结点 v 的所在边都己被探寻过，搜索将 回溯 到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。<br>回溯算法：采用试错的思想，尝试分步的去解决问题，在分步解决的过程中，当尝试发现有的分步答案不能得到有效的正确的解答的时候，<strong>取消上一步甚至上几步的计算</strong>，再通过其他可能的分步解答再次尝试寻找问题的答案。反复重复上诉过程后会有两种情况：</p>
<ol>
<li>找到一个可能存在的正确的答案</li>
<li>再尝试了所有可能的分步办法后宣告该问题没有答案。</li>
</ol>
<p>DFS 是一个劲的往某一个方向搜索，而回溯算法建立在 DFS 基础之上的，但不同的是在搜索过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索。因此回溯算法与 DFS 的区别就是有无状态重置，它强调了回退操作对于搜素的合理性，DFS强调一种遍历的思想。（广度优先遍历是另外的一种思想）</p>
<h2 id="与动态规划的区别："><a href="#与动态规划的区别：" class="headerlink" title="与动态规划的区别："></a>与动态规划的区别：</h2><p>共同点：用于求解多阶段的决策问题</p>
<ol>
<li>求解一个问题分为很多的步骤（阶段）</li>
<li>每一个步骤（阶段）可以有多种选择<br>不同点：</li>
<li>动态规划只是要求我们评估最优解是多少，最优解对应的具体解是什么并不要求，很适合应用于评估一个方案的效果</li>
<li>回溯算法可以得到所有方案（最优解含在内），本质是一种遍历算法，时间复杂度很高</li>
</ol>
<h2 id="何时使用回溯算法："><a href="#何时使用回溯算法：" class="headerlink" title="何时使用回溯算法："></a>何时使用回溯算法：</h2><p>当问题需要 “回头”，以此来查找出所有的解的时候，使用回溯算法。即<strong>满足结束条件或者发现不是正确路径的时候(走不通)，要撤销选择</strong>，<strong>回退到上一个状态，继续尝试，直到找出所有解为止</strong>。一般题目中看到需要求所有可能的结果，而不是结果个数的时候，我们就需要用暴力搜索所有的可行解，可以采用回溯法。</p>
<h2 id="递归函数的下面就是回溯的逻辑"><a href="#递归函数的下面就是回溯的逻辑" class="headerlink" title="递归函数的下面就是回溯的逻辑"></a>递归函数的下面就是回溯的逻辑</h2><p>树具有天然的递归：一般这种回溯的题目都是用的树来理解十分的清晰<br><strong>树的宽度用一个for循环来遍历，树的深度就是用的递归的性质</strong></p>
<h2 id="对于剪枝的理解："><a href="#对于剪枝的理解：" class="headerlink" title="对于剪枝的理解："></a>对于剪枝的理解：</h2><p>回溯算法的时间复杂度很高，在遍历的时候如果 能提前知道这一条分支不能搜索到满意的结果，就可以提前结束，加快搜索速度，有时候也需要做一些预处理（排序）才能达到剪枝的目的，预处理也耗时间，但是能够剪枝节约的时间更多。本质上是一种技巧，需要根据不同问题的场景采用不同的剪枝策略，需要在做题的过程中不断的进行总结。由于时间复杂度高，能够用空间换时间就尽量的换。</p>
<h2 id="一般来说回溯算法的思考步骤如下："><a href="#一般来说回溯算法的思考步骤如下：" class="headerlink" title="一般来说回溯算法的思考步骤如下："></a>一般来说回溯算法的思考步骤如下：</h2><p>（结合子集的题目来重点分析将大部分回溯算法的题目掌握清楚，当作一套模板背一下）</p>
<ol>
<li>画出递归树，找到状态变量（当画出树形图之后，整个思路就会一目了然，回溯函数的参数）：不断的去思考<ol>
<li>分支如何产生</li>
<li>题目需要的解在哪里？是在<strong>叶子节点</strong>，还是在<strong>非叶子节点</strong>，还是<strong>从根节点到叶子节点的路径</strong>？</li>
<li><strong>哪些搜索会产生不需要的解</strong>？产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？</li>
</ol>
</li>
<li>寻找结束条件，由于回溯算法是<strong>借助递归</strong>实现的，所以就是需要去寻找递归的终止条件（当前想要遍历的元素操作数组的长度）</li>
<li>确定选择列表，即需要把什么数据存储到结果里面</li>
<li>判断是否需要剪枝，去判断此时存储的数据是否之前已经被储存过（子集II,组合总和II,除去一些不符合题目要求的数，一些比较垃圾的逻辑，需要提前一步剪短）</li>
<li>做出选择，<strong>递归调用该函数，进入下一层继续搜索</strong></li>
<li><strong>撤销选择</strong>，回到上一层的状态（5和6就是通过两个函数来执行选与不选的操作的）</li>
</ol>
<h2 id="回溯算法的模板"><a href="#回溯算法的模板" class="headerlink" title="回溯算法的模板"></a>回溯算法的模板</h2><p>（参考东哥的算法小抄的理解）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ressult=[]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">路径，选择列表</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.append(路径)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrace(路径，选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>
<p>根据书上的额一些讲解，整理一些相对比较重点的点：</p>
<ol>
<li>核心就是for 循环里面的递归，<strong>在递归调用前做选择，在递归调用之后做撤销选择</strong></li>
<li>定义的回溯函数就像时一个指针，在决策树上进行遍历，同时正确维护每个节点的属性，每当走到树的底层，其”路径”就是一个子集（以子集举例）</li>
<li>前序遍历的代码：在进入某个节点之前的那个时间点执行；后序遍历的代码：在离开某个节点之后的那个时间点执行</li>
<li>做选择：从选择列表中拿出一个作为选择，并将它加入路径之中</li>
<li>撤销选择：从路径中拿出一个选择，将它恢复到“选择列表中”</li>
</ol>
<p>在写一遍框架模板：(加深印象)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">    <span class="comment"># 做选择</span></span><br><span class="line">    将该选择从列表中移除</span><br><span class="line">    路径.append(选择)</span><br><span class="line">    backtarce(路径，选择)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    路径.pop(选择)</span><br><span class="line">    将该选择恢复到选择列表中</span><br></pre></td></tr></table></figure>
<p>这里既然已经谈到了回溯的算法（DFS）,也顺便把广度优先搜索的也整理一下，相应的思想要做一些区分的工作，而且层序遍历、滑动窗口的最大值这两道题也用到了BSF的思想还有二叉树的最小高度<br>主要是想把BFS的框架整理一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 未完待续</span></span><br><span class="line"><span class="comment"># 计算从起点start到终点tareget的最短距离</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">start,target</span>):</span><br><span class="line">    q=queqe()  <span class="comment"># 核心数据结构</span></span><br><span class="line">    visted=[]    <span class="comment">#避免走回头路</span></span><br><span class="line">    <span class="comment"># 将起点加入队列中</span></span><br><span class="line">    q.add(start)</span><br><span class="line">    visited.append(start)</span><br><span class="line">    step = <span class="number">0</span> <span class="comment"># 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> q <span class="keyword">not</span> empty:</span><br><span class="line">        n=<span class="built_in">len</span>(q)</span><br><span class="line">        <span class="comment"># 将当前队列中的所有结点向四周扩散</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cur=</span><br></pre></td></tr></table></figure>
<p>以下为回溯法的一些题目，这里先做一些汇总如下：主要是做了这么多的题目要找到相应的一些套路是十分重要的，多做总结，多归类才能进步的更快，一点一滴的要整理清楚。</p>
<h1 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h1><ol>
<li>leetcoad200-岛屿数量（很经典，值得多做，而且里面的方法也是值得在很多题目里面借鉴的）</li>
</ol>
<h1 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h1><ol>
<li>leetcoad78-子集（*）</li>
<li>leetcoad90-子集II（**）：需要排序，然后还要剪枝</li>
</ol>
<h1 id="组合问题："><a href="#组合问题：" class="headerlink" title="组合问题："></a>组合问题：</h1><ol>
<li>leetcoad77-组合（*递归出口地条件比较特殊）</li>
<li>leetcoad39-组合总和（**递归出口地条件有两个：目标值小于和目标值等于0，后续地一切元素地选择只能从函数地参数开始）</li>
<li>leetcoad40-组合总数II（***在组合总和地基础上其他条件不变，附加需要对元素先排序，然后再剪枝）</li>
<li>leetcoad216-组合总和III（暂时未涉及）</li>
</ol>
<h1 id="排列问题："><a href="#排列问题：" class="headerlink" title="排列问题："></a>排列问题：</h1><ol>
<li>leetcoad46-全排列</li>
<li>leetcoad47-全排列II</li>
</ol>
<h1 id="leetcoad200-岛屿数量"><a href="#leetcoad200-岛屿数量" class="headerlink" title="leetcoad200-岛屿数量(****)"></a>leetcoad200-岛屿数量(****)</h1><p>非常好的一道题，值得认真反复的回味清楚，而且可能还有其他的一些解法什么的，都是需要理解的，也是很基础的DFS的题目，是一道很单纯的题目，每次做一遍都会有新的发现,做个10几遍都不为过。<br>解题思路：</p>
<ol>
<li>创建一个同样大小的二维网格mark(初始化每个都是0)：用这个网格来统计二维数组中的岛屿数量的</li>
<li>每次判断网格是1的时候就记录下来，开始按照上、左、下、右的顺序去搜索当前的网格</li>
<li>0代表当前网格没有被访问，1代表当前网格被访问了</li>
<li>遍历二维网格，对每行、每列进行一个访问<ol>
<li>如果发现（i，j）是没有标记的陆地</li>
<li>对该位置进行搜索，调用DFS函数</li>
</ol>
</li>
<li>DFS函数的书写：<ol>
<li>先找一个已经遍历的</li>
<li>定义方向组</li>
<li>通过for循环来找到相邻的四个方向<ol>
<li>如果新的方向发生了越界（超出了数组边界）<ol>
<li>跳出循环</li>
</ol>
</li>
<li>如果发现新的位置是陆地，并且没有被标记过<ol>
<li>递归搜索函数发现新的位置（用递归的时候就要注意将标记改为1，防止被重复的访问，找到一处就标记一处）</li>
<li>搜索完之后，岛屿数量+1</li>
<li>每次完成一次搜索，都会往前回退（原路返回，回退一步就扩大岛的面积，不断扩大，直至形成一个孤岛）<br><img src="https://runnerxr.github.io/post-images/1651335354445.png"><br><img src="https://runnerxr.github.io/post-images/1651335481424.png"><br><img src="https://runnerxr.github.io/post-images/1651335984684.png"><br><img src="https://runnerxr.github.io/post-images/1651336156364.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># count 代表岛屿数量</span></span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="comment"># mark 标记已经搜索的位置，大小与 grid 一致(这里需要理解，这里借助的是另外的数组，没有更改原数组的值，有些题解中，将原来为1的值经过搜索后改为0，直到搜索后不再发现0为止)</span></span><br><span class="line">        <span class="comment"># mark 初始化为 0，代表当前网格没有被访问</span></span><br><span class="line">        mark=[[<span class="number">0</span>]*<span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid))]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历 grid，对每行每列都进行访问</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[i])):</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果发现位置 （i ，j）是没有标记的陆地(是陆地，并且没有被搜索过)</span></span><br><span class="line">                <span class="keyword">if</span> grid[i][j] ==<span class="string">&quot;1&quot;</span><span class="keyword">and</span> mark[i][j]==<span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 对该位置进行搜索，看看有没有其他的陆地和它共同的组成岛屿</span></span><br><span class="line">                    <span class="comment"># 调用私有函数</span></span><br><span class="line">                    self.DFS(grid,i,j,mark)</span><br><span class="line">                    <span class="comment"># 对 （i ，j）完成搜索后，岛屿数量加 1</span></span><br><span class="line">                    count +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将 grid 中与 x ，y 相连的位置在 mark 中进行标记</span></span><br><span class="line">    <span class="comment"># x表示行坐标，y表示列坐标</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">self,grid,x,y,mark: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) :</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前搜索位置在 mark 中标记为 1 ，代表已经遍历了</span></span><br><span class="line">        mark[x][y]=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 循环遍历当前位置的上、下、左、右四个方向，这里写成了循环的方式，有的地方是分别按照4个敌对来写的</span></span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> ((-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>)):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># newX 代表新的行</span></span><br><span class="line">            newX=dx + x</span><br><span class="line"></span><br><span class="line">            <span class="comment"># newY 代表新的列</span></span><br><span class="line">            newY = dy + y</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果新的位置超出了数组边界</span></span><br><span class="line">            <span class="comment"># x坐标超出左右边界，y坐标超出上下边界</span></span><br><span class="line">            <span class="keyword">if</span> newX&lt; <span class="number">0</span> <span class="keyword">or</span> newX&gt;=<span class="built_in">len</span>(mark) <span class="keyword">or</span> newY &lt;<span class="number">0</span> <span class="keyword">or</span> newY &gt;=<span class="built_in">len</span>(mark[newX]):</span><br><span class="line">                <span class="comment"># 跳出该位置</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果发现新位置是陆地，并且没有被标记过</span></span><br><span class="line">            <span class="keyword">if</span> grid[newX][newY]==<span class="string">&quot;1&quot;</span> <span class="keyword">and</span> mark[newX][newY]==<span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 递归搜索新的位置，查看是否还有新的位置是陆地，共同的加入形成岛屿</span></span><br><span class="line">                self.DFS(grid,newX,newY,mark)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 算例（和自己的手抄笔记匹配的）</span></span><br><span class="line"><span class="comment"># [[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]</span></span><br><span class="line"><span class="comment"># 输出 ：3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尝试简化一些写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        mark=[[<span class="number">0</span>]*<span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid))]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[i])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] ==<span class="string">&quot;1&quot;</span><span class="keyword">and</span> mark[i][j]==<span class="number">0</span>:</span><br><span class="line">                    self.DFS(grid,i,j,mark)</span><br><span class="line">                    count +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">self,grid,x,y,mark: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) :</span><br><span class="line">        mark[x][y]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> ((-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>)):</span><br><span class="line">            newX=dx + x</span><br><span class="line">            newY = dy + y</span><br><span class="line">            <span class="keyword">if</span> newX&lt; <span class="number">0</span> <span class="keyword">or</span> newX&gt;=<span class="built_in">len</span>(mark) <span class="keyword">or</span> newY &lt;<span class="number">0</span> <span class="keyword">or</span> newY &gt;=<span class="built_in">len</span>(mark[newX])</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> grid[newX][newY]==<span class="string">&quot;1&quot;</span> <span class="keyword">and</span> mark[newX][newY]==<span class="number">0</span>:</span><br><span class="line">                self.DFS(grid,newX,newY,mark)</span><br></pre></td></tr></table></figure>
5月1日再次回顾：也不知道这是自己写的第几遍的过程了，但是还是存在问题，这里将问题记录如下，不仅是算法思维要正确，同样的代码也要过关才行，否则就是一堆的bug：</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>问题一：边界出现问题。<img src="https://runnerxr.github.io/post-images/1651411102787.png">，dfs函数里面的x和y为矩阵的行坐标和列坐标（从0开始的），出界的条件是x&gt;&#x3D;行数，y&gt;&#x3D;列数</li>
<li>问题二，<img src="https://runnerxr.github.io/post-images/1651411240693.png">判断条件漏写，这里在最后的时候，满足搜索条件有两个，一个是当前访问的是陆地，另一个是当前这块陆地没有被标记。</li>
<li>问题三，这里不像其他的复杂的回溯问题，没有取消元素选择并弹出元素的过程。</li>
</ol>
<p><strong>甚至还可以采用并查集的思想来做题</strong>（主要是理解思路 ）<br>参考链接：<a target="_blank" rel="noopener" href="https://liweiwei1419.gitee.io/leetcode-algo/2017/10/26/leetcode-algo/0200-number-of-islands/">https://liweiwei1419.gitee.io/leetcode-algo/2017/10/26/leetcode-algo/0200-number-of-islands/</a><br><img src="https://runnerxr.github.io/post-images/1650609416171.png"><br>设计算法如下：</p>
<ol>
<li>如果是陆地，尝试与周围合并</li>
<li>如果是水域，把水域合并在一起<br>需要注意的点：</li>
<li>将二维数组与一维数组进行互换的过程需要熟悉（x*列数+y）</li>
<li>对水域也需要计数</li>
<li>最后的数量&#x3D;原数组数量-陆地连通后减少的数量-水域的数量（其实是有一点间接的感觉，不过也是主流的做法之一）</li>
<li>和DFS一样，也是需要做边界情况的判断</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后续代码自己整理</span></span><br><span class="line"><span class="comment"># 值得自己反复的做多遍，因为是python，所以有些代码相教Java是做了一些简化的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 边界条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m,n = <span class="built_in">len</span>(grid),<span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 水域的数量</span></span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 初始化并查集</span></span><br><span class="line">        <span class="comment"># 一行代码解决,注意数组的大小</span></span><br><span class="line">        p = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m*n)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 开始遍历，合并为1的节点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 如果存在陆地，调用_union函数,将所有的陆地进行合并</span></span><br><span class="line">                <span class="comment"># 需要把二维问题转化为一维问题</span></span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    <span class="comment"># self._union(p,i,j)，这是适用于一维的情况</span></span><br><span class="line">                    <span class="comment"># 合并上下左右为1的节点,改为一个共同的祖先</span></span><br><span class="line">                    directions = [(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>)]</span><br><span class="line">                    <span class="keyword">for</span> x,y <span class="keyword">in</span> directions:</span><br><span class="line">                        x= x + i</span><br><span class="line">                        y= y + j</span><br><span class="line">                        <span class="comment"># 对于新的行和列，如果行列都不越界，并且此时的标记也是为1的话，就进行合并祖先的操作。</span></span><br><span class="line">                        <span class="keyword">if</span> x &gt;=<span class="number">0</span> <span class="keyword">and</span> y &gt;=<span class="number">0</span> <span class="keyword">and</span> x &lt;m <span class="keyword">and</span> y &lt;n <span class="keyword">and</span> grid[x][y]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                            <span class="comment"># 经过union操作后，祖先都变为相同了，此时数组的值并没有改变，但是下一次遍历到数值虽然是1，祖先已经被同化了</span></span><br><span class="line">                            self._union(p,x*n+y,i*n+j)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 把水域的数量+1</span></span><br><span class="line">                    water +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 看n里面总共有几个parent</span></span><br><span class="line">        <span class="comment"># 这里取值的问题</span></span><br><span class="line">        <span class="comment"># return len(set([self._parent(p,i) for i in range(m*n)]))</span></span><br><span class="line">        res = [self._parent(p,i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m*n)]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">set</span>(res))-water</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># _union和_parent直接按模板抄上来</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_union</span>(<span class="params">self,p,i,j</span>):</span><br><span class="line">        p1 = self._parent(p,i)</span><br><span class="line">        p2 = self._parent(p,j)</span><br><span class="line">        p[p2]=p1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类似于find函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_parent</span>(<span class="params">self,p,i</span>):</span><br><span class="line">        root = i</span><br><span class="line">        <span class="comment"># 本质上也是一个递归操作</span></span><br><span class="line">        <span class="keyword">while</span> p[root] != root:</span><br><span class="line">            root = p[root]</span><br><span class="line">        <span class="comment"># 路径压缩</span></span><br><span class="line">        <span class="keyword">while</span> p[i] != i:</span><br><span class="line">            x ,i,p[x] = i,p[i],root</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>对python代码做一点修改，主要是为了和java以及主流的代码思路保持一致</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 边界条件:如果网格为空或者行数为0,直接返回空</span></span><br><span class="line">        <span class="keyword">if</span> grid <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(grid)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 统计水域的数量,初始化为0</span></span><br><span class="line">        waters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 为了方便调用函数,因为union  find和getCount都在uf类之下</span></span><br><span class="line">        uf = UnionFind(grid)</span><br><span class="line">        m,n=<span class="built_in">len</span>(grid),<span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 如果发现的是水域,就把水域数量+1</span></span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                    waters +=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果是陆地,就需要朝四个方向进行搜索</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 合并上下左右为1的节点,改为一个共同的祖先</span></span><br><span class="line">                    <span class="comment"># 合并上边节点(i-1,j)，注意不能出界</span></span><br><span class="line">                    directions = [(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>)]</span><br><span class="line">                    <span class="keyword">for</span> x,y <span class="keyword">in</span> directions:</span><br><span class="line">                        x= x + i</span><br><span class="line">                        y= y + j</span><br><span class="line">                        <span class="comment"># 对于新的行和列，如果行列都不越界，并且此时的标记也是为1的话，就进行合并祖先的操作。</span></span><br><span class="line">                        <span class="keyword">if</span> x &gt;=<span class="number">0</span> <span class="keyword">and</span> y &gt;=<span class="number">0</span> <span class="keyword">and</span> x &lt;m <span class="keyword">and</span> y &lt;n <span class="keyword">and</span> grid[x][y]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                            uf.union(x*n+y,i*n+j)</span><br><span class="line">        <span class="keyword">return</span> uf.getCount() - waters</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义UnionFind类,当作模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="comment"># 方法,类似于构造一个和网格类似的一维数组</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,grid</span>):</span><br><span class="line">        m,n=<span class="built_in">len</span>(grid),<span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 创建一个一维的root数组,长度与grid的长度相同</span></span><br><span class="line">        self.root= [-<span class="number">1</span>]*m*n</span><br><span class="line">        <span class="comment"># 一开始初始化为多少个元素</span></span><br><span class="line">        <span class="comment"># 最终应该减去水域的个数-联通之后的减少的个数</span></span><br><span class="line">        self.count = m*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m*n):</span><br><span class="line">            self.root[i]=i </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self,x</span>):</span><br><span class="line">        <span class="keyword">if</span> x ==self.root[x]:</span><br><span class="line">            <span class="keyword">return</span> self.root[x]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.root[x]=self.find(self.root[x])</span><br><span class="line">            <span class="keyword">return</span> self.root[x]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self,x,y</span>):</span><br><span class="line">        rootX = self.find(x)</span><br><span class="line">        rootY = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> rootX !=rootY:</span><br><span class="line">            self.root[rootX] = rootY</span><br><span class="line">            self.count -=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getCount</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br></pre></td></tr></table></figure>
<p>在上面的一个题解的基础上做进一步的优化（建议把上面的几种方式十分熟练之后再做相应的处理，还会让自己更上一步台阶）<br>优化的两个点：参考资料<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Q5411H7v5?p=2">https://www.bilibili.com/video/BV1Q5411H7v5?p=2</a></p>
<ol>
<li>优化包括quick find和quick  union,这里主要还是quick union,对树的高度进行了优化，权重的优化</li>
<li>对搜索的方向进行了优化（这个只是作为平时的解答，在面试的时候，还是按照常规思路来作答比较的好）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义UnionFind类,模板,但是也是做了一定的修改的.(根据题目的不同)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="comment"># 方法,类似于构造一个和网格类似的一维数组</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,grid</span>):</span><br><span class="line">        m,n=<span class="built_in">len</span>(grid),<span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 创建一个一维的root数组,长度与grid的长度相同</span></span><br><span class="line">        self.root= [-<span class="number">1</span>]*m*n</span><br><span class="line">        <span class="comment"># 定义了一个rank数组，记录每一组树的高度，初始化为0</span></span><br><span class="line">        self.rank = [<span class="number">0</span>]*m*n</span><br><span class="line">        <span class="comment"># 一开始初始化为0</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 以下的代码既构造一个序列号==祖先的数组,同时还记录了陆地的数量</span></span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    self.root[i*n+j]=i*n+j </span><br><span class="line">                    self.count+=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self,x</span>):</span><br><span class="line">        <span class="keyword">if</span> x ==self.root[x]:</span><br><span class="line">            <span class="keyword">return</span> self.root[x]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.root[x]=self.find(self.root[x])</span><br><span class="line">            <span class="keyword">return</span> self.root[x]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self,x,y</span>):</span><br><span class="line">        rootX = self.find(x)</span><br><span class="line">        rootY = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> rootX !=rootY:</span><br><span class="line">            <span class="comment"># 再加入一个判断,保证并查集不会退化为单链,树形结构尽量的矮一点,从而快速获得结点的根</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 比较两个树的树高,rootX的树高小于rootY的树高，把矮的树连接到高的树上面去</span></span><br><span class="line">            <span class="comment"># 即把rootX的根节点放到rootY</span></span><br><span class="line">            <span class="keyword">if</span> self.rank[rootX] &lt;self.rank[rootY]:</span><br><span class="line">                rootX,rootY=rootY,rootX</span><br><span class="line">            <span class="comment"># 否则：把rootY的根节点放到rootX(把 y连到x)</span></span><br><span class="line">            self.root[rootY] = rootX</span><br><span class="line">            <span class="comment"># 以上的三行代码是做了相应的优化的实际上是这四行代码</span></span><br><span class="line">            <span class="comment"># if self.rank[rootX] &lt;self.rank[rootY]:</span></span><br><span class="line">            <span class="comment">#      self.root[rootX] = rootY</span></span><br><span class="line">            <span class="comment"># elif self.rank[rootX] &lt;self.rank[rootY]:</span></span><br><span class="line">            <span class="comment">#     self.root[rootY] = rootX</span></span><br><span class="line">            <span class="keyword">elif</span> self.rank[rootX] ==self.rank[rootY]:</span><br><span class="line">                self.rank[rootX] +=<span class="number">1</span></span><br><span class="line">            self.count -=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getCount</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 边界条件:如果网格为空或者行数为0,直接返回空</span></span><br><span class="line">        <span class="keyword">if</span> grid <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(grid)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 为了方便调用函数,因为union  find和getCount都在uf类之下</span></span><br><span class="line">        uf = UnionFind(grid)</span><br><span class="line">        m,n=<span class="built_in">len</span>(grid),<span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 如果是陆地,就需要朝四个方向进行搜索</span></span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 合并上下左右为1的节点,改为一个共同的祖先</span></span><br><span class="line">                    <span class="comment"># 合并上边节点(i-1,j)，注意不能出界</span></span><br><span class="line">                    <span class="comment"># directions = [(-1,0),(1,0),(0,-1),(0,1)]</span></span><br><span class="line">                    <span class="comment"># 对于方向向量,可以只用右边和下边</span></span><br><span class="line">                    directions = [(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>)]</span><br><span class="line">                    <span class="keyword">for</span> x,y <span class="keyword">in</span> directions:</span><br><span class="line">                        x= x + i</span><br><span class="line">                        y= y + j</span><br><span class="line">                        <span class="comment"># 对于新的行和列，如果行列都不越界，并且此时的标记也是为1的话，就进行合并祖先的操作。</span></span><br><span class="line">                        <span class="keyword">if</span> x &gt;=<span class="number">0</span> <span class="keyword">and</span> y &gt;=<span class="number">0</span> <span class="keyword">and</span> x &lt;m <span class="keyword">and</span> y &lt;n <span class="keyword">and</span> grid[x][y]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                            uf.union(x*n+y,i*n+j)</span><br><span class="line">                    <span class="comment"># if i+1&lt;m and grid[i+1][j]==&#x27;1&#x27;:</span></span><br><span class="line">                    <span class="comment">#     uf.union((i+1)*n+j,i*n+j)</span></span><br><span class="line">                    <span class="comment"># if j+1&lt;n and grid[i][j+1]==&#x27;1&#x27;:</span></span><br><span class="line">                    <span class="comment">#     uf.union(i*n+j+1,i*n+j)</span></span><br><span class="line">        <span class="keyword">return</span> uf.getCount()</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h1><p>解题思路：<br>用空间换时间的操作<br>一旦发现是错的，就需要推到重来<br>还有浅拷贝和深拷贝的情况：值传递和引用传递的区别<br>运用数学公式去更新棋盘<br>回溯和递归的关系：用递归的代码来解决回溯的算法，需要把某些代码做一个重置、剪枝操作（一定要深入理解递归的算法）</p>
<ol>
<li>构建两个数组,一个数组是攻击数组:attack(是否可以放置皇后)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 待整理</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad78-子集-middle"><a href="#leetcoad78-子集-middle" class="headerlink" title="leetcoad78-子集(middle)"></a>leetcoad78-子集(middle)</h1><p><strong>非常重要-重点掌握，每一行代码都要清楚，并且还要清楚相应的调试过程，把DFS+剪枝的操作掌握得烂熟于心的程度（本题没有剪枝过程），由子集的解题步骤衍生出的7道题目的写法</strong><br>方法一：采用树形递归的方式（结合树形图理解相应的递归路线，本质是一种深度优先搜索DFS）<br><img src="https://runnerxr.github.io/post-images/1649694805789.png"><br>结合着张图以及后面自己在本地调式的过程，基本上是把这个过程给完完全全的整理清楚了。<br>方法二：采用循环的思路来解决（与方法一的区别：把子集加入结果数组的时机不一样，本质的思路是一样的）<br>方法三：采用广度优先搜索（BFS）,是一种分层搜索的方法，不是递归形式的，不需要回退<br>函数：</p>
<ol>
<li>每次调用这个函数，我们都会在当前数组中可用的区间中搜索出一个元素来，每找到一个元素就在原先的路径上添加的一个元素，此时你无论添加一个什么样的元素，当前都已经有一条完整的路径了，形成的一个路径就是一个子集，加入到我们的结果数组中</li>
<li>i肯定会超过数组，一旦超过数组的话，就结束相应的判断，否则的话：确定选了1之后，开始查看后面有多少种选择，利用三行代码把所有的子集添加进去：<ol>
<li>利用subset.add扩充新的元素进去，判断是否需要剪枝，去判断此时储存的数据是否之前已经被储存过</li>
<li>做出选择，递归调用该函数，进入下一层继续 （当前的这个搜索区间不再是从2开始的，从2的后面的元素开始的。）backtrack</li>
<li>撤销选择，回到上一层的状态：subset.remove</li>
</ol>
</li>
</ol>
<p>看视频做的一点记录：<br>对于每个元素都有两种选择方案：选或者不选，总共有2^n种<br>无法利用一次循环来把所有的元素都选出来：对于某个元素做出选或者不选的决定后，之前选择的元素与该元素共同组成一个新的组合，会漏掉一个不选的元素<br>把选1的策略全部走完<br>然后把选2的策略全部走完</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照吴师兄的思路一步步的调试清楚</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 结果集合</span></span><br><span class="line">        sets=[]</span><br><span class="line">        <span class="comment">#每次的子集</span></span><br><span class="line">        subset=[]</span><br><span class="line">        <span class="comment"># 执行回溯算法</span></span><br><span class="line">        self.backtrack(<span class="number">0</span>,nums,subset,sets)</span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> sets</span><br><span class="line">    <span class="comment"># i 表示递归时正在访问的数组元素下标</span></span><br><span class="line">    <span class="comment"># nums 表示当前集合中的元素</span></span><br><span class="line">    <span class="comment"># subset 表示每次递归后生成的子集，就是路径上的那些元素,类似于临时的子数组</span></span><br><span class="line">    <span class="comment"># sets 表示最终生成的所有子集合</span></span><br><span class="line">    <span class="comment"># 画出递归树，找到状态变量（回溯函数的参数）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self,i:<span class="built_in">int</span>,nums:<span class="type">List</span>[<span class="built_in">int</span>],subset:<span class="type">List</span>[<span class="built_in">int</span>],sets:<span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 每次确定好一个子集，都把它加入到结果集合中</span></span><br><span class="line">        sets.append(subset[:])</span><br><span class="line">        <span class="comment"># 此处在调试的时候加入一个打印，有助于了解相应的不断递归过程</span></span><br><span class="line">        <span class="comment"># print(&quot;  递归前subset =&gt; &quot; ,subset)</span></span><br><span class="line">        <span class="comment"># print(&quot;  递归前sets =&gt; &quot; ,sets)</span></span><br><span class="line">        <span class="comment"># 2、寻找结束条件，由于回溯算法是借助递归实现，所以也就是去寻找递归终止条件</span></span><br><span class="line">        <span class="comment"># 本题中可以不加这个判断，大家可以思考一下为什么可以不加，结合 for 循环的边界来思考</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 当访问的数组下标超过了nums数组的长度时，递归结束（这里的理解非常重要，只有递归结束了，才会有回溯的操作过程，这是一体的）</span></span><br><span class="line">        <span class="comment"># 此处也可以不加判断，理由，通过调试的过程中我们就会发现，当n=len(nums)的时候，此时不会进入到循环之中，直接跳到subset.pop(len(subset) - 1)这一行代码，类似于是递归的最后一次循环了。</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;=n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 3、确定选择列表，需要把什么数据存储到结果里面</span></span><br><span class="line">        <span class="comment"># for 循环就是一个选择的过程</span></span><br><span class="line">        <span class="comment"># 遍历本层集合中的元素</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">            <span class="comment"># 把本次递归访问的元素加入到 subset 数组中</span></span><br><span class="line">            subset.append(nums[j])</span><br><span class="line">            <span class="comment"># 4、判断是否需要剪枝，去判断此时存储的数据是否之前已经被存储过</span></span><br><span class="line">            <span class="comment"># 本题不需要剪枝</span></span><br><span class="line">            <span class="comment"># 5、做出选择，递归调用该函数，进入下一层继续搜索</span></span><br><span class="line">            <span class="comment"># 递归</span></span><br><span class="line">            <span class="comment"># 此时需要传入新的参数</span></span><br><span class="line">            self.backtrack( j+<span class="number">1</span>,nums , subset , sets)</span><br><span class="line">            <span class="comment"># 6、撤销选择，回到上一层的状态</span></span><br><span class="line">            <span class="comment"># 取消对 nums[i] 的选择（这里的取消选择的过程，自己也可以通过代码来进行调试，让自己更加熟悉这个过程：只有在递归到尽头的时候才会进行回溯的操作）</span></span><br><span class="line">            subset.pop(<span class="built_in">len</span>(subset) - <span class="number">1</span>)</span><br><span class="line">            <span class="comment">#print(&quot; 取消subset最后一个元素 =&gt; &quot; ,subset)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 输入一个特定的需要求解的数组</span></span><br><span class="line">    nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    res = Solution().subsets(nums)</span><br><span class="line">    <span class="comment">#print(res)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;  输出 =&gt; &quot;</span> ,res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果如下</span></span><br><span class="line"><span class="comment"># 一开始就选1时，从头递归到尾</span></span><br><span class="line"><span class="comment">#  递归前subset =&gt;  []</span></span><br><span class="line"><span class="comment">#   递归前sets =&gt;  [[]]</span></span><br><span class="line"><span class="comment">#   递归前subset =&gt;  [1]</span></span><br><span class="line"><span class="comment">#   递归前sets =&gt;  [[], [1]]</span></span><br><span class="line"><span class="comment">#   递归前subset =&gt;  [1, 2]</span></span><br><span class="line"><span class="comment">#   递归前sets =&gt;  [[], [1], [1, 2]]</span></span><br><span class="line"><span class="comment">#   递归前subset =&gt;  [1, 2, 3]</span></span><br><span class="line"><span class="comment">#   递归前sets =&gt;  [[], [1], [1, 2], [1, 2, 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一开始就选1时，从递归结束的地方开始回溯</span></span><br><span class="line"><span class="comment">#   取消subset最后一个元素 =&gt;  [1, 2]</span></span><br><span class="line"><span class="comment">#   取消subset最后一个元素 =&gt;  [1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 一开始就选1时，回退到选3不选2的过程</span></span><br><span class="line"><span class="comment">#   递归前subset =&gt;  [1, 3]</span></span><br><span class="line"><span class="comment">#   递归前sets =&gt;  [[], [1], [1, 2], [1, 2, 3], [1, 3]]</span></span><br><span class="line"><span class="comment">#   取消subset最后一个元素 =&gt;  [1]</span></span><br><span class="line"><span class="comment">#   取消subset最后一个元素 =&gt;  []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   回退到空，然后开始选2的过程</span></span><br><span class="line"><span class="comment">#   递归前subset =&gt;  [2]</span></span><br><span class="line"><span class="comment">#   递归前sets =&gt;  [[], [1], [1, 2], [1, 2, 3], [1, 3], [2]]</span></span><br><span class="line"><span class="comment">#   递归前subset =&gt;  [2, 3]</span></span><br><span class="line"><span class="comment">#   递归前sets =&gt;  [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选2的时候递归结束开始回溯的一个过程</span></span><br><span class="line"><span class="comment">#   取消subset最后一个元素 =&gt;  [2]</span></span><br><span class="line"><span class="comment">#   取消subset最后一个元素 =&gt;  []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   回退到空，然后开始选3的过程</span></span><br><span class="line"><span class="comment">#   递归前subset =&gt;  [3]</span></span><br><span class="line"><span class="comment">#   递归前sets =&gt;  [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   回退到空，然后开始选3的下一个元素的过程（发现此时已经无元素可以选择了）</span></span><br><span class="line"><span class="comment">#   取消subset最后一个元素 =&gt;  []</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终对sets进行输出</span></span><br><span class="line"><span class="comment">#   输出 =&gt;  [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己对代码做一点简化，比如我把函数写在了subsets里面，就不需要再另外的去定义sets和subset变量。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        sets=[]</span><br><span class="line">        subset=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">i:<span class="built_in">int</span>,nums</span>):</span><br><span class="line">            sets.append(subset[:])</span><br><span class="line">            <span class="comment"># print(&quot; subset =&gt; &quot; ,subset)</span></span><br><span class="line">            <span class="comment"># print(&quot; sets =&gt; &quot; ,sets)</span></span><br><span class="line">            n = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="keyword">if</span> i &gt;=n:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                subset.append(nums[j])</span><br><span class="line">                backtrack( j+<span class="number">1</span>,nums )</span><br><span class="line">                <span class="comment"># 弹出subset中的最后一个元素</span></span><br><span class="line">                subset.pop()</span><br><span class="line">                <span class="comment"># print(&quot; 取消subset最后一个元素的选择 =&gt; &quot; ,subset)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用回溯算法</span></span><br><span class="line">        backtrack(<span class="number">0</span>,nums)</span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> sets</span><br></pre></td></tr></table></figure>
<p><strong>迭代法</strong>（待整理）<br>参考链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/">https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = [[]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            res = res + [[i] + num <span class="keyword">for</span> num <span class="keyword">in</span> res]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="leetcoad90-子集II-middle"><a href="#leetcoad90-子集II-middle" class="headerlink" title="leetcoad90-子集II(middle)"></a>leetcoad90-子集II(middle)</h1><p><img src="https://runnerxr.github.io/post-images/1652361154485.png"><br>相比于子集，加入了一个剪枝的操作：判断当前的元素是否和之前的元素相同，如果相同就不去执行后面的代码。（后面的代码是将当前元素作为一种选择情况下的那一个子集加入到相应的结果数组中，当前的情况已经在之前分析过了，不需要再执行了,子集那道题已经限制了给定的值是互不相同的）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 并加入头文件进行调试，选用的例子是nums=[1,2,2],如果选用[1,2,3],得到的结果和子集I是一样的结果</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 对原数组排序，这样才能对比当前元素和之前的元素是否相同</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        sets=[]</span><br><span class="line">        subset=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">i:<span class="built_in">int</span>,nums</span>):</span><br><span class="line">            sets.append(subset[:])</span><br><span class="line">            n = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="keyword">if</span> i &gt;=n:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                <span class="comment"># 剪枝</span></span><br><span class="line">                <span class="keyword">if</span> j &gt;i <span class="keyword">and</span> nums[j-<span class="number">1</span>]==nums[j]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                subset.append(nums[j])</span><br><span class="line"></span><br><span class="line">                backtrack( j+<span class="number">1</span>,nums )</span><br><span class="line">                <span class="comment"># 弹出subset中的最后一个元素</span></span><br><span class="line">                subset.pop()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用回溯算法</span></span><br><span class="line">        backtrack(<span class="number">0</span>,nums)</span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> sets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 输入一个特定的需要求解的数组</span></span><br><span class="line">    nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">    res = Solution().subsetsWithDup(nums)</span><br><span class="line">    <span class="comment">#print(res)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;  输出 =&gt; &quot;</span> ,res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果如下：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一开始就选1时，从头递归到尾</span></span><br><span class="line"><span class="comment"># subset =&gt;  []</span></span><br><span class="line"><span class="comment">#  sets =&gt;  [[]]</span></span><br><span class="line"><span class="comment">#  subset =&gt;  [1]</span></span><br><span class="line"><span class="comment">#  sets =&gt;  [[], [1]]</span></span><br><span class="line"><span class="comment">#  subset =&gt;  [1, 2]</span></span><br><span class="line"><span class="comment">#  sets =&gt;  [[], [1], [1, 2]]</span></span><br><span class="line"><span class="comment">#  subset =&gt;  [1, 2, 2]</span></span><br><span class="line"><span class="comment">#  sets =&gt;  [[], [1], [1, 2], [1, 2, 2]]  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一开始就选1时，从递归结束的地方开始回溯，由于后面还有一个2，与上一次选择相同，不会再选择，直接回溯到空</span></span><br><span class="line"><span class="comment">#  取消subset最后一个元素的选择 =&gt;  [1, 2]</span></span><br><span class="line"><span class="comment">#  取消subset最后一个元素的选择 =&gt;  [1]   </span></span><br><span class="line"><span class="comment">#  取消subset最后一个元素的选择 =&gt;  []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   回退到空，然后开始选2的过程</span></span><br><span class="line"><span class="comment">#  subset =&gt;  [2]</span></span><br><span class="line"><span class="comment">#  sets =&gt;  [[], [1], [1, 2], [1, 2, 2], [2]]</span></span><br><span class="line"><span class="comment">#  subset =&gt;  [2, 2]</span></span><br><span class="line"><span class="comment">#  sets =&gt;  [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]</span></span><br><span class="line"><span class="comment">#  取消subset最后一个元素的选择 =&gt;  [2]</span></span><br><span class="line"><span class="comment">#  取消subset最后一个元素的选择 =&gt;  []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   回退到空，然后开始选2的下一个元素的过程（发现此时已经无元素可以选择了）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   输出 =&gt;  [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]</span></span><br></pre></td></tr></table></figure>
<h1 id="leetcoad77-组合-middle"><a href="#leetcoad77-组合-middle" class="headerlink" title="leetcoad77-组合(middle)"></a>leetcoad77-组合(middle)</h1><p>题目描述：给定两个整数 n 和 k，返回范围 [1, n] 中<strong>所有可能的 k 个数的组合</strong>。<br>你可以按 任何顺序 返回答案。<br>输入：n &#x3D; 4, k &#x3D; 2<br>输出：<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]<br>做题链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/">https://leetcode-cn.com/problems/combinations/</a><br><img src="https://runnerxr.github.io/post-images/1652362914174.png"><br><img src="https://runnerxr.github.io/post-images/1652363742876.png"><br>做题思路：<br>这里用4个元素中找出3个数的组合来解题</p>
<ol>
<li>理解题目的意思：当前总共有三个坑，如何<strong>从四个元素中去寻找三个元素</strong>去填满这些坑，可以将数组中的每一个元素作为三个坑的第一个元素，然后在剩下的三个元素中去寻找两个元素出来，将剩下的这两个坑填满。然后在填了两个坑的基础上，查看后面的以后个坑如何选择</li>
<li>实现地具体过程以及相应地注意点：<ol>
<li>递归地终止条件变了：需要填入地数为0</li>
<li>确定选择列表地时候也变了，选择地终止索引为后面地数刚好能凑齐k个数截至（想要保证数不重复，又要把元素填满）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">暂时没有代码，待补充</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="leetcoad39-组合总和-middle"><a href="#leetcoad39-组合总和-middle" class="headerlink" title="leetcoad39-组合总和(middle)"></a>leetcoad39-组合总和(middle)</h1><p>题目描述：<br>给你一个 <strong>无重复元素</strong> 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。<br>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。<br>理解题目的意思之后再谈做题的方法：</p>
<ol>
<li>仍然可以用回溯的算法思想</li>
<li>第一次是可以选择任意元素，在第一次选择的基础上，剩下的就是要凑出target-nums[i]的和，然后继续进行下一轮的选择，<strong>在选数的时候不能选比当前需要值大的数</strong>。<br>以下结合这几张图来辅助理解这里的过程<br><img src="https://runnerxr.github.io/post-images/1652364640585.png"></li>
<li>罗列所有选择并排除不合适的选择，这样就选出了[2,2,3] [2,3,2] [3,2,2] [7],但是这和题目的意思是不符合的，组合的话是不用管顺序的<br><img src="https://runnerxr.github.io/post-images/1652364808224.png"></li>
<li>紧接着就思考，如何进行剪枝的问题？对于想要凑齐5的情况，由于第一次已经选了2 2 3，当下一次选到2 3的时候就会发现之前是舍弃了2没有选的，那么在接下的选择中就也不能选择2，只能从3开始选择，同理在凑齐4的过程中，由于前面是选择了3的，所以后面就不能再选比3小的数，也就只能从3开始选，也就有了下面的这张图的理解过程<br><img src="https://runnerxr.github.io/post-images/1652364824518.png"></li>
<li>再紧接着就思考递归结束的条件： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. target&lt;0</span><br><span class="line">2. target==0</span><br></pre></td></tr></table></figure>
4.再接着就是确定选择列表，需要将什么样的数加入进去，精髓就在于递归的时候传入的数据：backtrack(nums,target-nums[i],path,newposition)<br>5.初调用函数的时候表示：从第0个元素开始选择，要筹齐的目标数为原始目标数，然后随着不断地递归,target不断地减小，最后达到递归地出口地位置。<span id="more"></span>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 采用吴师兄的思路</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        path =[]</span><br><span class="line">        res = []</span><br><span class="line">        self.backtrack(candidates,target,path,<span class="number">0</span>,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 画出递归树，找到状态变量</span></span><br><span class="line">    <span class="comment"># strat表示递归正在访问的数组元素下标</span></span><br><span class="line">    <span class="comment"># target表示想在当前区间拼凑出的目标值</span></span><br><span class="line">    <span class="comment"># path表示路径</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self,nums,target,path,start,res</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 2.寻找结束条件（也即寻找递归的终止条件,这里有两个）</span></span><br><span class="line">        <span class="keyword">if</span> target &lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到一个组合</span></span><br><span class="line">        <span class="keyword">if</span> target==<span class="number">0</span>:</span><br><span class="line">            res.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 3.确定选择列表，需要把什么数据传入里面</span></span><br><span class="line">        <span class="comment"># for 循环就是一个选择的过程</span></span><br><span class="line">        <span class="comment"># i 等于 start 表示，后续可以选的元素一开始只能从 start 开始</span></span><br><span class="line">        <span class="comment"># 比如 nums = [2,3,6,7]</span></span><br><span class="line">        <span class="comment"># i = 1，指向了元素 3 ，表示当前后续选择的过程中，只能从 3 开始选，可以重复选 3 ，但无法选 2 了</span></span><br><span class="line">        <span class="comment"># i = 2，指向了元素 6 ，表示当前后续选择的过程中，只能从 6 开始选，可以重复选 6 ，但无法选 2、3 了</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,n):</span><br><span class="line">            <span class="comment"># 当前路径上可以把 nums[i] 加上</span></span><br><span class="line">            path.append(nums[i])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 一些逻辑操作（可有可无，视情况而定）</span></span><br><span class="line">            <span class="comment"># 4、判断是否需要剪枝，去判断此时存储的数据是否之前已经被存储过</span></span><br><span class="line">            <span class="comment"># 需要剪枝</span></span><br><span class="line">            <span class="comment"># 此时，目标值 target，已经从 target 变成了 target - nums[i]</span></span><br><span class="line">            <span class="comment"># 接下来需要去【某个区间中】拼凑 target - nums[i]</span></span><br><span class="line">            <span class="comment"># 由于 同一个 数字可以 无限制重复被选取</span></span><br><span class="line">            <span class="comment"># 当前正在使用 nums[i]，那么为了拼凑 target - nums[i]，依旧可以继续从使用 nums[i] 开始</span></span><br><span class="line">            <span class="comment"># 而 i 前面的元素，比如 num[i-1]、 num[i-2]无法继续使用，实现了剪枝操作</span></span><br><span class="line">            nowposition = i</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 5、做出选择，递归调用该函数，进入下一层继续搜索</span></span><br><span class="line">            <span class="comment"># 递归</span></span><br><span class="line">            self.backtrack(nums, target - nums[i] , path , nowposition,res )</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 一些逻辑操作（可有可无，视情况而定）</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 6、撤销选择，回到上一层的状态</span></span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己在此基础上做了一点简化代码的工作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        path =[]</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 定义回溯函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">nums,target,path,start</span>):</span><br><span class="line">            n = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 寻找结束条件</span></span><br><span class="line">            <span class="keyword">if</span> target &lt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> target==<span class="number">0</span>:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 3.确定选择列表，需要把什么数据传入里面</span></span><br><span class="line">            <span class="comment"># for 循环就是一个选择的过程</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,n):</span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                <span class="comment">#4、判断是否需要剪枝</span></span><br><span class="line">                nowposition = i</span><br><span class="line">                <span class="comment"># 5、做出选择，递归调用该函数，进入下一层继续搜索</span></span><br><span class="line">                <span class="comment"># 递归</span></span><br><span class="line">                backtrack(nums, target - nums[i] , path , nowposition )</span><br><span class="line">                <span class="comment"># 6、撤销选择，回到上一层的状态</span></span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用回溯函数</span></span><br><span class="line">        backtrack(candidates,target,path,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="leetcoad40-组合总数II-middle"><a href="#leetcoad40-组合总数II-middle" class="headerlink" title="leetcoad40-组合总数II(middle)"></a>leetcoad40-组合总数II(middle)</h1><p>题目描述：给定一个候选人编号的集合 candidates 和一个目标数 target ，<strong>找出 candidates 中所有可以使数字和为 target 的组合</strong>。candidates 中的<strong>每个数字在每个组合中只能使用 一次</strong> 。(和上面一题的区别：在candidate中找的数字只能使用一次，但是给定的数组可能含有相同的值)<br>注意：解集不能包含重复的组合。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 对数组进行一个排序操作</span></span><br><span class="line">        candidates.sort()</span><br><span class="line">        path =[]</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 定义回溯函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">nums,target,path,start</span>):</span><br><span class="line">            n = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 寻找结束条件</span></span><br><span class="line">            <span class="keyword">if</span> target &lt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> target==<span class="number">0</span>:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 3.确定选择列表，需要把什么数据传入里面</span></span><br><span class="line">            <span class="comment"># for 循环就是一个选择的过程</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,n):</span><br><span class="line">                </span><br><span class="line">                <span class="comment">#4、判断是否需要剪枝</span></span><br><span class="line">                <span class="comment"># 之所以限定i &gt; strat,是为了保证i-1是有值的</span></span><br><span class="line">                <span class="keyword">if</span> i &gt;start <span class="keyword">and</span> nums[i-<span class="number">1</span>] ==nums[i]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                nowposition = i+<span class="number">1</span></span><br><span class="line">                <span class="comment"># 5、做出选择，递归调用该函数，进入下一层继续搜索</span></span><br><span class="line">                <span class="comment"># 递归</span></span><br><span class="line">                backtrack(nums, target - nums[i] , path , nowposition )</span><br><span class="line">                <span class="comment"># 6、撤销选择，回到上一层的状态</span></span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用回溯函数</span></span><br><span class="line">        backtrack(candidates,target,path,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h1><p>题目描述：<br>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：<br>    只使用数字1到9<br>    每个数字 最多使用一次<br>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。<br>输入: k &#x3D; 3, n &#x3D; 7<br>输出: [[1,2,4]]<br>解释:<br>1 + 2 + 4 &#x3D; 7<br>没有其他符合的组合了。<br>解题思路：和lc77.组合相比，本题多了一个步骤：<strong>判断已经拿到的k个数之和是否等于n</strong>。<br>化简题意：从[1,9]中找k个数，使得它们的和是否等于n。<br>如何做？模拟人工寻找过程，先选1、2、3发现它们的和不等于n，下一步我们会保留1、2，舍弃3，添加4进来再次判断，以此类推，[1、2、5]、[1、2、6]…当最后一位数字3~9全都试过之后，我们再去改变第二位数….</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待整理</span><br></pre></td></tr></table></figure>
<h1 id="leetcoad46-全排列-middle"><a href="#leetcoad46-全排列-middle" class="headerlink" title="leetcoad46-全排列(middle)"></a>leetcoad46-全排列(middle)</h1><p><img src="https://runnerxr.github.io/post-images/1651336911841.png"><br><img src="https://runnerxr.github.io/post-images/1651337009639.png"><br><img src="https://runnerxr.github.io/post-images/1651337042332.png"><br><img src="https://runnerxr.github.io/post-images/1651415586877.png"><br>注意与子集的区别的地方：</p>
<ol>
<li>对前面已经用过的数字，后面还是可以再继续用（对于123和23在排列里面是不同的组合，在子集中就是相同的组合）</li>
<li>只有当搜索到的数组的长度等于原数组的长度才会进行返回（全排列需要把所有的数都要加进来的）<br>需要建立一个布尔类型数组：用来判断每个元素在后面的遍历过程中没有使用<br>一开始默认的每一个元素都没有被选中<br>创建回溯函数：<br>几个参数：数组、路径、几个当前的元素在之前的遍历过程中有没有被使用过的数组<br>只有当前元素还没有被用到过，才有资格加入到我们的数组中<br>把当前的这个元素设置为true的操作，表明已经选择的数字在当前要选择的数字中不能出现<br>由于要遍历所有的元素，相当于是一个暴力的解法，不存在剪枝操作<br>递归的调用代码，进入下一层的搜索<br>取消对nums[i]的选择（这里的理解很重要：在每次的遍历过程中，先是设置为了true,方便进行递归，但是在一轮循环中，这个被置为true的数仍然要被用到，需要加入取消对nums[i]的选择）</li>
<li>先写以 111 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]，即 1 + [2, 3] 的全排列（注意：<strong>递归结构体现在这里</strong>）；</li>
<li>再写以 222 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]，即 2 + [1, 3] 的全排列；</li>
<li>最后写以 333 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]，即 3 + [1, 2] 的全排列<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 结果集合</span></span><br><span class="line">        sets=[]</span><br><span class="line">        <span class="comment">#每次的子集</span></span><br><span class="line">        subset=[]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建一个布尔数组</span></span><br><span class="line">        <span class="comment"># 每个元素默认一开始没有被选择，后面当我们选定一个数的时候，将这个数组的相应位置设置为true，在考虑下一个位置的时候能够以O(1)的时间复杂度判断是否被选择过，是一种以空间换时间的思想</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        used = [<span class="literal">False</span>]*n</span><br><span class="line">        <span class="comment"># 执行回溯算法</span></span><br><span class="line">        self.backtrack(nums,subset,used,sets)</span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> sets</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># used表示递归时正在访问的数组元素是否之前已经被访问过</span></span><br><span class="line">    <span class="comment"># nums 表示当前集合中的元素</span></span><br><span class="line">    <span class="comment"># subset 表示每次递归后生成的子集，就是路径上的那些元素,类似于临时的子数组，就是充当了一个栈的作用</span></span><br><span class="line">    <span class="comment"># sets 表示最终生成的所有子集合</span></span><br><span class="line">    <span class="comment"># 画出递归树，找到状态变量（回溯函数的参数）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self,nums:<span class="type">List</span>[<span class="built_in">int</span>],subset:<span class="type">List</span>[<span class="built_in">int</span>],used:<span class="type">List</span>[<span class="built_in">int</span>],sets:<span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2、寻找结束条件，由于回溯算法是借助递归实现，所以也就是去寻找递归终止条件</span></span><br><span class="line">        <span class="comment"># 当访问的数组长度等于原数组的长度，递归结束</span></span><br><span class="line">        <span class="comment"># 每次确定好一个子集，都把它加入到结果集合中</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(subset)==n:</span><br><span class="line">            sets.append(subset[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3、确定选择列表，需要把什么数据存储到结果里面</span></span><br><span class="line">        <span class="comment"># for 循环就是一个选择的过程</span></span><br><span class="line">        <span class="comment"># 遍历本层集合中的元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n):</span><br><span class="line">            <span class="comment"># 当前是哪些元素可以加入</span></span><br><span class="line">            <span class="comment"># 如果当前的元素的布尔值是False,那么就可以选择该元素</span></span><br><span class="line">            <span class="keyword">if</span> used[i]==<span class="literal">False</span>:</span><br><span class="line">                <span class="comment"># 把本次递归访问的元素加入到 subset 数组中</span></span><br><span class="line">                <span class="comment"># 往下走一层，subset在尾部追加</span></span><br><span class="line">                subset.append(nums[i])</span><br><span class="line">                <span class="comment"># 这个元素已经被使用过，就用更改标记</span></span><br><span class="line">                <span class="comment"># 在一轮还没有选完的过程中，标记了这个就表明如果循环到这里了需要跳过，这个元素已经选过了，需要选择下一个。</span></span><br><span class="line">                used[i]=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 4、判断是否需要剪枝，去判断此时存储的数据是否之前已经被存储过</span></span><br><span class="line">                <span class="comment"># 本题不需要剪枝</span></span><br><span class="line">                <span class="comment"># 5、做出选择，递归调用该函数，进入下一层继续搜索</span></span><br><span class="line">                <span class="comment"># 递归的调用代码（暴力的过程）</span></span><br><span class="line">                self.backtrack( nums,subset ,used,sets)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 6、撤销选择，回到上一层的状态（上面的一轮搜索到底执行完毕就回撤，这里的理解要结合调试的过程来理解，其实如果是例子很简单还比较好理解，一旦例子过于复杂就会出现问题，所以主要还是在于思想的方面）</span></span><br><span class="line">                <span class="comment"># 取消对 nums[i] 的选择(从最后一个加入的元素开始的)，这两行代码是配套操作的，两个都不能少（也需要结合调试的过程来理解）</span></span><br><span class="line">                <span class="comment"># 回溯的过程，不断地往前，将之前变为True的标记一个一个的变成False，索引号一是从大变小的</span></span><br><span class="line">                used[i]=<span class="literal">False</span></span><br><span class="line">                <span class="comment"># 把当前元素移除我们的路径，在这一次循环里面，比如1设置为true，它不会在进入if语句。</span></span><br><span class="line">                <span class="comment"># 往上走一层，subset撤销上一次选择</span></span><br><span class="line">                subset.pop()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简化版</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        sets=[]</span><br><span class="line">        subset=[]</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        used = [<span class="literal">False</span>]*n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">subset,used,sets</span>) :</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(subset)==n:</span><br><span class="line">                sets.append(subset[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n):</span><br><span class="line">                <span class="keyword">if</span> used[i]==<span class="literal">False</span>:</span><br><span class="line">                    subset.append(nums[i])</span><br><span class="line">                    used[i]=<span class="literal">True</span></span><br><span class="line">                    backtrack( subset,used,sets)</span><br><span class="line">                    used[i]=<span class="literal">False</span></span><br><span class="line">                    subset.pop()</span><br><span class="line">        </span><br><span class="line">        backtrack(subset,used,sets)</span><br><span class="line">        <span class="keyword">return</span> sets</span><br></pre></td></tr></table></figure>
5月1日再次回顾的时候再看看这道题，发现还是存在一些问题没有完全的弄懂。几个重要的点再次进行回顾与整理：</li>
<li>首先在大体的思路上就出现了问题：要定义一个布尔数组，为了好进行相应的标定工作。</li>
<li><img src="https://runnerxr.github.io/post-images/1651412531168.png">第一点不用说，深拷贝的问题</li>
<li>对于一轮选择中的单个元素加入subset的时机的问题：只有符合筛选条件之后才能加入，不能够放错位置</li>
<li>常规步骤，在一次递归之后取消选择以及移除路径<br><strong>假设每一次尝试都复制，则不需要回溯</strong><br>在每一个非叶子节点分支的尝试，都创建新的变量来表示状态</li>
<li>在回到上一层节点的时候不需要回溯</li>
<li>在递归终止的时候也不要做拷贝<br>结果：可以得到解，但是会创建中间变量，会有空间和时间的消耗</li>
</ol>
<p>顺便贴一个可以在本地调试的版本，还可以输出递归前以及递归后的子集的情况（在本地调试之后发现很多问题就能迎刃而解）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        sets=[]</span><br><span class="line">        subset=[]</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        used = [<span class="literal">False</span>]*n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">subset,used,sets</span>) :</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(subset)==n:</span><br><span class="line">                sets.append(subset[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n):</span><br><span class="line">                <span class="keyword">if</span> used[i]==<span class="literal">False</span>:</span><br><span class="line">                    subset.append(nums[i])</span><br><span class="line">                    used[i]=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># print(&quot;  递归之前 =&gt; &quot;,subset)</span></span><br><span class="line">                    backtrack( subset,used,sets)</span><br><span class="line">                    used[i]=<span class="literal">False</span></span><br><span class="line">                    subset.pop()</span><br><span class="line">                    <span class="comment"># print(&quot;  递归之后 =&gt; &quot; ,subset)</span></span><br><span class="line">        </span><br><span class="line">        backtrack(subset,used,sets)</span><br><span class="line">        <span class="keyword">return</span> sets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 输入一个特定的需要求解的数组</span></span><br><span class="line">    nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    solution = Solution()</span><br><span class="line">    res = solution.permute(nums)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    <span class="comment"># print(&quot;  输出 =&gt; &quot; ,res)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果如下</span></span><br><span class="line"><span class="comment"># 递归之前 =&gt;  [1]</span></span><br><span class="line"><span class="comment"># 递归之前 =&gt;  [1, 2]</span></span><br><span class="line"><span class="comment"># 递归之前 =&gt;  [1, 2, 3]</span></span><br><span class="line"><span class="comment"># 递归之后 =&gt;  [1, 2]</span></span><br><span class="line"><span class="comment"># 递归之后 =&gt;  [1]</span></span><br><span class="line"><span class="comment"># 递归之前 =&gt;  [1, 3]</span></span><br><span class="line"><span class="comment"># 递归之前 =&gt;  [1, 3, 2]</span></span><br><span class="line"><span class="comment"># 递归之后 =&gt;  [1, 3]</span></span><br><span class="line"><span class="comment"># 递归之后 =&gt;  [1]</span></span><br><span class="line"><span class="comment"># 递归之后 =&gt;  []</span></span><br><span class="line"><span class="comment"># 递归之前 =&gt;  [2]</span></span><br><span class="line"><span class="comment"># 递归之前 =&gt;  [2, 1]</span></span><br><span class="line"><span class="comment"># 递归之前 =&gt;  [2, 1, 3]</span></span><br><span class="line"><span class="comment"># 递归之后 =&gt;  [2, 1]</span></span><br><span class="line"><span class="comment"># 递归之后 =&gt;  [2]</span></span><br><span class="line"><span class="comment"># 递归之前 =&gt;  [2, 3]</span></span><br><span class="line"><span class="comment"># 递归之前 =&gt;  [2, 3, 1]</span></span><br><span class="line"><span class="comment"># 递归之后 =&gt;  [2, 3]</span></span><br><span class="line"><span class="comment"># 递归之后 =&gt;  [2]</span></span><br><span class="line"><span class="comment"># 递归之后 =&gt;  []</span></span><br><span class="line"><span class="comment"># 递归之前 =&gt;  [3]</span></span><br><span class="line"><span class="comment"># 递归之前 =&gt;  [3, 1]</span></span><br><span class="line"><span class="comment"># 递归之前 =&gt;  [3, 1, 2]</span></span><br><span class="line"><span class="comment"># 递归之后 =&gt;  [3, 1]</span></span><br><span class="line"><span class="comment"># 递归之后 =&gt;  [3]</span></span><br><span class="line"><span class="comment"># 递归之前 =&gt;  [3, 2]</span></span><br><span class="line"><span class="comment"># 递归之前 =&gt;  [3, 2, 1]</span></span><br><span class="line"><span class="comment"># 递归之后 =&gt;  [3, 2]</span></span><br><span class="line"><span class="comment"># 递归之后 =&gt;  [3]</span></span><br><span class="line"><span class="comment"># 递归之后 =&gt;  []</span></span><br><span class="line"><span class="comment"># 输出 =&gt;  [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]</span></span><br></pre></td></tr></table></figure>

<h1 id="leetcoad47-全排列II-middle"><a href="#leetcoad47-全排列II-middle" class="headerlink" title="leetcoad47-全排列II(middle)"></a>leetcoad47-全排列II(middle)</h1><p>与全排列的区别：给定的数组可以包含重复的数字,如果给定的数组中元素互不相同，那就是一个完全的全排列的问题，所以现在考虑的就是把含有相同的元素的情况给去除掉<br><img src="https://runnerxr.github.io/post-images/1651338150722.png"><br><img src="https://runnerxr.github.io/post-images/1651338329999.png"><br><img src="https://runnerxr.github.io/post-images/1651338364547.png"><br>解决方法：</p>
<ol>
<li>先对数组进行排序</li>
<li>然后对后续出现的相同的搜索进行剪枝操作</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 对原数组进行排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="comment"># 结果集合</span></span><br><span class="line">        sets=[]</span><br><span class="line">        <span class="comment">#每次的子集</span></span><br><span class="line">        subset=[]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建一个布尔数组</span></span><br><span class="line">        <span class="comment"># 每个元素默认一开始没有被选择</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        used = [<span class="literal">False</span>]*n</span><br><span class="line">        <span class="comment"># 执行回溯算法</span></span><br><span class="line">        self.backtrack(nums,subset,used,sets)</span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> sets</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># used表示递归时正在访问的数组元素是否之前已经被访问过</span></span><br><span class="line">    <span class="comment"># nums 表示当前集合中的元素</span></span><br><span class="line">    <span class="comment"># subset 表示每次递归后生成的子集，就是路径上的那些元素,类似于临时的子数组</span></span><br><span class="line">    <span class="comment"># sets 表示最终生成的所有子集合</span></span><br><span class="line">    <span class="comment"># 画出递归树，找到状态变量（回溯函数的参数）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self,nums:<span class="type">List</span>[<span class="built_in">int</span>],subset:<span class="type">List</span>[<span class="built_in">int</span>],used:<span class="type">List</span>[<span class="built_in">int</span>],sets:<span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2、寻找结束条件，由于回溯算法是借助递归实现，所以也就是去寻找递归终止条件</span></span><br><span class="line">        <span class="comment"># 当访问的数组长度等于原数组的长度，递归结束</span></span><br><span class="line">        <span class="comment"># 每次确定好一个子集，都把它加入到结果集合中</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(subset)==n:</span><br><span class="line">            sets.append(subset[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3、确定选择列表，需要把什么数据存储到结果里面</span></span><br><span class="line">        <span class="comment"># for 循环就是一个选择的过程</span></span><br><span class="line">        <span class="comment"># 遍历本层集合中的元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n):</span><br><span class="line">            <span class="comment"># 如果当前的元素的布尔值是False,那么就可以选择该元素</span></span><br><span class="line">            <span class="keyword">if</span> used[i]==<span class="literal">False</span>:</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 4、判断是否需要剪枝，去判断此时存储的数据是否之前已经被存储过</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i-<span class="number">1</span>]==nums[i] <span class="keyword">and</span> used[i-<span class="number">1</span>]==<span class="literal">False</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 把本次递归访问的元素加入到 subset 数组中（剪枝后再加入）</span></span><br><span class="line">                subset.append(nums[i])</span><br><span class="line">                used[i]=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 5、做出选择，递归调用该函数，进入下一层继续搜索</span></span><br><span class="line">                <span class="comment"># 递归</span></span><br><span class="line">                <span class="comment"># 此时需要传入新的参数</span></span><br><span class="line">                self.backtrack( nums,subset ,used,sets)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 6、撤销选择，回到上一层的状态</span></span><br><span class="line">                <span class="comment"># 取消对 nums[i] 的选择</span></span><br><span class="line">                used[i]=<span class="literal">False</span></span><br><span class="line">                subset.pop()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#简化版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        sets=[]</span><br><span class="line">        subset=[]</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        used = [<span class="literal">False</span>]*n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">subset:<span class="type">List</span>[<span class="built_in">int</span>],used:<span class="type">List</span>[<span class="built_in">int</span>],sets:<span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) :</span><br><span class="line">            n = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(subset)==n:</span><br><span class="line">                sets.append(subset[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n):</span><br><span class="line">                <span class="keyword">if</span> used[i]==<span class="literal">False</span>:</span><br><span class="line">                    <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i-<span class="number">1</span>]==nums[i] <span class="keyword">and</span> used[i-<span class="number">1</span>]==<span class="literal">False</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    subset.append(nums[i])</span><br><span class="line">                    used[i]=<span class="literal">True</span></span><br><span class="line">                    backtrack( subset ,used,sets)</span><br><span class="line">                    used[i]=<span class="literal">False</span></span><br><span class="line">                    subset.pop()</span><br><span class="line">        </span><br><span class="line">        backtrack(subset,used,sets)</span><br><span class="line">        <span class="keyword">return</span> sets</span><br></pre></td></tr></table></figure>
<p>5月1号来做，发现还是存在问题，这种小的细节根本就没法把握：</p>
<ol>
<li>结果要以字典序的升序进行排列，所以要预先做一个排序工作</li>
<li>判断剪枝的操作，自己还是打盹了，说明还在犹豫，想这里面的过程<img src="https://runnerxr.github.io/post-images/1651414572252.png">它难就难在这一步的过程</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/21/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B8%80/" data-id="claquc63c002kz0tk5vus0m1i" data-title="搜索算法、回溯算法系列一" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/03/21/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B3%BB%E7%B1%BB%E4%BA%8C/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          搜索算法、回溯算法系类二
        
      </div>
    </a>
  
  
    <a href="/2022/03/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E4%BD%8D%E8%BF%90%E7%AE%97/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">二分查找-位运算</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gridea/" rel="tag">Gridea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" rel="tag">python知识小记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99%E7%9A%84%E5%B0%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/" rel="tag">工作之余的小的编程小知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" rel="tag">算法专栏（用python注写）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0/" rel="tag">读书摘记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Gridea/" style="font-size: 10px;">Gridea</a> <a href="/tags/python%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/" style="font-size: 13.33px;">python知识小记</a> <a href="/tags/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99%E7%9A%84%E5%B0%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/" style="font-size: 16.67px;">工作之余的小的编程小知识</a> <a href="/tags/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F%EF%BC%88%E7%94%A8python%E6%B3%A8%E5%86%99%EF%BC%89/" style="font-size: 20px;">算法专栏（用python注写）</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0/" style="font-size: 10px;">读书摘记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/21/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2022/11/12/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%BA%94%E7%9A%84%E5%90%8C%E6%AD%A5/">搭建自己的博客并进行相应的同步</a>
          </li>
        
          <li>
            <a href="/2022/10/03/vs%20code%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%B7%A5%E5%85%B7%E5%8C%85/">关于vs code导入本地工具包和消除&#39;import [module] could not be resolved in pylance&#39;</a>
          </li>
        
          <li>
            <a href="/2022/09/25/%E5%85%B3%E4%BA%8Ematalab%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">关于matalab的数据分析</a>
          </li>
        
          <li>
            <a href="/2022/07/30/%E5%85%B3%E4%BA%8Epython%E7%88%AC%E8%99%AB%E4%B8%80%E7%82%B9%E5%B0%8F%E7%9A%84%E6%95%B4%E7%90%86/">关于python爬虫一点小的整理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>