<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>
        bear的生活随笔
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico" />
    <link rel="stylesheet" href="/css/style/github.min.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <div class="container">
        <div class="header">
    <!-- <div class="logo">
        <a href="/">bear的生活随笔</a>
    </div> -->
    <div class="logo">
        <img src="/images/logo.png" alt="Logo">
    </div>
    <div class="nav">
        <ul class="menu">
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">
                        Home
                    </a>
                </li>
            
                <li class="menu-item">
                    <a target="_blank" rel="noopener" href="https://github.com/Runnerxr" class="menu-item-link">
                        Github
                    </a>
                </li>
                
        </ul>
    </div>
</div>
        <div class="article">
    <!-- <div class="article-title">
        <h2>
            对Python函数这一块的系统整理（主要来自廖雪峰+平时的一些积累）
        </h2>
    </div> -->
    <div class="article-meta">
        <div class="article-date">
            <i class="fas fa-edit"></i>
            2022/04/11 Mon 23:18&nbsp;&nbsp;&nbsp;
            <span class="just-a-temp"><span>
            <i class="fas fa-redo"></i>
            2022/11/16 Wed 23:41
        </div>
    </div>
    <div class="article-content">
        <p>这一块应该没有什么难度的，但是对于初学小白来说也是非常重要的知识点</p>
<h1 id="一些小的层面的"><a href="#一些小的层面的" class="headerlink" title="一些小的层面的"></a>一些小的层面的</h1><p>函数常用的一些操作：<br>调用函数<br>定义函数<br>函数的参数<br>递归函数<br>函数的高级特性：（印象笔记也整理了一部分，这里相当于是二次整理，只不过可能更加的详细了）</p>
<ol>
<li>切片</li>
<li>迭代</li>
<li>列表生成式</li>
<li>生成器</li>
<li>迭代器</li>
</ol>
<p>函数式编程：</p>
<h1 id="大的层面方向的"><a href="#大的层面方向的" class="headerlink" title="大的层面方向的"></a>大的层面方向的</h1><p><strong>Python函数调用时，参数的传递方式</strong><br>详细内容移步：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/downey-blog/p/10483216.html">https://www.cnblogs.com/downey-blog/p/10483216.html</a>     有兴趣的话后面再吗，慢慢的去结合起来进行全方面的深度理解。</p>
<p>对于C程序员来说，我们都知道C在函数调用时，采用的是值传递，即形参和实参分配不同的内存地址，在调用时将实参的值传给实参，在这种情况下，在函数内修改形参并不会影响到实参，但是这样带来一个问题，如果我们需要刻意地对实参进行修改，就不得不传递实参的指针到函数，然后在函数中修改指针指向的数据，以达到修改实参的目的。</p>
<p>后来，C++中引入了引用这个概念，即在函数定义时，在形参前加一个&amp;符号，表示传递参数的引用，在写法上，除了多出一个&amp;符号，其他部分和C中传值调用一样，但是实际确是达到了可以在函数内修改实参内容的目的。这种参数传递的方式被称为传引用。</p>
<p><strong>python的参数传递</strong></p>
<p><strong>关于各个函数的调用的问题</strong><br>以及各个循环之间的参数是否互不影响的问题？？这也是我在做算法题遇到的一些很小的问题</p>
<h1 id="python类中函数调用要加self"><a href="#python类中函数调用要加self" class="headerlink" title="python类中函数调用要加self"></a>python类中函数调用要加self</h1><p>参考链接：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jessonluo/p/4717140.html">https://www.cnblogs.com/jessonluo/p/4717140.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/stuscs/article/details/40110815">https://blog.csdn.net/stuscs/article/details/40110815</a><br>python中的类方法也是一种对象，既可以通过实例也可以通过类来访问方法，再python里面有两种风格</p>
<ol>
<li>未绑定的类方法：没有self<br>通过类来引用方法返回一个未绑定方法对象。要调用它，你必须显示地提供一个实例作为第一个参数。</li>
<li>绑定的实例方法：有self<br>通过实例访问方法返回一个绑定的方法对象。Python自动地给方法绑定一个实例，所以我们调用它时不用再传一个实例参数。<br>两者的区别：两种方法都是对象，它们可以被传递、存入列表等待。两者运行时都需要一个实例作为第一参数（给予一个self值），但当通过一个实例调用一个绑定方法时Python自动会提供一个。<br>对象调用方法时, 实际上是通过类调用的a &#x3D; muffedcalculator()a.calc(expr)<br>实际上是这样调用的 muffledcalculator.calc(a, expr)这样self 就是 a, python隐含地把a 传进方法 替代了self, 就成了绑定的方法, 就可以执行了. 否则就是非绑定方法(这种方式虽然很抽象，但是子集读了几遍之后大概是理解了,self就像是一个替代品一样)<br><strong>self代表类的实例，而非类</strong></li>
</ol>
<pre><code class="python">class Test:
    def prt(self):
        print(self)
        print(self.__class__)

t = Test()
t.prt()
# 运行结果
# &lt;__main__.Test object at 0x000000000284E080&gt;
# &lt;class &#39;__main__.Test&#39;&gt;
</code></pre>
<p>从上面的例子中可以很明显的看出，self代表的是类的实例。而self.__class__则指向类。(没有太懂)<br><strong>self不必非写成self</strong></p>
<pre><code class="python">class Test:
    def prt(this):
        print(this)
        print(this.__class__)

t = Test()
t.prt()
# 运行结果不变
</code></pre>
<p><strong>self是否可以不写</strong></p>
<pre><code class="python">class Test:
    def prt():
        print(self)

t = Test()
t.prt()
# 运行提示：prt() takes 0 positional arguments but 1 was given（prt在定义的时候没有参数，但是我们运行的时候强行传入了一个参数。t.prt()通过python解释成：Test.prt(t),程序提醒我们多传入了一个参数t）
</code></pre>
<p>如果我们在定义和调用的时候都不传入实例，就是属于类方法</p>
<pre><code class="python">class Test:
    def prt():
        print(__class__)
Test.prt()
# 输出：&lt;class &#39;__main__.Test&#39;&gt; 
</code></pre>
<p><strong>在继承时，传入的是哪个实例，就是那个传入的实例，而不是指定义了self的类的实例</strong></p>
<pre><code class="python"># 定义父类
class Parent:
    # 定义了一个pprt()函数
    def pprt(self):
        print(self)

# 定义一个child类
class Child(Parent):
    # 定义了一个cprt()函数
    def cprt(self):
        print(self)

c = Child()
c.cprt()
# 输出结果：&lt;__main__.Child object at 0x0000000002A47080&gt;
# 指的是child类的实例
c.pprt()
# 输出结果：&lt;__main__.Child object at 0x0000000002A47080&gt;
# 等同于child.pprt(c),self依然是child类的实例，由于self中没有定义pprt()方法，所以沿着继承树往上找，发现在父类Parent中定义了pprt()方法，所以就会成功调用。
p = Parent()
p.pprt()
# 输出结果：&lt;__main__.Parent object at 0x0000000002A47240&gt;


</code></pre>

    </div>

    <div class="totop">ToTOP</div>
</div>
        <div class="footer">
    <a href="#">
        2018 <i class="fab fa-studiovinari"></i> bear <i class="fas fa-angle-double-up"></i>
    </a>
</div>


<script src="/js/totop.js"></script>


<script src="/js/search.js"></script>

    </div>
</body>

</html>